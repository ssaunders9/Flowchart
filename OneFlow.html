<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WSU Engineering Curriculum Flowchart</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸŽ“</text></svg>">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; line-height: 1.6; padding: 1.25rem; background: #f5f5f5; }

        .visually-hidden { position: absolute; left: -10000px; width: 1px; height: 1px; overflow: hidden; }
        
        .skip-link {
            position: absolute;
            top: -100px;
            left: 0;
            background: #A60F2D;
            color: white;
            padding: 8px 16px;
            text-decoration: none;
            z-index: 10000;
            border-radius: 0 0 4px 0;
            font-weight: bold;
            opacity: 0;
            transform: translateY(-100%);
        }
        
        .skip-link:focus {
            top: 0;
            opacity: 1;
            transform: translateY(0);
        }
        
        header { background: #A60F2D; color: white; padding: 1.25rem; margin-bottom: 1.875rem; border-radius: 0.5rem; }
        h1 { font-size: 1.8em; margin-bottom: 0.625rem; }
        .subtitle { font-size: 1.1em; opacity: 0.9; }

        .program-selector { margin-top: 0.938rem; }
        .program-selector label { font-size: 1em; font-weight: bold; margin-right: 0.625rem; display: inline-block; }
        .program-selector select {
            font-size: 1em;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            border: 2px solid white;
            background: white;
            color: #A60F2D;
            font-weight: bold;
            cursor: pointer;
            max-width: 100%;
            min-width: min(300px, 100%);
        }
        .program-selector select option {
            font-weight: bold;
        }
        .program-selector select optgroup {
            font-weight: bold;
        }
        .diagram-wrapper { background: white; padding: 1.875rem; border-radius: 0.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1); overflow-x: auto; position: relative; scroll-behavior: smooth; display: flex; justify-content: flex-start; }
        .diagram-container { position: relative; min-width: 1600px; max-width: max-content; display: flex; gap: 70px; scroll-snap-type: x mandatory; }

        @media (min-width: 1700px) {
            .diagram-wrapper { justify-content: center; }
        }
        .semester-column { flex: 0 0 180px; display: flex; flex-direction: column; gap: 20px; scroll-snap-align: start; }
        .semester-header { font-size: 1em; font-weight: bold; color: white; background: #A60F2D; padding: 0.625rem; border-radius: 0.375rem; text-align: center; margin-bottom: 0.313rem; }
        .semester-header .credits { font-weight: normal; font-size: 0.85em; opacity: 0.9; }
        .course { padding: 0.625rem; border-radius: 0.375rem; border: 3px solid #333; min-height: 4.688rem; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; cursor: pointer; position: relative; z-index: 6; transition: all 0.2s ease; }
        .course:hover { transform: scale(1.05); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
        /* .course:focus removed for static version - no interaction */
        .course.engineering { background: #8fc9f7; border-color: #1565c0; color: #002942; }
        .course.science { background: #a5d6a7; border-color: #2e7d32; color: #003d0a; }
        .course.ucore { background: #ce93d8; border-color: #6a1b9a; color: #1f0030; }
        .course.technical { background: #bdbdbd; border-color: #616161; color: #212121; }
        .course-code { font-weight: bold; font-size: 1em; display: block; margin-bottom: 0.25rem; text-align: center; }
        .course-name { font-size: 0.9em; font-weight: 600; display: block; margin-bottom: 0.25rem; text-align: center; line-height: 1.3; }
        .course-credits { font-size: 0.8em; display: block; text-align: center; }
        
        /* AAA Compliance: Abbreviation - semantic only, no visual styling */
        abbr[title] {
            text-decoration: none;
            cursor: inherit;
        }
        
        .relationship-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #ff9800;
            color: white;
            border-radius: 4px;
            padding: 0.188rem 0.375rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7em;
            font-weight: bold;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            z-index: 200;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5); /* Improves text readability */
        }
        
        .relationship-badge.prereq { background: #b83600; } /* Darkened for better contrast */
        .relationship-badge.coreq { background: #0a2f6e; } /* Darkened for better contrast */
        .relationship-badge.leadsto { background: #7b1fa2; } /* Purple - distinct from all other badges */

        .semester-restriction-badge {
            position: absolute;
            bottom: -8px;
            right: -8px;
            background: #D2691E;
            color: white;
            border-radius: 4px;
            padding: 0.188rem 0.375rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7em;
            font-weight: bold;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            z-index: 200;
        }

        .semester-restriction-badge.fall { background: #8B4513; }
        .semester-restriction-badge.spring { background: #1b5e20; }
        .semester-restriction-badge.summer { background: #c44100; }

        .notes-indicator {
            position: absolute;
            top: -8px;
            left: -8px;
            background: #757575;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75em;
            font-weight: bold;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            z-index: 200;
        }

        /* Line highlighting styles */
        .connection-path { cursor: pointer; }
        .connection-path.highlighted { stroke-width: 2.5 !important; stroke-opacity: 1 !important; }
        .connection-path.faded { display: none; }
        .connection-indicator.highlighted { fill-opacity: 1 !important; }
        .connection-indicator.faded { display: none; }
        .course.highlighted { box-shadow: 0 0 12px rgba(0, 0, 0, 0.5); z-index: 7; }
        
        /* Colored glows for different relationship types */
        .course.highlighted.prereq-glow { box-shadow: 0 0 16px rgba(184, 54, 0, 0.7); } /* Orange glow for prerequisites */
        .course.highlighted.coreq-glow { box-shadow: 0 0 16px rgba(10, 47, 110, 0.7); } /* Blue glow for co-requisites */
        .course.highlighted.leadsto-glow { box-shadow: 0 0 16px rgba(22, 68, 23, 0.7); } /* Green glow for "leads to" */
        
        .course.selected { 
            border: 5px solid #000 !important; 
            box-shadow: 0 0 0 3px #A60F2D !important;
            z-index: 8;
        }
        .course.dimmed { opacity: 0.5; filter: grayscale(60%); transition: opacity 0.2s ease, filter 0.2s ease; z-index: 4 !important; position: relative; }

        /* Enhanced focus indicators for accessibility */
        *:focus {
            outline: 3px solid #A60F2D;
            outline-offset: 2px;
        }

        .course:focus {
            outline: 4px solid #A60F2D;
            outline-offset: 4px;
            box-shadow: 0 0 0 2px white, 0 0 0 6px #A60F2D, 0 0 8px rgba(166, 15, 45, 0.5);
            z-index: 9 !important;
        }

        button:focus, 
        select:focus,
        .notes-indicator:focus,
        .alternatives-indicator:focus {
            outline: 3px solid #A60F2D;
            outline-offset: 2px;
            box-shadow: 0 0 8px rgba(166, 15, 45, 0.5);
        }

        /* High contrast mode support */
        @media (prefers-contrast: high) {
            *:focus {
                outline: 4px solid currentColor;
                outline-offset: 3px;
            }
            
            .course:focus {
                outline: 5px solid currentColor;
                outline-offset: 5px;
                box-shadow: 0 0 0 3px white, 0 0 0 8px currentColor;
            }
        }

        /* Remove focus outline when clicking with mouse (but keep for keyboard) */
        .course:focus:not(:focus-visible) {
            outline: none;
            box-shadow: none;
        }

        button:focus:not(:focus-visible),
        select:focus:not(:focus-visible) {
            outline: 2px solid #A60F2D;
            box-shadow: none;
        }

        .notes-indicator:hover {
            background: #616161;
        }

        .alternatives-indicator {
            position: absolute;
            bottom: -8px;
            left: -8px;
            background: #616161;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6em;
            font-weight: bold;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            z-index: 200;
            cursor: pointer;
            transition: transform 0.2s ease;
            line-height: 1;
        }

        .alternatives-indicator:hover {
            transform: scale(1.1);
            background: #424242;
        }
        
        /* Side Pane for Course Information */
        .course-info-pane {
            position: fixed;
            right: -380px;
            top: 0;
            width: 350px;
            height: 100vh;
            background: white;
            border-left: 2px solid #757575;
            box-shadow: -4px 0 12px rgba(0,0,0,0.2);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            transition: right 0.3s ease;
            overflow-y: auto;
        }
        
        .course-info-pane[aria-hidden="false"] {
            right: 0;
        }
        
        /* Responsive: Bottom drawer on narrow screens */
        @media (max-width: 1024px) {
            .course-info-pane {
                position: fixed;
                right: auto;
                top: auto;
                bottom: -500px;
                left: 0;
                width: 100%;
                height: auto;
                max-height: 30vh;
                border-left: none;
                border-top: 2px solid #757575;
                box-shadow: 0 -4px 12px rgba(0,0,0,0.2);
                transition: bottom 0.3s ease;
                border-radius: 12px 12px 0 0;
                z-index: 9998;
            }
            
            .course-info-pane[aria-hidden="false"] {
                right: auto;
                bottom: 0;
            }
        }
        
        /* Adjust flowchart when pane is open on desktop */
        @media (min-width: 1025px) {
            #flowchart-container {
                transition: margin-right 0.3s ease;
            }
            
            body.pane-open #flowchart-container {
                margin-right: 380px;
            }
        }
        
        .course-info-pane-header {
            position: relative;
            padding: 20px 20px 16px 20px;
            border-bottom: 2px solid #e0e0e0;
            flex-shrink: 0;
        }
        
        .course-info-pane-title {
            font-weight: bold;
            color: #424242;
            font-size: 1.2em;
            margin: 0;
            padding-right: 32px;
        }
        
        .course-info-pane-close {
            position: absolute;
            top: 12px;
            right: 12px;
            background: none;
            border: none;
            font-size: 1.5em;
            color: #666;
            cursor: pointer;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s ease;
            padding: 0;
        }
        
        .course-info-pane-close:hover {
            background: #f0f0f0;
            color: #333;
        }
        
        .course-info-pane-close:focus-visible {
            outline: 2px solid #0d47a1;
        }
        
        .course-info-tabs {
            display: flex;
            gap: 0;
            padding: 0 20px;
            border-bottom: 2px solid #e0e0e0;
            background: #fafafa;
            flex-shrink: 0;
        }
        
        .course-info-tab {
            background: none;
            border: none;
            padding: 12px 16px;
            cursor: pointer;
            color: #666;
            font-weight: 500;
            font-size: 0.95em;
            position: relative;
            border-bottom: 3px solid transparent;
            transition: all 0.2s ease;
            white-space: nowrap;
        }
        
        .course-info-tab:hover {
            color: #333;
            background: #efefef;
        }
        
        .course-info-tab[aria-selected="true"] {
            color: #0d47a1;
            border-bottom-color: #0d47a1;
        }
        
        .course-info-tab:focus-visible {
            outline: 2px solid #0d47a1;
            outline-offset: -3px;
        }
        
        .course-info-panel {
            display: none;
            padding: 20px;
            flex: 1;
            overflow-y: auto;
            animation: fadeIn 0.2s ease;
        }
        
        .course-info-panel.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .course-info-content {
            color: #333;
            line-height: 1.6;
            word-wrap: break-word;
        }
        
        .course-info-content p {
            margin: 0 0 12px 0;
        }
        
        .course-info-content strong {
            color: #424242;
        }
        
        .course-details-row {
            margin-bottom: 12px;
            display: flex;
            flex-direction: column;
        }
        
        .course-details-label {
            font-weight: 600;
            color: #0d47a1;
            font-size: 0.9em;
            margin-bottom: 4px;
        }
        
        .course-details-value {
            color: #333;
            padding-left: 8px;
        }
        
        /* Responsive tab styles for narrow screens */
        @media (max-width: 1024px) {
            .course-info-tabs {
                padding: 0 12px;
                overflow-x: auto;
                flex-wrap: nowrap;
            }
            
            .course-info-tab {
                padding: 10px 12px;
                font-size: 0.9em;
                flex-shrink: 0;
            }
            
            .course-info-panel {
                padding: 16px;
            }
        }
        .text-semester { margin-bottom: 40px; }
        .text-semester h3 { color: #A60F2D; font-size: 1.4em; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 3px solid #A60F2D; }
        .text-semester h4 { font-size: 1.1em; margin-bottom: 8px; color: #333; }
        .text-course { margin-bottom: 15px; padding: 15px; border-left: 5px solid #1565c0; background: #f5f5f5; border-radius: 4px; }
        .text-course.science { border-left-color: #2e7d32; }
        .text-course.ucore { border-left-color: #6a1b9a; }
        .text-course p { margin: 5px 0; color: #666; }
        kbd { background: #fff; border: 1px solid #ccc; border-radius: 3px; padding: 2px 6px; font-family: monospace; font-weight: bold; }
        
        .legend { background: #f0f0f0; padding: 0.938rem; margin-bottom: 1.25rem; border-radius: 0.375rem; border-left: 4px solid #A60F2D; }
        #guideToggle { font-size: 1em; margin-bottom: 0.5rem; color: #A60F2D; cursor: pointer; user-select: none; display: flex; align-items: center; justify-content: space-between; font-weight: bold; border: none; background: none; padding: 0; text-align: left; width: 100%; font-family: Arial, sans-serif; }
        #guideToggle:hover { color: #8a0c24; }
        #guideToggle::after { content: 'â–¼'; font-size: 0.8em; transition: transform 0.3s ease; }
        #guideToggle.collapsed::after { transform: rotate(-90deg); }
        .legend-content { transition: all 0.3s ease; overflow: hidden; }
        .legend-content.hidden { max-height: 0; opacity: 0; margin: 0; }
        .legend-section { margin-bottom: 20px; }
        .legend-section:last-child { margin-bottom: 0; }
        .legend-items { display: flex; flex-wrap: wrap; gap: 20px; }
        .legend-item { display: flex; align-items: center; gap: 8px; }
        .legend-box { width: 30px; height: 30px; border-radius: 4px; border: 3px solid; }
        .legend-box.engineering { background: #8fc9f7; border-color: #1565c0; }
        .legend-box.science { background: #a5d6a7; border-color: #2e7d32; }
        .legend-box.ucore { background: #ce93d8; border-color: #6a1b9a; }
        .legend-box.technical { background: #bdbdbd; border-color: #616161; }
        .legend-label { font-size: 0.9em; font-weight: 500; }
        
        .scroll-indicators { display: flex; justify-content: center; align-items: center; gap: 0.625rem; margin-top: 0.938rem; padding: 0.625rem; }
        .scroll-arrow { position: fixed; background: rgba(255, 255, 255, 0.95); border: 2px solid #A60F2D; color: #A60F2D; width: 56px; height: 56px; border-radius: 50%; cursor: pointer; padding: 0; display: none; align-items: center; justify-content: center; flex-shrink: 0; z-index: 1000; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); transition: right 0.3s ease, left 0.3s ease; }
        .course-info-pane[aria-hidden="false"] ~ .scroll-arrow { display: flex; }
        .scroll-arrow:hover { background: #A60F2D; color: white; box-shadow: 0 4px 12px rgba(166, 15, 45, 0.3); }
        .scroll-arrow:focus-visible { outline: 2px solid #0d47a1; outline-offset: 2px; }
        .scroll-arrow:disabled { opacity: 0.5; cursor: not-allowed; }
        .scroll-left { left: 12px; top: 50%; transform: translateY(-50%); }
        .scroll-right { right: 12px; top: 50%; transform: translateY(-50%); }
        
        /* Adjust right button when pane is open on desktop */
        @media (min-width: 1025px) {
            .course-info-pane[aria-hidden="false"] ~ .scroll-right {
                right: 370px;
            }
        }
        .scroll-dot { width: 10px; height: 10px; border-radius: 50%; background: #ff6b6b; cursor: pointer; border: 2px solid #ff5252; }
        .scroll-dot:hover { background: #A60F2D; border-color: #8a0c24; transform: scale(1.2); }
        .scroll-dot.active { background: #A60F2D; width: 14px; height: 14px; border: 3px solid #8a0c24; box-shadow: 0 0 8px rgba(166, 15, 45, 0.5); }
        .scroll-dot.out-of-view { background: white; border: 2px solid #333; opacity: 1; }
        .scroll-hint { text-align: center; color: #666; font-size: 0.9em; margin-top: 0.625rem; padding: 0.5rem; background: #f9f9f9; border-radius: 0.25rem; }
        
        @media (max-width: 768px) {
            .scroll-hint { font-size: 0.85em; }
        }

        /* Position scroll controls on narrow screens */
        @media (max-width: 1024px) {
            main {
                padding-bottom: 0;
            }

            .scroll-controls {
                position: relative;
                z-index: 100;
                background: white;
                padding: 10px;
                border-top: 1px solid #e0e0e0;
            }
        }
        
        /* AAA Compliance: Respect user motion preferences */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                transition-delay: 0ms !important;
                scroll-behavior: auto !important;
            }
            .course:hover { 
                transform: none !important; 
                box-shadow: 0 4px 8px rgba(0,0,0,0.2) !important;
            }
            .scroll-dot { transition: none !important; }
            .skip-link { transition: none !important; }
            .modal-overlay { animation: none !important; }
        }

        /* Disclaimer Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10001;
            padding: 20px;
        }

        .modal-overlay.hidden {
            display: none;
        }

        .modal-content {
            background: white;
            border-radius: 8px;
            padding: 30px;
            max-width: 600px;
            width: 100%;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .modal-content h2 {
            color: #A60F2D;
            font-size: 1.5em;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .modal-content p {
            line-height: 1.6;
            margin-bottom: 15px;
            color: #333;
        }

        .modal-content ul {
            margin: 15px 0 15px 25px;
            line-height: 1.8;
        }

        .modal-content li {
            margin-bottom: 8px;
        }

        .modal-content a {
            color: #A60F2D;
            text-decoration: underline;
        }

        .modal-content a:hover {
            color: #8a0c24;
        }

        .modal-button {
            background: #A60F2D;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1.1em;
            font-weight: bold;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 20px;
            width: 100%;
        }

        .modal-button:hover {
            background: #8a0c24;
        }

        /* Modal button uses default focus style */

        /* Print Styles */
        @media print {
            /* Page setup for landscape single page */
            @page {
                size: landscape;
                margin: 0.4in;
            }

            /* Hide interactive elements only */
            .skip-link,
            .program-selector,
            .scroll-controls,
            .scroll-indicators,
            .scroll-hint,
            .scroll-arrow,
            #toggleBtn,
            #guideToggle,
            #textView,
            .modal-overlay,
            .course-info-pane {
                display: none !important;
            }

            /* Hide non-essential legend sections: Course Relationships, Additional Indicators, Keyboard Navigation */
            .legend-content .legend-section:nth-of-type(2),
            .legend-content .legend-section:nth-of-type(4),
            .legend-content .legend-section:nth-of-type(5) {
                display: none !important;
            }

            /* Hide "click to view" text in print and interactive navigation */
            @media print {
                .legend-print-hide {
                    display: none !important;
                }
            }

            /* Keep legend visible but hidden content shown */
            .legend {
                display: block !important;
                page-break-inside: avoid;
                page-break-after: avoid;
                margin: 0.1in 0 0 0;
                padding: 0.05in 0.04in;
                border-top: 1px solid #ccc;
                font-size: 0.75em;
                position: relative;
                border-radius: 0;
            }

            .legend-content {
                display: flex !important;
                visibility: visible !important;
                height: auto !important;
                max-height: none !important;
                opacity: 1 !important;
                margin: 0.04in 0 !important;
                gap: 15px;
                flex-wrap: nowrap;
            }

            .legend-content.hidden {
                display: flex !important;
                visibility: visible !important;
                height: auto !important;
                max-height: none !important;
                opacity: 1 !important;
                margin: 0.04in 0 !important;
                gap: 15px;
                flex-wrap: nowrap;
            }

            .legend-section {
                display: block !important;
                page-break-inside: avoid;
                margin-bottom: 0;
                flex-shrink: 0;
            }

            .legend-items {
                display: flex !important;
                flex-wrap: wrap;
                gap: 8px;
            }

            .legend-item {
                display: flex !important;
                align-items: center;
                gap: 3px;
                margin-bottom: 0;
                font-size: 0.8em;
                white-space: nowrap;
            }

            /* Keep body and main container as-is */
            body {
                background: white;
                padding: 0.3in;
            }

            /* Header - reduce padding for print */
            header {
                page-break-after: avoid;
                padding: 0.4rem;
                margin-bottom: 0.4rem;
                border-radius: 0;
            }

            h1 {
                font-size: 1.3em;
                margin-bottom: 0.2rem;
            }

            .subtitle {
                font-size: 0.9em;
            }

            /* Main flowchart container */
            main {
                padding: 0;
            }

            .diagram-wrapper {
                overflow: visible !important;
                box-shadow: none !important;
                /* Use zoom instead of transform to affect document flow */
                zoom: 0.72;
                page-break-inside: avoid;
                margin-bottom: 0;
                margin-top: 0;
                width: auto;
            }

            /* Ensure SVG connections are visible */
            #connectionsSvg {
                display: block !important;
                print-color-adjust: exact;
                -webkit-print-color-adjust: exact;
            }

            /* Ensure connection lines print */
            #connectionsSvg path,
            #connectionsSvg circle,
            #connectionsSvg polygon {
                print-color-adjust: exact;
                -webkit-print-color-adjust: exact;
            }

            /* Ensure course colors print */
            .course {
                print-color-adjust: exact;
                -webkit-print-color-adjust: exact;
                page-break-inside: avoid;
            }

            /* Remove transitions for faster printing */
            * {
                transition: none !important;
                animation: none !important;
            }

            /* Hide tooltips */
            .course-info-tooltip {
                display: none !important;
            }
        }
    
        /* Lane routing styles for static flowchart */
        .diagram-wrapper {
            padding-top: 30px !important;
            padding-bottom: 30px !important;
        }

        .routing-lane {
            position: absolute;
            left: 0;
            right: 0;
            height: 80px;
            background: rgba(230, 230, 230, 0.3);
            border-top: 2px dashed #999;
            border-bottom: 2px dashed #999;
            z-index: 1;
            pointer-events: none;
        }

        .routing-lane.top {
            top: 20px;
        }

        .routing-lane.bottom {
            bottom: 20px;
        }

        .routing-lane-label {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.8em;
            color: #666;
            font-weight: bold;
            background: white;
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid #999;
        }
    
    </style>
</head>
<body>
    <!-- Skip Navigation Link -->
    <header style="position: absolute; top: 0; left: 0; pointer-events: none; z-index: 10000; background: transparent; padding: 0; margin: 0;">
        <a href="#flowchart-container" class="skip-link" style="pointer-events: auto;">Skip to flowchart</a>
    </header>
    
    <!-- Disclaimer Modal -->
    <div id="disclaimerModal" class="modal-overlay" role="dialog" aria-labelledby="disclaimerTitle" aria-modal="true">
        <div class="modal-content">
            <h2 id="disclaimerTitle">Important: Planning Tool Disclaimer</h2>
            <p>This flowchart is provided for <strong>convenience only</strong> to help you visualize your degree plan. The official <a href="https://catalog.wsu.edu/" target="_blank" rel="noopener noreferrer">WSU Course Catalog (opens in new window)</a> is the authoritative reference for all degree requirements.</p>

            <p><strong>Students are responsible for:</strong></p>
            <ul>
                <li>Verifying all course information against the official catalog</li>
                <li>Following <a href="https://registrar.wsu.edu/academic-regulations/#108" target="_blank" rel="noopener noreferrer">WSU Academic Regulations (opens in new window)</a></li>
                <li>Consulting with their academic advisor for questions or concerns</li>
            </ul>

            <p>By using this tool, you acknowledge that it is for planning purposes only and may not reflect the most current information.</p>

            <button class="modal-button" id="disclaimerButton">I Understand</button>
        </div>
    </div>
    
    <header>
        <h1>Washington State University</h1>
        <p class="subtitle">Voiland School of Chemical Engineering and Bioengineering</p>
        <p class="subtitle" id="programTitle">Bachelor of Science - Chemical Engineering (4 Year Plan)</p>
        <div class="program-selector">
            <label for="programSelect">Select Program:</label>
            <select id="programSelect">
                <!-- Options will be populated dynamically from programsData -->
            </select>
        </div>
    </header>
    
    <main id="main-content">
        <h2 class="visually-hidden">Curriculum Flowchart</h2>
        <div class="visually-hidden" role="status" aria-live="assertive">
            <p>This is a static visual representation of the curriculum flowchart. For full accessibility features including keyboard navigation, course details, prerequisite relationships, and interactive functionality, please visit the full flowchart page. This static version provides a complete visual overview but has limited interactive and accessibility capabilities.</p>
        </div>
        <div id="announcements" style="position: absolute; left: -10000px; width: 1px; height: 1px; overflow: hidden;" aria-live="polite" aria-atomic="true"></div>

        <!-- Side Pane for Course Information -->
        <aside id="courseInfoPane" class="course-info-pane" aria-label="Course information details" aria-hidden="true" inert>
            <div class="course-info-pane-header">
                <h2 id="courseInfoHeader" class="course-info-pane-title">Course Information</h2>
                <button class="course-info-pane-close" aria-label="Close course information" id="closeCourseInfoBtn">
                    <span aria-hidden="true">Ã—</span>
                </button>
            </div>
            
            <!-- Single Content Panel (no tabs) -->
            <div class="course-info-panel active" role="region" aria-label="Course details">
                <div class="course-info-content" id="detailsContent"></div>
            </div>
        </aside>

        <!-- User Guide / Legend -->
        <div class="legend">
            <button id="guideToggle" class="collapsed" aria-expanded="false">
                <span><span aria-hidden="true">ðŸ“–</span> How to Use This Tool</span>
            </button>

            <div class="legend-content hidden" id="guideContent">
            <h3 class="visually-hidden">User Guide</h3>
            
            <div class="legend-section">
                <h4 style="font-size: 1em; margin-bottom: 10px; color: #333; font-weight: 600;">Course Types:</h4>
                <div class="legend-items">
                    <div class="legend-item">
                        <div class="legend-box engineering"></div>
                        <span class="legend-label">Engineering</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-box science"></div>
                        <span class="legend-label">Science/Math</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-box ucore"></div>
                        <span class="legend-label">UCORE</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-box technical"></div>
                        <span class="legend-label">Technical Elective</span>
                    </div>
                </div>
            </div>

            <div class="legend-section">
                <h4 style="font-size: 1em; margin-bottom: 10px; color: #333; font-weight: 600;">Course Relationships (click any course to see):</h4>
                <div class="legend-items">
                    <div class="legend-item">
                        <div style="width: 32px; height: 32px; border: 5px solid #000; background: #fff; box-shadow: 0 0 0 3px #A60F2D; border-radius: 4px; margin: 8px;"></div>
                        <span class="legend-label">Selected Course</span>
                    </div>
                    <div class="legend-item">
                        <div style="width: 32px; height: 32px; border: 5px solid #ff9800; background: #fff3e0; box-shadow: 0 0 10px rgba(255, 152, 0, 0.6); border-radius: 4px; margin: 8px; position: relative;">
                            <div style="position: absolute; top: 0; right: 0; transform: translate(50%, -50%); background: #c44100; color: white; border-radius: 3px; padding: 0.1rem 0.25rem; font-size: 0.55em; font-weight: bold; border: 1.5px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.3);">PRE</div>
                        </div>
                        <span class="legend-label">Prerequisites (must take first)</span>
                    </div>
                    <div class="legend-item">
                        <div style="width: 32px; height: 32px; border: 5px solid #2196f3; background: #e3f2fd; box-shadow: 0 0 10px rgba(33, 150, 243, 0.6); border-radius: 4px; margin: 8px; position: relative;">
                            <div style="position: absolute; top: 0; right: 0; transform: translate(50%, -50%); background: #0d47a1; color: white; border-radius: 3px; padding: 0.1rem 0.25rem; font-size: 0.55em; font-weight: bold; border: 1.5px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.3);">CO</div>
                        </div>
                        <span class="legend-label">Co-requisites (take together)</span>
                    </div>
                    <div class="legend-item">
                        <div style="width: 32px; height: 32px; border: 5px solid #4caf50; background: #e8f5e9; box-shadow: 0 0 10px rgba(76, 175, 80, 0.6); border-radius: 4px; margin: 8px; position: relative;">
                            <div style="position: absolute; top: 0; right: 0; transform: translate(50%, -50%); background: #1b5e20; color: white; border-radius: 3px; padding: 0.1rem 0.25rem; font-size: 0.55em; font-weight: bold; border: 1.5px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.3);">â–¶</div>
                        </div>
                        <span class="legend-label">Leads to (unlocks these courses)</span>
                    </div>
                </div>
            </div>

            <div class="legend-section">
                <h4 style="font-size: 1em; margin-bottom: 10px; color: #333; font-weight: 600;">Line Types:</h4>
                <div class="legend-items">
                    <div class="legend-item">
                        <svg width="40" height="24" style="margin: 8px;">
                            <line x1="0" y1="12" x2="40" y2="12" stroke="#333" stroke-width="2.5" stroke-opacity="0.7"/>
                        </svg>
                        <span class="legend-label">Solid line = Prerequisite</span>
                    </div>
                    <div class="legend-item">
                        <svg width="40" height="24" style="margin: 8px;">
                            <line x1="0" y1="12" x2="40" y2="12" stroke="#333" stroke-width="2.5" stroke-opacity="0.7" stroke-dasharray="5,5"/>
                        </svg>
                        <span class="legend-label">Dashed line = Co-requisite</span>
                    </div>
                </div>
            </div>

            <div class="legend-section">
                <h4 style="font-size: 1em; margin-bottom: 10px; color: #333; font-weight: 600;">Additional Indicators:</h4>
                <div class="legend-items">
                    <div class="legend-item">
                        <div style="width: 32px; height: 32px; border: 3px solid #ddd; background: #f5f5f5; border-radius: 4px; position: relative; margin: 10px;">
                            <div style="position: absolute; top: -8px; left: -8px; background: #757575; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-size: 0.7em; font-weight: bold; border: 2px solid white;">i</div>
                        </div>
                        <span class="legend-label">Course has notes<span class="legend-print-hide"> (click to view)</span></span>
                    </div>
                    <div class="legend-item">
                        <div style="width: 32px; height: 32px; border: 3px solid #ddd; background: #f5f5f5; border-radius: 4px; position: relative; margin: 10px;">
                            <div style="position: absolute; bottom: -8px; left: -8px; background: #616161; color: white; border-radius: 50%; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; font-size: 0.65em; font-weight: bold; border: 2px solid white;">OR</div>
                        </div>
                        <span class="legend-label">Course has alternatives<span class="legend-print-hide"> (click to view)</span></span>
                    </div>
                    <div class="legend-item">
                        <div style="width: 32px; height: 32px; border: 3px solid #ddd; background: #f5f5f5; border-radius: 4px; position: relative; margin: 10px;">
                            <div style="position: absolute; bottom: -8px; right: -8px; background: #8B4513; color: white; border-radius: 4px; padding: 3px 6px; font-size: 0.7em; font-weight: bold; border: 2px solid white;">F</div>
                        </div>
                        <span class="legend-label">Fall only</span>
                    </div>
                    <div class="legend-item">
                        <div style="width: 32px; height: 32px; border: 3px solid #ddd; background: #f5f5f5; border-radius: 4px; position: relative; margin: 10px;">
                            <div style="position: absolute; bottom: -8px; right: -8px; background: #1b5e20; color: white; border-radius: 4px; padding: 3px 6px; font-size: 0.7em; font-weight: bold; border: 2px solid white;">Sp</div>
                        </div>
                        <span class="legend-label">Spring only</span>
                    </div>
                </div>
            </div>

            <div class="legend-section">
                <h4 style="font-size: 1em; margin-bottom: 10px; color: #333; font-weight: 600;">Keyboard Navigation:</h4>
                <ul style="margin-left: 20px; line-height: 1.8;">
                    <li><kbd style="background: #fff; border: 1px solid #ccc; border-radius: 3px; padding: 2px 6px; font-family: monospace; font-weight: bold;">Tab</kbd> - Navigate between courses and buttons</li>
                    <li><kbd style="background: #fff; border: 1px solid #ccc; border-radius: 3px; padding: 2px 6px; font-family: monospace; font-weight: bold;">Arrow Keys</kbd> - Move between courses in the grid</li>
                    <li><kbd style="background: #fff; border: 1px solid #ccc; border-radius: 3px; padding: 2px 6px; font-family: monospace; font-weight: bold;">Enter</kbd> or <kbd style="background: #fff; border: 1px solid #ccc; border-radius: 3px; padding: 2px 6px; font-family: monospace; font-weight: bold;">Space</kbd> - Highlight course and show relationships</li>
                    <li><kbd style="background: #fff; border: 1px solid #ccc; border-radius: 3px; padding: 2px 6px; font-family: monospace; font-weight: bold;">I</kbd> - View info (notes and/or alternatives) for the focused course</li>
                    <li><kbd style="background: #fff; border: 1px solid #ccc; border-radius: 3px; padding: 2px 6px; font-family: monospace; font-weight: bold;">Escape</kbd> - Close info panel or clear selection</li>
                </ul>
            </div>
            </div>
        </div>

        <div style="text-align: center; margin-bottom: 20px;">
            <button id="toggleBtn" style="padding: 12px 24px; font-size: 1em; font-weight: bold; background: #A60F2D; color: white; border: 2px solid #A60F2D; border-radius: 6px; cursor: pointer;">
                Switch to Text-Only View
            </button>
        </div>

        <div class="diagram-wrapper" id="flowchart-container">
            <section aria-labelledby="flowchart-heading">
                <h2 id="flowchart-heading" class="visually-hidden">Course Flowchart</h2>
                <div class="diagram-container" id="flowchartContainer">
                    <svg id="fadedConnectionsSvg" aria-hidden="true" role="presentation" focusable="false" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: -1;">
                    </svg>
                    <svg id="connectionsSvg" aria-hidden="true" role="presentation" focusable="false" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5;">
                    </svg>
                </div>
            </section>
        </div>
        
        <div class="scroll-controls">
            <div class="scroll-indicators" role="navigation" aria-label="Semester navigation">
                <div id="scrollIndicators"></div>
            </div>
            <div class="scroll-hint"><span aria-hidden="true">ðŸ’¡</span> Use arrows, swipe, or scroll horizontally to view all semesters â€¢ Click dots to jump to a semester</div>
        </div>
        
        <!-- Fixed position scroll arrow buttons -->
        <button class="scroll-arrow scroll-left" id="scrollLeftBtn" aria-label="Scroll left to previous semesters" title="Previous semesters">
            <svg viewBox="0 0 24 24" width="40" height="40" fill="currentColor" aria-hidden="true" style="margin-right: 2px;">
                <polyline points="15 18 9 12 15 6" stroke="currentColor" stroke-width="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </button>
        <button class="scroll-arrow scroll-right" id="scrollRightBtn" aria-label="Scroll right to next semesters" title="Next semesters">
            <svg viewBox="0 0 24 24" width="40" height="40" fill="currentColor" aria-hidden="true" style="margin-left: 2px;">
                <polyline points="9 18 15 12 9 6" stroke="currentColor" stroke-width="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </button>
        
        <div id="textView" style="display: none; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
            <h2 style="color: #A60F2D; margin-bottom: 20px;">Text-Based Course Listing</h2>
            <div id="textContent"></div>
        </div>
    </main>

    <!-- Load external course data (with cache busting timestamp) -->
    <script src="programsData.js?v=20251021"></script>

    <script>
        // AAA Compliance: Department abbreviation mappings for accessibility
        const DEPT_ABBREVIATIONS = {
            'CHE': 'Chemical Engineering',
            'CHEM': 'Chemistry',
            'MATH': 'Mathematics',
            'PHYS': 'Physics',
            'BIOLOGY': 'Biology',
            'ENGL': 'English',
            'HIST': 'History',
            'ECONS': 'Economics',
            'ELEC': 'Elective'
        };
        
        // Helper function to wrap course code with abbreviation tag for AAA compliance
        function formatCourseCodeWithAbbr(courseCode) {
            const match = courseCode.match(/^([A-Z]+)[\s-]?(\d+.*)$/);
            if (match && DEPT_ABBREVIATIONS[match[1]]) {
                const dept = match[1];
                const number = match[2];
                return `<abbr title="${DEPT_ABBREVIATIONS[dept]}">${dept}</abbr> ${number}`;
            }
            return courseCode;
        }
        
        (function checkBrowserCompatibility() {
            try {
                const testArrow = () => true;
                const testDestructure = { a: 1 };
                const { a } = testDestructure;
                const testTemplate = `test`;

                const missingFeatures = [];

                if (typeof requestAnimationFrame !== 'function') {
                    missingFeatures.push('requestAnimationFrame');
                }
                if (typeof document.querySelector !== 'function') {
                    missingFeatures.push('querySelector');
                }
                if (!('classList' in document.createElement('div'))) {
                    missingFeatures.push('classList');
                }
                if (typeof Array.prototype.forEach !== 'function') {
                    missingFeatures.push('Array.forEach');
                }

                if (missingFeatures.length > 0) {
                    console.warn('Browser compatibility issue. Missing features:', missingFeatures.join(', '));
                    console.warn('Please use a modern browser (Chrome 80+, Firefox 75+, Safari 13.1+, Edge 80+)');
                    alert('This application requires a modern browser. Please update your browser or use Chrome, Firefox, Safari, or Edge.');
                }
            } catch (e) {
                console.error('Browser compatibility check failed:', e);
                alert('This application requires a modern browser. Please update your browser.');
            }
        })();

        // Program data loaded from external file: programsData.js

        // âœ… PHASE 2.1: Centralized configuration constants
        const CONFIG = {
            // Lane routing and conflict detection
            VERTICAL_BUFFER: 60,           // Minimum vertical separation between horizontal segments
            HORIZONTAL_CONFLICT_BUFFER_TOP: 30,    // Buffer for conflict checks when preferring top lane
            HORIZONTAL_CONFLICT_BUFFER_BOTTOM: 15, // Buffer for conflict checks for bottom courses
            STUB_BUFFER: 20,               // Buffer to avoid overlapping with course stubs
            TOP_LANE_DISTANCE_THRESHOLD: 80, // Distance threshold for considering top lane
            LANE_SPACING: 15,              // Spacing between lanes in same semester
            
            // SVG and rendering
            SPATIAL_GRID_CELL_SIZE: 150,  // Grid cell size for spatial indexing (Phase 1.3)
            
            // Visual and layout
            COURSE_MARGIN: 20,             // Margin around course elements
            SEMESTER_GAP_WIDTH: 200,       // Width between semester columns
        };

        // Current program state - default to first program with 'current' status
        let currentProgram = Object.keys(programsData).find(key => programsData[key].status === 'current') ||
                            Object.keys(programsData)[0];
        let courseData = programsData[currentProgram].courseData;
        let semesterOrder = programsData[currentProgram].semesterOrder;

        // Make courseData and semesterOrder available globally
        window.courseData = courseData;
        window.semesterOrder = semesterOrder;

        // âœ… PHASE 2.2: LaneRouter class for managing lane reservations and conflicts
        class LaneRouter {
            constructor(lanes, isVertical = true) {
                this.lanes = lanes || [];
                this.isVertical = isVertical;
            }

            /**
             * Check if a lane segment is available for routing
             * @param {object} lane - Lane to check
             * @param {number} y1 - Start Y position (for vertical) or X position
             * @param {number} y2 - End Y position (for vertical) or end X position
             * @param {object} params - Additional parameters (startY, endY, fromCourse, toCourse, isAdjacentSemester)
             * @returns {boolean} True if lane is available
             */
            isAvailable(lane, y1, y2, params = {}) {
                if (this.isVertical) {
                    return this._isVerticalLaneAvailable(lane, y1, y2, params);
                } else {
                    return this._isHorizontalLaneAvailable(lane, y1, y2, params);
                }
            }

            /**
             * Check if a vertical lane segment is available
             */
            _isVerticalLaneAvailable(lane, y1, y2, params) {
                const { startY = null, endY = null, fromCourse = null, toCourse = null, isAdjacentSemester = false } = params;
                
                if (lane.reservations.length === 0) return true;

                const minY = Math.min(y1, y2);
                const maxY = Math.max(y1, y2);
                const BUFFER = CONFIG.VERTICAL_BUFFER;
                const thisGoingDown = (startY !== null && endY !== null) ? startY < endY : null;

                for (let i = 0; i < lane.reservations.length; i++) {
                    const res = lane.reservations[i];
                    
                    // Rule 1: Same source can share if same routing type
                    if (fromCourse && res.fromCourse === fromCourse) {
                        if (isAdjacentSemester !== res.isAdjacentSemester) return false;
                        if (toCourse && res.toCourse === toCourse) return false;
                        if (thisGoingDown !== null && res.startY !== null && res.endY !== null) {
                            const resGoingDown = res.startY < res.endY;
                            if (thisGoingDown !== resGoingDown) {
                                const resMinY = Math.min(res.y1, res.y2);
                                const resMaxY = Math.max(res.y1, res.y2);
                                if (!(maxY < resMinY || minY > resMaxY)) return false;
                            }
                        }
                        const resMinY = Math.min(res.y1, res.y2);
                        const resMaxY = Math.max(res.y1, res.y2);
                        if (!(maxY < resMinY || minY > resMaxY)) return false;
                        continue;
                    }

                    // Rule 2: Same target CANNOT share lane
                    if (toCourse && res.toCourse && toCourse === res.toCourse) return false;

                    const resMinY = Math.min(res.y1, res.y2);
                    const resMaxY = Math.max(res.y1, res.y2);

                    if (maxY + BUFFER < resMinY || minY - BUFFER > resMaxY) continue;

                    // Check for crossing paths
                    if (thisGoingDown !== null && res.startY !== null && res.endY !== null) {
                        const resGoingDown = res.startY < res.endY;
                        if (thisGoingDown !== resGoingDown) return false;
                    }

                    // Check horizontal segment conflicts
                    if (startY !== null) {
                        if ((res.startY !== null && Math.abs(startY - res.startY) < BUFFER) ||
                            (res.endY !== null && Math.abs(startY - res.endY) < BUFFER)) {
                            return false;
                        }
                    }

                    if (endY !== null) {
                        if ((res.startY !== null && Math.abs(endY - res.startY) < BUFFER) ||
                            (res.endY !== null && Math.abs(endY - res.endY) < BUFFER)) {
                            return false;
                        }
                    }

                    return false;
                }

                return true;
            }

            /**
             * Check if a horizontal lane segment is available
             */
            _isHorizontalLaneAvailable(lane, x1, x2, params) {
                if (lane.reservations.length === 0) return true;

                const minX = Math.min(x1, x2);
                const maxX = Math.max(x1, x2);
                
                if (minX === maxX) return true; // Vertical lines don't reserve horizontal space

                for (let i = 0; i < lane.reservations.length; i++) {
                    const res = lane.reservations[i];
                    if (res.x1 === res.x2) continue; // Skip vertical lines

                    const resMinX = Math.min(res.x1, res.x2);
                    const resMaxX = Math.max(res.x1, res.x2);
                    if (!(maxX < resMinX || minX > resMaxX)) return false;
                }

                return true;
            }

            /**
             * Reserve a lane segment
             */
            reserve(lane, y1, y2, params = {}) {
                if (this.isVertical) {
                    const { fromCourse, startY = null, endY = null, toCourse = null, isAdjacentSemester = false } = params;
                    lane.reservations.push({ y1, y2, fromCourse, startY, endY, toCourse, isAdjacentSemester });
                } else {
                    const { fromCourse } = params;
                    lane.reservations.push({ x1: y1, x2: y2, fromCourse }); // x1, x2 passed as y1, y2
                }
            }

            /**
             * Find best available lane for a range
             */
            findBestLane(y1, y2, targetY = null, params = {}) {
                const availableLanes = this.lanes.filter(lane => 
                    this.isAvailable(lane, y1, y2, params)
                );

                if (availableLanes.length === 0) return null;

                // If no target Y, return first available
                if (targetY === null) return availableLanes[0];

                // Sort by distance to target Y
                availableLanes.sort((a, b) => {
                    const distA = Math.abs(a.y - targetY);
                    const distB = Math.abs(b.y - targetY);
                    return distA - distB;
                });

                return availableLanes[0];
            }
        }

        // Cached DOM elements for performance
        const domCache = {
            flowchartContainer: null,
            visualView: null,
            textView: null,
            textContent: null,
            connectionsSvg: null,
            scrollIndicators: null,
            courseInfoPane: null,
            detailsContent: null,
            courseInfoHeader: null,
            closeCourseInfoBtn: null,
            scrollLeftBtn: null,
            scrollRightBtn: null,
            announcements: null,
            guideToggle: null,
            guideContent: null,
            toggleBtn: null,
            programSelect: null,
            programTitle: null,
            scrollControls: null,
            disclaimerModal: null
        };

        // OPTIMIZATION #2: Global bounding rect cache to avoid repeated layout calculations
        const rectCache = {
            data: new Map(),
            
            // Initialize cache with all course and container rects
            rebuild() {
                this.data.clear();
                
                // Cache container rect
                if (domCache.flowchartContainer) {
                    this.data.set('container', domCache.flowchartContainer.getBoundingClientRect());
                }
                
                // Cache all course element rects
                const courseDivs = document.querySelectorAll('[data-course-key]');
                courseDivs.forEach(div => {
                    const key = div.getAttribute('data-course-key');
                    if (key) {
                        this.data.set(key, div.getBoundingClientRect());
                    }
                });
            },
            
            // Get cached rect or compute if not in cache
            get(keyOrElement) {
                if (typeof keyOrElement === 'string') {
                    return this.data.get(keyOrElement);
                } else if (keyOrElement && keyOrElement.getBoundingClientRect) {
                    // If passed an element, try to find its key or compute
                    const key = keyOrElement.getAttribute?.('data-course-key') || keyOrElement.id;
                    if (key && this.data.has(key)) {
                        return this.data.get(key);
                    }
                    return keyOrElement.getBoundingClientRect();
                }
                return null;
            },
            
            // Clear cache (call when layout changes)
            clear() {
                this.data.clear();
            }
        };

        // Initialize DOM cache
        function initDOMCache() {
            domCache.flowchartContainer = document.getElementById('flowchartContainer');
            domCache.visualView = document.getElementById('flowchart-container');
            domCache.textView = document.getElementById('textView');
            domCache.textContent = document.getElementById('textContent');
            domCache.connectionsSvg = document.getElementById('connectionsSvg');
            domCache.scrollIndicators = document.getElementById('scrollIndicators');
            domCache.courseInfoPane = document.getElementById('courseInfoPane');
            domCache.detailsContent = document.getElementById('detailsContent');
            domCache.courseInfoHeader = document.getElementById('courseInfoHeader');
            domCache.closeCourseInfoBtn = document.getElementById('closeCourseInfoBtn');
            domCache.scrollLeftBtn = document.getElementById('scrollLeftBtn');
            domCache.scrollRightBtn = document.getElementById('scrollRightBtn');
            domCache.announcements = document.getElementById('announcements');
            domCache.guideToggle = document.getElementById('guideToggle');
            domCache.guideContent = document.getElementById('guideContent');
            domCache.toggleBtn = document.getElementById('toggleBtn');
            domCache.programSelect = document.getElementById('programSelect');
            domCache.programTitle = document.getElementById('programTitle');
            domCache.scrollControls = document.querySelector('.scroll-controls');
            domCache.disclaimerModal = document.getElementById('disclaimerModal');
        }

        function buildLeadsToMap() {
            try {
                const leadsToMap = {};

                if (!courseData || typeof courseData !== 'object') {
                    console.error('Invalid courseData');
                    return {};
                }

                // OPTIMIZATION: Use Sets instead of arrays for O(1) lookups
                Object.keys(courseData).forEach(key => {
                    leadsToMap[key] = { asPrereq: new Set(), asCoreq: new Set() };
                });

                Object.entries(courseData).forEach(([courseKey, course]) => {
                    if (!course) return;

                    if (Array.isArray(course.prereqs)) {
                        course.prereqs.forEach(prereqKey => {
                            if (leadsToMap[prereqKey]) {
                                leadsToMap[prereqKey].asPrereq.add(courseKey);
                            }
                        });
                    }

                    if (Array.isArray(course.coreqs)) {
                        course.coreqs.forEach(coreqKey => {
                            if (leadsToMap[coreqKey]) {
                                leadsToMap[coreqKey].asCoreq.add(courseKey);
                            }
                        });
                    }
                });

                return leadsToMap;
            } catch (error) {
                console.error('Error building leads-to map:', error);
                return {};
            }
        }
        
        let leadsToMap = {};
        let selectedCourseKey = null;
        let connectionCounts = {};
        let sourceConnectionCounts = {};
        let currentNotesIndicator = null;

        // COMPREHENSIVE CACHE CLEANUP - Prevents memory leaks on program switch
        function cleanupAllCaches() {
            // Clear primary caches
            if (courseElementCache) courseElementCache.clear();
            if (rectCache) rectCache.clear();
            if (highlightingCache) highlightingCache.clear();
            
            // Clear global lane tracking objects (CRITICAL - previously missing!)
            window.sameSemesterVerticalLanesBySemester = {};
            window.sameSemesterVerticalLanesByCourse = {};
            
            // Clear connection bounding boxes
            if (window.connectionBoundingBoxes) {
                window.connectionBoundingBoxes.clear();
            }
            
            // Clear connection counts
            connectionCounts = {};
            sourceConnectionCounts = {};
            
            // Clear leads-to map
            leadsToMap = {};
            
            // Clear any remaining references
            selectedCourseKey = null;
            currentNotesIndicator = null;
            
            // Log cleanup for debugging (optional)
            console.log('[Memory] All caches cleaned up');
        }

        // OPTIMIZATION #4: Course element cache for reducing DOM queries
        const courseElementCache = {
            data: new Map(),
            
            rebuild() {
                this.data.clear();
                const courseDivs = document.querySelectorAll('[data-course-key]');
                courseDivs.forEach(div => {
                    const key = div.getAttribute('data-course-key');
                    if (key) {
                        this.data.set(key, div);
                    }
                });
            },
            
            get(courseKey) {
                return this.data.get(courseKey);
            },
            
            clear() {
                this.data.clear();
            }
        };

        // OPTIMIZATION #4: Cache for highlighting collections (reduces DOM queries)
        const highlightingCache = {
            allPaths: null,
            allIndicators: null,
            allCourses: null,
            
            rebuild() {
                this.allPaths = document.querySelectorAll('.connection-path');
                this.allIndicators = document.querySelectorAll('.connection-indicator');
                this.allCourses = document.querySelectorAll('[data-course-key]');
            },
            
            clear() {
                this.allPaths = null;
                this.allIndicators = null;
                this.allCourses = null;
            }
        };

        // Helper function: Get course element from cache
        function getCourseElement(courseKey) {
            return courseElementCache.get(courseKey);
        }

        // Helper function: Clear course element cache
        function clearCourseElementCache() {
            courseElementCache.clear();
        }

        /**
         * Show course information in side pane with Details, Notes, and Alternatives tabs
         */
        function showCourseInfo(courseKey, tab = 'details') {
            const course = courseData[courseKey];
            if (!course) return;

            // Check if course has any info to show
            const hasNotes = course.notes && course.notes.trim() !== '';
            const hasAlternatives = course.alternatives && course.alternatives.length > 0;

            const pane = domCache.courseInfoPane;
            const header = domCache.courseInfoHeader;
            const detailsContent = domCache.detailsContent;
            const announcer = domCache.announcements;

            if (!pane || !header || !detailsContent) return;

            // Set header with code, name, and credits
            let headerText = `${course.code} - ${course.name}`;
            if (course.credits) {
                headerText += ` (${course.credits} credits)`;
            }
            header.textContent = headerText;

            // Populate Details tab
            detailsContent.innerHTML = '';
            const detailsDiv = document.createElement('div');
            
            // Course Description (from catalog if available, otherwise full name)
            if (course.description || course.name) {
                const descRow = document.createElement('div');
                descRow.className = 'course-details-row';
                const descLabel = document.createElement('div');
                descLabel.className = 'course-details-label';
                descLabel.textContent = 'Description';
                descRow.appendChild(descLabel);
                const descValue = document.createElement('div');
                descValue.className = 'course-details-value';
                descValue.style.marginBottom = '12px';
                descValue.textContent = course.description || course.name;
                descRow.appendChild(descValue);
                detailsDiv.appendChild(descRow);
            }
            
            // Prerequisites
            if (course.prereqs && course.prereqs.length > 0) {
                const prereqRow = document.createElement('div');
                prereqRow.className = 'course-details-row';
                const prereqCodes = course.prereqs.map(p => courseData[p]?.code || p).join(', ');
                prereqRow.innerHTML = `<div class="course-details-label">Prerequisites</div><div class="course-details-value">${prereqCodes}</div>`;
                detailsDiv.appendChild(prereqRow);
            }
            
            // Co-requisites
            if (course.coreqs && course.coreqs.length > 0) {
                const coreqRow = document.createElement('div');
                coreqRow.className = 'course-details-row';
                const coreqCodes = course.coreqs.map(c => courseData[c]?.code || c).join(', ');
                coreqRow.innerHTML = `<div class="course-details-label">Co-requisites</div><div class="course-details-value">${coreqCodes}</div>`;
                detailsDiv.appendChild(coreqRow);
            }

            // Required For (courses that require this one as prerequisite or corequisite)
            const leadsTo = leadsToMap[courseKey];
            if (leadsTo) {
                const requiredForKeys = [...leadsTo.asPrereq, ...leadsTo.asCoreq];
                if (requiredForKeys.length > 0) {
                    const requiredForRow = document.createElement('div');
                    requiredForRow.className = 'course-details-row';
                    const requiredForCodes = requiredForKeys.map(k => courseData[k]?.code || k).join(', ');
                    requiredForRow.innerHTML = `<div class="course-details-label">Required For</div><div class="course-details-value">${requiredForCodes}</div>`;
                    detailsDiv.appendChild(requiredForRow);
                }
            }

            // Add Notes section if available
            if (hasNotes) {
                const notesSection = document.createElement('div');
                notesSection.style.marginTop = '15px';
                notesSection.style.paddingTop = '15px';
                notesSection.style.borderTop = '1px solid #ddd';
                
                const notesLabel = document.createElement('div');
                notesLabel.className = 'course-details-label';
                notesLabel.textContent = 'Notes';
                notesLabel.style.marginBottom = '8px';
                notesSection.appendChild(notesLabel);
                
                const safeContent = createSafeLinksFromText(course.notes);
                notesSection.appendChild(safeContent);
                detailsDiv.appendChild(notesSection);
            }

            // Add Alternatives section if available
            if (hasAlternatives) {
                const altSection = document.createElement('div');
                altSection.style.marginTop = '15px';
                altSection.style.paddingTop = '15px';
                altSection.style.borderTop = '1px solid #ddd';
                
                const altLabel = document.createElement('div');
                altLabel.className = 'course-details-label';
                altLabel.textContent = 'Alternatives';
                altLabel.style.marginBottom = '8px';
                altSection.appendChild(altLabel);
                
                if (course.alternatives.length === 1) {
                    const altText = document.createElement('div');
                    altText.className = 'course-details-value';
                    altText.textContent = course.alternatives[0];
                    altSection.appendChild(altText);
                } else {
                    course.alternatives.forEach((alt, index) => {
                        const optionDiv = document.createElement('div');
                        optionDiv.className = 'course-details-value';
                        optionDiv.style.marginBottom = '8px';
                        optionDiv.innerHTML = `<strong>Option ${index + 1}:</strong> ${alt}`;
                        altSection.appendChild(optionDiv);
                    });
                }
                detailsDiv.appendChild(altSection);
            }
            
            if (detailsDiv.children.length === 0) {
                detailsDiv.innerHTML = '<p>No details available.</p>';
            }
            
            detailsContent.appendChild(detailsDiv);

            // Show pane
            pane.setAttribute('aria-hidden', 'false');
            pane.removeAttribute('inert'); // Make pane and its contents focusable
            document.body.classList.add('pane-open'); // Add class for CSS adjustments
            currentNotesIndicator = document.querySelector(`.course[data-course-key="${courseKey}"]`);

            // Scroll selected course into view when pane opens (with slight delay for CSS transition)
            setTimeout(() => {
                const selectedCourseDiv = getCourseElement(courseKey);
                const wrapper = domCache.visualView;
                if (selectedCourseDiv && wrapper) {
                    const courseRect = selectedCourseDiv.getBoundingClientRect();
                    const wrapperRect = wrapper.getBoundingClientRect();
                    
                    // Check if course is out of view horizontally
                    if (courseRect.right > wrapperRect.right || courseRect.left < wrapperRect.left) {
                        // Scroll to center the course in the viewport with some padding
                        const courseScrollLeft = selectedCourseDiv.offsetLeft - (wrapperRect.width / 2) + (courseRect.width / 2);
                        wrapper.scrollLeft = courseScrollLeft;
                    }
                }
            }, 310); // Match the CSS transition duration (0.3s = 300ms, +10ms buffer)

            // Store trigger for focus return
            let courseInfoTrigger = document.activeElement;
            window.courseInfoTrigger = courseInfoTrigger;

            // Announce to screen readers with full relationship context
            if (announcer) {
                let announcement = `${course.code} - ${course.name}. `;
                if (course.credits) announcement += `${course.credits} credits. `;
                
                // Add relationship information
                if (course.prereqs && course.prereqs.length > 0) {
                    const prereqCodes = course.prereqs.map(p => courseData[p]?.code || p).join(', ');
                    announcement += `Prerequisites: ${prereqCodes}. `;
                }
                
                if (course.coreqs && course.coreqs.length > 0) {
                    const coreqCodes = course.coreqs.map(c => courseData[c]?.code || c).join(', ');
                    announcement += `Corequisites: ${coreqCodes}. `;
                }
                
                // Calculate and announce "required for"
                const requiredForKeys = [];
                Object.entries(courseData).forEach(([otherKey, otherCourse]) => {
                    if (otherCourse.prereqs && otherCourse.prereqs.includes(courseKey)) {
                        requiredForKeys.push(otherKey);
                    }
                });
                if (requiredForKeys.length > 0) {
                    const requiredForCodes = requiredForKeys.map(k => courseData[k]?.code || k).join(', ');
                    announcement += `Required for: ${requiredForCodes}. `;
                }
                
                if (hasNotes) announcement += `Notes available. `;
                if (hasAlternatives) announcement += `Alternatives available. `;
                announcement += 'Press Escape to close.';
                announcer.textContent = announcement;
            }
        }

        /**
         * Close course information pane and return focus
         */
        window.closeCourseInfo = function() {
            const pane = domCache.courseInfoPane;
            if (pane) {
                pane.setAttribute('aria-hidden', 'true');
                pane.setAttribute('inert', ''); // Make pane and its contents unfocusable
                document.body.classList.remove('pane-open'); // Remove class for CSS adjustments
                // Ensure the pane is actually hidden by removing any inline overrides
                pane.style.removeProperty('right');
                pane.style.removeProperty('bottom');
            }

            if (currentNotesIndicator) {
                currentNotesIndicator = null;
            }

            // Return focus to trigger element
            if (window.courseInfoTrigger && window.courseInfoTrigger.focus) {
                window.courseInfoTrigger.focus();
                window.courseInfoTrigger = null;
            }
        };
        
        // Utility function to safely create links from text and render HTML
        function createSafeLinksFromText(text) {
            // Create a container
            const container = document.createElement('div');

            // Sanitize HTML - allow only <br>, <br/>, <strong>, <em>, <a> tags
            // First, we'll use a temporary div to parse the HTML safely
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = text;

            // Helper to recursively process nodes and sanitize
            function sanitizeNode(node) {
                if (node.nodeType === Node.TEXT_NODE) {
                    return node.cloneNode(true);
                }

                if (node.nodeType === Node.ELEMENT_NODE) {
                    const tagName = node.tagName.toLowerCase();
                    
                    // Allow specific safe tags
                    if (['br', 'strong', 'em', 'b', 'i', 'a', 'p', 'div'].includes(tagName)) {
                        const newNode = document.createElement(tagName);
                        
                        // For links, validate href
                        if (tagName === 'a' && node.href) {
                            try {
                                const url = new URL(node.href);
                                if (url.protocol === 'http:' || url.protocol === 'https:') {
                                    newNode.href = node.href;
                                    newNode.target = '_blank';
                                    newNode.rel = 'noopener noreferrer';
                                }
                            } catch (e) {
                                // Invalid URL - skip href
                            }
                        }
                        
                        // Copy allowed attributes
                        if (tagName === 'a' && node.textContent) {
                            newNode.textContent = node.textContent;
                        } else {
                            // Recursively sanitize child nodes
                            Array.from(node.childNodes).forEach(child => {
                                const sanitized = sanitizeNode(child);
                                if (sanitized) {
                                    newNode.appendChild(sanitized);
                                }
                            });
                        }
                        
                        return newNode;
                    }
                }

                // Return null for disallowed nodes
                return null;
            }

            // Process all child nodes
            Array.from(tempDiv.childNodes).forEach(node => {
                const sanitized = sanitizeNode(node);
                if (sanitized) {
                    container.appendChild(sanitized);
                }
            });

            return container;
        }
        window.clearHighlights = function() {
            // Batch DOM reads and writes for better performance
            // Query once and reuse
            const courses = document.querySelectorAll('.course');

            // Remove all badges and reset styles in a single loop
            courses.forEach(courseDiv => {
                // Remove badge
                const badge = courseDiv.querySelector('.relationship-badge');
                if (badge) badge.remove();

                // Reset classes and styles
                courseDiv.classList.remove('selected', 'highlighted-prereq', 'highlighted-coreq', 'highlighted-leadsto', 'dimmed');
                courseDiv.style.cssText = ''; // Clear all inline styles at once
            });

            // Clear SVG efficiently
            const svg = domCache.connectionsSvg;
            if (svg) {
                // More efficient than innerHTML = ''
                while (svg.firstChild) {
                    svg.removeChild(svg.firstChild);
                }
            }
            
            // âœ… FIX #2: Clear connection tracking objects to prevent memory buildup
            connectionCounts = {};
            sourceConnectionCounts = {};
            if (window.connectionBoundingBoxes) {
                window.connectionBoundingBoxes.clear();
            }

            if (selectedCourseKey) {
                const announcer = domCache.announcements;
                if (announcer) {
                    announcer.textContent = 'Course selection cleared.';
                }
            }

            selectedCourseKey = null;
            
            // Close the course info pane when clearing highlights
            window.closeCourseInfo();
        };
        
        function updateSVGSize() {
            const svg = domCache.connectionsSvg;
            const container = domCache.flowchartContainer;
            const wrapper = domCache.visualView;

            if (!svg || !container || !wrapper) return;

            // Calculate actual content dimensions based on semester columns
            const columns = container.querySelectorAll('.semester-column');
            let contentWidth = 0;
            let contentHeight = 0;

            if (columns.length > 0) {
                // Get the rightmost edge of the last column
                const lastColumn = columns[columns.length - 1];
                const containerRect = container.getBoundingClientRect();
                const lastColumnRect = lastColumn.getBoundingClientRect();
                contentWidth = (lastColumnRect.right - containerRect.left) + 30; // Add some padding

                // Get the tallest column
                columns.forEach(col => {
                    contentHeight = Math.max(contentHeight, col.offsetHeight);
                });
            }

            // Fallback to offsetWidth/Height if no columns found
            const fullWidth = contentWidth || container.offsetWidth;
            const fullHeight = contentHeight || container.offsetHeight;

            svg.style.width = fullWidth + 'px';
            svg.style.height = fullHeight + 'px';
            svg.setAttribute('width', fullWidth);
            svg.setAttribute('height', fullHeight);
            svg.setAttribute('viewBox', `0 0 ${fullWidth} ${fullHeight}`);
        }
        
        function drawConnection(fromKey, toKey, color, type, sourcePositionIndex) {
            const fromDiv = getCourseElement(fromKey);
            const toDiv = getCourseElement(toKey);
            const svg = domCache.connectionsSvg;
            const wrapper = domCache.visualView;
            const container = domCache.flowchartContainer;

            if (!fromDiv || !toDiv || !svg || !wrapper || !container) return;

            // OPTIMIZATION: Use cached rects instead of forcing layout recalculation
            const fromRect = rectCache.get(fromKey) || fromDiv.getBoundingClientRect();
            const toRect = rectCache.get(toKey) || toDiv.getBoundingClientRect();
            const containerRect = rectCache.get('container') || container.getBoundingClientRect();

            const fromCourse = courseData[fromKey];
            const toCourse = courseData[toKey];
            const sameSemester = fromCourse.semester === toCourse.semester;

            let fromX, fromY, toX, toY;

            if (sameSemester) {
                const fromIsAbove = fromRect.top < toRect.top;

                if (fromIsAbove) {
                    fromX = fromRect.left - containerRect.left + fromRect.width / 2;
                    fromY = fromRect.top - containerRect.top + fromRect.height;
                    toX = toRect.left - containerRect.left + toRect.width / 2;
                    toY = toRect.top - containerRect.top;
                } else {
                    fromX = fromRect.left - containerRect.left + fromRect.width / 2;
                    fromY = fromRect.top - containerRect.top;
                    toX = toRect.left - containerRect.left + toRect.width / 2;
                    toY = toRect.top - containerRect.top + toRect.height;
                }
            } else {
                if (!sourceConnectionCounts[fromKey]) {
                    sourceConnectionCounts[fromKey] = 0;
                }

                const sourceIndex = sourceConnectionCounts[fromKey];
                const totalSourceConnections = window.srcTotalConnections[fromKey] || 1;

                let sourceVerticalOffset = 0;
                if (totalSourceConnections > 1) {
                    const spacing = CONFIG.LANE_SPACING;
                    const totalSpread = (totalSourceConnections - 1) * spacing;
                    sourceVerticalOffset = (sourceIndex * spacing) - (totalSpread / 2);
                }

                sourceConnectionCounts[fromKey]++;

                // Use sourcePositionIndex to determine destination point
                // Sources with higher positions get higher destination points
                const totalConnections = window.destTotalConnections[toKey] || 1;

                let destVerticalOffset = 0;
                if (totalConnections > 1 && sourcePositionIndex !== undefined) {
                    const spacing = CONFIG.LANE_SPACING;
                    const totalSpread = (totalConnections - 1) * spacing;
                    destVerticalOffset = (sourcePositionIndex * spacing) - (totalSpread / 2);
                }

                fromX = fromRect.left - containerRect.left + fromRect.width;
                fromY = fromRect.top - containerRect.top + fromRect.height / 2 + sourceVerticalOffset;

                toX = toRect.left - containerRect.left;
                toY = toRect.top - containerRect.top + toRect.height / 2 + destVerticalOffset;
            }
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const d = `M ${fromX} ${fromY} L ${toX} ${toY}`;

            path.setAttribute('d', d);
            path.setAttribute('stroke', color);
            path.setAttribute('stroke-width', '2.5');
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke-opacity', '0.7');
            // Add dashed line for corequisites
            if (type === 'coreq') {
                path.setAttribute('stroke-dasharray', '5,5');
            }
            // Add data attributes for highlighting
            path.setAttribute('data-from-course', fromKey);
            path.setAttribute('data-to-course', toKey);
            path.setAttribute('class', 'connection-path');

            svg.appendChild(path);
        }
        
        function createArrowMarkers() {
            // Arrow markers removed - not currently used
        }

        // Helper function: Highlight selected course
        function highlightSelectedCourse(courseKey) {
            const selectedDiv = getCourseElement(courseKey);
            if (selectedDiv) {
                selectedDiv.classList.add('selected');
                selectedDiv.style.border = '5px solid #000';
                selectedDiv.style.boxShadow = '0 0 0 4px #A60F2D, 0 0 20px rgba(166, 15, 45, 0.5)';
                selectedDiv.style.zIndex = '100';
                selectedDiv.style.opacity = '1';
                selectedDiv.style.filter = 'none';
            }
            return selectedDiv;
        }

        // Helper function: Dim all other courses
        function dimOtherCourses(courseKey, coursesCache = null) {
            // Use cached courses if provided, otherwise query
            const courses = coursesCache || document.querySelectorAll('.course');
            courses.forEach(courseDiv => {
                if (courseDiv.getAttribute('data-course-key') !== courseKey) {
                    courseDiv.classList.add('dimmed');
                    courseDiv.style.opacity = '0.25';
                    courseDiv.style.filter = 'grayscale(80%)';
                }
            });
        }

        // Helper function: Apply relationship styling to a course
        function applyRelationshipStyle(courseDiv, type, badgeText) {
            if (!courseDiv) return;

            const styles = {
                prereq: { border: '5px solid #ff9800', boxShadow: '0 0 15px rgba(255, 152, 0, 0.8)', class: 'highlighted-prereq' },
                coreq: { border: '5px solid #2196f3', boxShadow: '0 0 15px rgba(33, 150, 243, 0.8)', class: 'highlighted-coreq' },
                leadsto: { border: '5px solid #4caf50', boxShadow: '0 0 15px rgba(76, 175, 80, 0.8)', class: 'highlighted-leadsto' }
            };

            const style = styles[type];
            if (!style) return;

            courseDiv.classList.remove('dimmed');
            courseDiv.classList.add(style.class);
            courseDiv.style.border = style.border;
            courseDiv.style.boxShadow = style.boxShadow;
            courseDiv.style.opacity = '1';
            courseDiv.style.filter = 'none';

            const badge = document.createElement('div');
            badge.className = `relationship-badge ${type}`;
            badge.textContent = badgeText;
            badge.setAttribute('aria-hidden', 'true');
            courseDiv.appendChild(badge);
        }

        // Helper function: Highlight prerequisites
        function highlightPrerequisites(prereqKeys) {
            prereqKeys.forEach(prereqKey => {
                const prereqDiv = getCourseElement(prereqKey);
                applyRelationshipStyle(prereqDiv, 'prereq', 'PR');
            });
        }

        // Helper function: Highlight corequisites
        function highlightCorequisites(coreqKeys) {
            coreqKeys.forEach(coreqKey => {
                const coreqDiv = getCourseElement(coreqKey);
                applyRelationshipStyle(coreqDiv, 'coreq', 'CO');
            });
        }

        // Helper function: Highlight courses this leads to
        function highlightLeadsTo(leadsToKeys) {
            leadsToKeys.forEach(leadsToKey => {
                const leadsToDiv = getCourseElement(leadsToKey);
                applyRelationshipStyle(leadsToDiv, 'leadsto', 'â–¶');
            });
        }

        // Helper function: Sort course keys by vertical position
        function sortCoursesByPosition(courseKeys) {
            // OPTIMIZATION: Use cached positions to avoid repeated layout calculations
            const positions = new Map();
            courseKeys.forEach(key => {
                const cachedRect = rectCache.get(key);
                if (cachedRect) {
                    positions.set(key, cachedRect.top);
                } else {
                    // Fallback if not in cache
                    const div = getCourseElement(key);
                    if (div) {
                        positions.set(key, div.getBoundingClientRect().top);
                    }
                }
            });

            return [...courseKeys].sort((a, b) => {
                const posA = positions.get(a);
                const posB = positions.get(b);
                if (posA === undefined || posB === undefined) return 0;
                return posA - posB;
            });
        }

        // Helper function: Calculate connection counts
        function calculateConnectionCounts(courseKey, prereqsSorted, coreqsSorted, leadsToSorted) {
            const destConnectionCounts = {};
            const srcConnectionCounts = {};

            prereqsSorted.forEach(prereqKey => {
                if (!destConnectionCounts[courseKey]) destConnectionCounts[courseKey] = 0;
                destConnectionCounts[courseKey]++;

                if (!srcConnectionCounts[prereqKey]) srcConnectionCounts[prereqKey] = 0;
                srcConnectionCounts[prereqKey]++;
            });

            coreqsSorted.forEach(coreqKey => {
                if (!destConnectionCounts[courseKey]) destConnectionCounts[courseKey] = 0;
                destConnectionCounts[courseKey]++;

                if (!srcConnectionCounts[coreqKey]) srcConnectionCounts[coreqKey] = 0;
                srcConnectionCounts[coreqKey]++;
            });

            leadsToSorted.forEach(leadsToKey => {
                if (!destConnectionCounts[leadsToKey]) destConnectionCounts[leadsToKey] = 0;
                destConnectionCounts[leadsToKey]++;

                if (!srcConnectionCounts[courseKey]) srcConnectionCounts[courseKey] = 0;
                srcConnectionCounts[courseKey]++;
            });

            return { destConnectionCounts, srcConnectionCounts };
        }

        // Helper function: Draw all connection lines
        // ORIGINAL FUNCTION COMMENTED OUT FOR STATIC VERSION
        /*
        function drawAllConnections(courseKey, course, prereqsSorted, coreqsSorted, leadsToSorted, destConnectionCounts, srcConnectionCounts) {
            const courseDiv = getCourseElement(courseKey);
            const courseRect = courseDiv ? courseDiv.getBoundingClientRect() : null;

            // Filter out coreqs in same semester (they use vertical connections without offsets)
            const coreqsDifferentSemester = coreqsSorted.filter(key => {
                const coreqCourse = courseData[key];
                return coreqCourse && coreqCourse.semester !== course.semester;
            });

            const incomingConnections = [
                ...prereqsSorted.map(key => ({ key, type: 'prereq', color: '#ff9800' })),
                ...coreqsDifferentSemester.map(key => ({ key, type: 'coreq', color: '#2196f3' }))
            ];

            // Calculate position and angle from each source to destination
            incomingConnections.forEach(conn => {
                const sourceDiv = getCourseElement(conn.key);
                if (sourceDiv && courseRect) {
                    const sourceRect = sourceDiv.getBoundingClientRect();
                    conn.verticalPos = sourceRect.top + sourceRect.height / 2;
                    const dx = courseRect.left - (sourceRect.left + sourceRect.width);
                    const dy = (courseRect.top + courseRect.height / 2) - (sourceRect.top + sourceRect.height / 2);
                    conn.angle = Math.atan2(dy, dx);
                } else {
                    conn.verticalPos = 0;
                    conn.angle = 0;
                }
            });

            // Sort primarily by vertical position, secondarily by angle
            incomingConnections.sort((a, b) => {
                const verticalDiff = a.verticalPos - b.verticalPos;
                if (Math.abs(verticalDiff) > 20) {
                    return verticalDiff;
                }
                return a.angle - b.angle;
            });

            // Draw all incoming connections
            incomingConnections.forEach((conn, index) => {
                drawConnection(conn.key, courseKey, conn.color, conn.type, index);
            });

            // Draw coreqs in same semester
            const coreqsSameSemester = coreqsSorted.filter(key => {
                const coreqCourse = courseData[key];
                return coreqCourse && coreqCourse.semester === course.semester;
            });
            coreqsSameSemester.forEach(coreqKey => {
                drawConnection(coreqKey, courseKey, '#2196f3', 'coreq', undefined);
            });

            // Calculate and draw outgoing connections
            const outgoingConnections = leadsToSorted.map(key => ({
                key,
                type: 'leadsto',
                color: '#4caf50'
            }));

            outgoingConnections.forEach(conn => {
                const destDiv = getCourseElement(conn.key);
                if (destDiv && courseRect) {
                    const destRect = destDiv.getBoundingClientRect();
                    conn.verticalPos = destRect.top + destRect.height / 2;
                    const dx = destRect.left - (courseRect.left + courseRect.width);
                    const dy = (destRect.top + destRect.height / 2) - (courseRect.top + courseRect.height / 2);
                    conn.angle = Math.atan2(dy, dx);
                } else {
                    conn.verticalPos = 0;
                    conn.angle = 0;
                }
            });

            outgoingConnections.sort((a, b) => {
                const verticalDiff = a.verticalPos - b.verticalPos;
                if (Math.abs(verticalDiff) > 20) {
                    return verticalDiff;
                }
                return a.angle - b.angle;
            });

            outgoingConnections.forEach((conn, index) => {
                drawConnection(courseKey, conn.key, conn.color, conn.type, index);
            });
        }
        */

        // Replacement drawAllConnections function with lane routing
// This replaces the entire original drawAllConnections function

function drawAllConnections() {
    // âœ… PHASE 1.2: Start performance measurement
    performance.mark('svg-render-start');

    const svg = document.getElementById('connectionsSvg');
    if (!svg) return;

    // Clear existing
    while (svg.firstChild) {
        svg.removeChild(svg.firstChild);
    }

    const courseData = window.courseData;
    const semesterOrder = window.semesterOrder;

    if (!courseData || !semesterOrder) {
        console.error('Missing courseData or semesterOrder');
        return;
    }

    // âœ… PHASE 1.2: DocumentFragment for batch rendering - collects all SVG elements before single append
    const svgFragment = document.createDocumentFragment();

    // Initialize global tracking for same-semester vertical lanes
    window.sameSemesterVerticalLanesBySemester = {};
    window.sameSemesterVerticalLanesByCourse = {}; // Track lanes per source course

    // STEP 1: Create internal records for each course
    const courseRecords = {};
    const semesterGaps = {}; // Track gaps between semesters

    // âœ… PHASE 1.2: Helper to create SVG elements with attributes
    function createSVGElement(tagName, attributes = {}) {
        const el = document.createElementNS('http://www.w3.org/2000/svg', tagName);
        Object.entries(attributes).forEach(([key, value]) => {
            if (key === 'style') {
                Object.assign(el.style, value);
            } else {
                el.setAttribute(key, value);
            }
        });
        return el;
    }

    // Helper to get course DOM element
    function getCourseElement(courseKey) {
        return document.querySelector(`[data-course-key="${courseKey}"]`);
    }

    // Helper to get course position and dimensions
    function getCourseRect(courseKey) {
        const el = getCourseElement(courseKey);
        if (!el) return null;
        const rect = el.getBoundingClientRect();
        const svgRect = svg.getBoundingClientRect();
        return {
            left: rect.left - svgRect.left,
            right: rect.right - svgRect.left,
            top: rect.top - svgRect.top,
            bottom: rect.bottom - svgRect.top,
            width: rect.width,
            height: rect.height,
            centerX: (rect.left + rect.right) / 2 - svgRect.left,
            centerY: (rect.top + rect.bottom) / 2 - svgRect.top
        };
    }

    // PERFORMANCE OPTIMIZATION: Convert prerequisite/corequisite arrays to Sets for O(1) lookup
    // Pre-compute sets once to avoid repeated .includes() calls which are O(n)
    const prereqSetsByKey = {};
    const coreqSetsByKey = {};
    Object.keys(courseData).forEach(courseKey => {
        const course = courseData[courseKey];
        prereqSetsByKey[courseKey] = new Set(course.prereqs || []);
        coreqSetsByKey[courseKey] = new Set(course.coreqs || []);
    });

    // Build course records
    Object.keys(courseData).forEach(courseKey => {
        const course = courseData[courseKey];
        const allPrereqs = [...(course.prereqs || []), ...(course.coreqs || [])];

        // Find courses that this course is a prereq/coreq for
        const isPrereqFor = [];
        const isPrereqForWithType = []; // Track type (prereq vs coreq)
        Object.keys(courseData).forEach(otherKey => {
            const other = courseData[otherKey];
            // Use pre-computed Sets for O(1) lookup instead of array .includes()
            if (prereqSetsByKey[otherKey].has(courseKey)) {
                isPrereqFor.push(otherKey);
                isPrereqForWithType.push({ courseKey: otherKey, type: 'prereq' });
            } else if (coreqSetsByKey[otherKey].has(courseKey)) {
                isPrereqFor.push(otherKey);
                isPrereqForWithType.push({ courseKey: otherKey, type: 'coreq' });
            }
        });

        courseRecords[courseKey] = {
            courseKey,
            semester: course.semester,
            prereqCount: allPrereqs.length,
            isPrereqForCount: isPrereqFor.length,
            allPrereqs,
            isPrereqFor,
            isPrereqForWithType, // New: track connection types
            leftStubs: [],  // Will be populated with stub positions
            rightStubs: [], // Will be populated with stub positions
            rect: null      // Will be populated with actual position
        };
    });

    // Get actual positions for all courses
    Object.keys(courseRecords).forEach(key => {
        courseRecords[key].rect = getCourseRect(key);
    });

    // PERFORMANCE OPTIMIZATION: Cache all bounding rects once to avoid repeated reflow triggers
    const boundingRectCache = new Map();
    const svgElement = document.getElementById('connectionsSvg');
    const svgRect = svgElement.getBoundingClientRect();
    boundingRectCache.set('svg', svgRect);
    
    // Cache all course element bounding rects
    Object.keys(courseRecords).forEach(key => {
        const element = getCourseElement(key);
        if (element) {
            boundingRectCache.set(key, element.getBoundingClientRect());
        }
    });

    // PERFORMANCE OPTIMIZATION: Pre-compute sorted course lists by semester
    // These are used in conflict detection and bounding box calculations - avoid rebuilding for each connection
    const courseListBySemester = {};
    semesterOrder.forEach(semester => {
        courseListBySemester[semester] = Object.keys(courseData)
            .filter(k => courseData[k].semester === semester)
            .sort((a, b) => a.localeCompare(b));
    });

    // PERFORMANCE OPTIMIZATION: Build semester index map for O(1) lookups
    // Replace expensive indexOf() calls with O(1) Map.get() operations
    const semesterIndexMap = new Map();
    semesterOrder.forEach((semester, index) => {
        semesterIndexMap.set(semester, index);
    });

    // Filter out courses without positions (not visible)
    const visibleCourses = Object.keys(courseRecords).filter(key => courseRecords[key].rect !== null);

    // STEP 2: Create stubs on left side (one for each prereq/coreq)
    visibleCourses.forEach(courseKey => {
        const record = courseRecords[courseKey];
        const rect = record.rect;
        const count = record.prereqCount;

        if (count > 0) {
            // Distribute stubs evenly on the left side
            for (let i = 0; i < count; i++) {
                const y = rect.top + (rect.height * (i + 1) / (count + 1));
                record.leftStubs.push({
                    x: rect.left,
                    y: y,
                    used: false,
                    fromCourse: null
                });
            }
            // Sort top to bottom
            record.leftStubs.sort((a, b) => a.y - b.y);
        }
    });

    // STEP 3: Create ONE stub on right side per course (all outputs share this stub)
    visibleCourses.forEach(courseKey => {
        const record = courseRecords[courseKey];
        const rect = record.rect;

        if (record.isPrereqForCount > 0) {
            // Single output stub at center-right, positioned at 9% from top of course box
            const outputStubY = rect.top + (rect.height * 0.09);
            record.rightStubs.push({
                x: rect.right,
                y: outputStubY,
                used: false,
                connections: [] // Track all connections using this stub
            });

            // Create vertical lanes for same-semester connections
            // These are X positions where vertical segments can be placed
            if (!record.sameSemesterVerticalLanes) {
                record.sameSemesterVerticalLanes = [];
            }
        }
    });

    // Add vertical lanes for courses that receive same-semester connections from above
    visibleCourses.forEach(courseKey => {
        const record = courseRecords[courseKey];
        const rect = record.rect;

        if (record.hasPrereqsCount > 0 || record.hasCoreqsCount > 0) {
            // Create vertical lanes for same-semester connections
            if (!record.sameSemesterVerticalLanes) {
                record.sameSemesterVerticalLanes = [];
            }
        }
    });

    // STEP 4: Count stubs in each gap and calculate lanes needed
    // First, identify semester positions
    const semesterPositions = {};
    semesterOrder.forEach((semester, idx) => {
        const coursesInSemester = visibleCourses.filter(k => courseRecords[k].semester === semester);
        if (coursesInSemester.length > 0) {
            const rects = coursesInSemester.map(k => courseRecords[k].rect);
            let leftMost = Infinity, rightMost = -Infinity, topMost = Infinity, bottomMost = -Infinity;
            for (const rect of rects) {
                leftMost = Math.min(leftMost, rect.left);
                rightMost = Math.max(rightMost, rect.right);
                topMost = Math.min(topMost, rect.top);
                bottomMost = Math.max(bottomMost, rect.bottom);
            }

            semesterPositions[semester] = {
                index: idx,
                left: leftMost,
                right: rightMost,
                top: topMost,
                bottom: bottomMost,
                centerX: (leftMost + rightMost) / 2
            };
        }
    });

    // Calculate gaps between semesters
    for (let i = 0; i < semesterOrder.length - 1; i++) {
        const currentSem = semesterOrder[i];
        const nextSem = semesterOrder[i + 1];

        if (semesterPositions[currentSem] && semesterPositions[nextSem]) {
            const gapKey = `${currentSem}|${nextSem}`;
            const gapLeft = semesterPositions[currentSem].right;
            const gapRight = semesterPositions[nextSem].left;
            const gapWidth = gapRight - gapLeft;

            // Count COURSES that cross this gap (not connections)
            let courseCount = 0;
            visibleCourses.forEach(fromKey => {
                const fromRecord = courseRecords[fromKey];
                if (fromRecord.semester === currentSem && fromRecord.isPrereqForCount > 0) {
                    // Check if this course has any connections crossing this gap
                    const hasConnectionAcrossGap = fromRecord.isPrereqFor.some(toKey => {
                        const toRecord = courseRecords[toKey];
                        return toRecord && toRecord.rect && toRecord.semester !== currentSem;
                    });
                    if (hasConnectionAcrossGap) {
                        courseCount++;
                    }
                }
            });

            semesterGaps[gapKey] = {
                left: gapLeft,
                right: gapRight,
                width: gapWidth,
                courseCount: courseCount,
                laneCount: courseCount + 2, // Add 2 extra lanes as specified
                lanes: [],
                fromSemester: currentSem,
                toSemester: nextSem
            };

            // Create lane positions (evenly distributed in the gap)
            const laneCount = semesterGaps[gapKey].laneCount;
            for (let l = 0; l < laneCount; l++) {
                const x = gapLeft + (gapWidth * (l + 1) / (laneCount + 1));
                semesterGaps[gapKey].lanes.push({
                    x: x,
                    reservations: [], // Array of {y1, y2, fromCourse}
                    assignedToCourse: null // Track which course is using this lane
                });
            }
        }
    }

    // STEP 5: Create horizontal lanes - one above first course, and between each pair of courses
    const horizontalLanesBySemester = {};
    semesterOrder.forEach(semester => {
        if (!semesterPositions[semester]) return;

        // Get all courses in this semester and their positions
        const coursesInSem = visibleCourses.filter(k => courseRecords[k].semester === semester);
        const courseRects = coursesInSem.map(k => courseRecords[k].rect).sort((a, b) => a.top - b.top);

        horizontalLanesBySemester[semester] = [];

        // Add ONE lane above the first course (positioned between semester header and first course)
        if (courseRects.length > 0) {
            const firstRect = courseRects[0];
            // Get the semester header to calculate position between header and first course
            const semesterColumn = document.querySelector(`[data-semester="${semester}"]`);
            const semesterHeader = semesterColumn?.querySelector('.semester-header');
            const headerRect = semesterHeader?.getBoundingClientRect();

            // Position lane halfway between header bottom and first course top
            let laneY;
            if (headerRect) {
                const gapBetweenHeaderAndCourse = firstRect.top - headerRect.bottom;
                laneY = headerRect.bottom + (gapBetweenHeaderAndCourse / 2);
            } else {
                // Fallback if header not found: 10px above first course
                laneY = firstRect.top - 10;
            }

            horizontalLanesBySemester[semester].push({
                y: laneY,
                reservations: [],
                betweenCourses: null, // Special: above all courses
                isPrimary: true,
                isAboveAll: true // Flag to indicate this is the top lane
            });
        }

        // Add lanes ONLY between each pair of courses
        for (let i = 0; i < courseRects.length - 1; i++) {
            const currentRect = courseRects[i];
            const nextRect = courseRects[i + 1];
            const gap = nextRect.top - currentRect.bottom;

            // Create 2 lanes: primary (closer to top, default) and secondary (backup)
            const spacing = gap / 3;

            // Primary lane (closer to top course, used by default)
            horizontalLanesBySemester[semester].push({
                y: currentRect.bottom + spacing,
                reservations: [],
                betweenCourses: [i, i + 1],
                isPrimary: true // Preferred lane
            });

            // Secondary lane (backup, only used when primary conflicts)
            horizontalLanesBySemester[semester].push({
                y: currentRect.bottom + spacing * 2,
                reservations: [],
                betweenCourses: [i, i + 1],
                isPrimary: false // Backup lane
            });
            // If gap is too small (< 8px), no horizontal lanes in this gap
        }

        // Add ONE lane below the last course
        if (courseRects.length > 0) {
            const lastRect = courseRects[courseRects.length - 1];
            // Position lane below the last course
            const laneY = lastRect.bottom + 20; // 20px below last course

            horizontalLanesBySemester[semester].push({
                y: laneY,
                reservations: [],
                betweenCourses: null, // Special: below all courses
                isPrimary: true,
                isBelowAll: true // Flag to indicate this is the bottom lane
            });
        }
    });

    // STEP 6: Route connections from earliest to latest courses
    const connections = [];

    // Collect all connections
    visibleCourses.forEach(fromKey => {
        const fromRecord = courseRecords[fromKey];
        fromRecord.isPrereqForWithType.forEach(connection => {
            const toKey = connection.courseKey;
            const toRecord = courseRecords[toKey];
            if (toRecord && toRecord.rect) {
                connections.push({
                    from: fromKey,
                    to: toKey,
                    type: connection.type, // 'prereq' or 'coreq'
                    fromRecord,
                    toRecord
                });
            }
        });
    });

    // Sort connections by source position (top to bottom, left to right)
    connections.sort((a, b) => {
        const aRect = a.fromRecord.rect;
        const bRect = b.fromRecord.rect;
        if (Math.abs(aRect.centerY - bRect.centerY) > 5) {
            return aRect.centerY - bRect.centerY;
        }
        return aRect.centerX - bRect.centerX;
    });

    // âœ… PHASE 1.3: Performance tracking for conflict detection
    performance.mark('conflict-detection-start');
    let conflictChecks = 0; // Counter for debugging

    // Helper: Check if a vertical lane segment is available
    // âœ… PHASE 1.3: Optimized with early exits and reduced redundant calculations
    function isLaneAvailable(lane, y1, y2, startY = null, endY = null, fromCourse = null, toCourse = null, isAdjacentSemester = false) {
        conflictChecks++; // Track how many times this is called
        
        // Early exit: if no reservations, lane is available
        if (lane.reservations.length === 0) {
            return true;
        }

        const minY = Math.min(y1, y2);
        const maxY = Math.max(y1, y2);

        // Add buffer zones to prevent horizontal segments from being too close
        const BUFFER = CONFIG.VERTICAL_BUFFER;

        // Cache direction calculation if we have start/end positions
        const thisGoingDown = (startY !== null && endY !== null) ? startY < endY : null;

        // Use traditional for loop for better performance (allows early exit with return)
        for (let i = 0; i < lane.reservations.length; i++) {
            const res = lane.reservations[i];

            // Rule 1: Same source can share if same routing type. Rule 2: Same target cannot share
            if (fromCourse && res.fromCourse === fromCourse) {
                // Same source course - check if different routing types
                if (isAdjacentSemester !== res.isAdjacentSemester) {
                    // Adjacent and multi-semester cannot share lane even from same source
                    return false; // Conflict
                }

                // Same source and same routing type - check if going to same target
                if (toCourse && res.toCourse === toCourse) {
                    // Same source AND same target - this shouldn't happen (duplicate connection)
                    // But if it does, don't allow sharing
                    return false;
                }

                // Same course - check for crossing paths even if same source
                // This prevents adjacent and cross-semester connections from same course from crossing
                if (thisGoingDown !== null && res.startY !== null && res.endY !== null) {
                    const resGoingDown = res.startY < res.endY;

                    // If going in opposite directions, they might cross - check Y-range overlap
                    if (thisGoingDown !== resGoingDown) {
                        const resMinY = Math.min(res.y1, res.y2);
                        const resMaxY = Math.max(res.y1, res.y2);
                        // Quick overlap check: if ranges don't overlap, continue to next
                        if (!(maxY < resMinY || minY > resMaxY)) {
                            return false; // Conflict - paths from same course cross each other
                        }
                    }
                }

                // Otherwise, only check if vertical ranges overlap (no buffer for same course)
                const resMinY = Math.min(res.y1, res.y2);
                const resMaxY = Math.max(res.y1, res.y2);
                if (!(maxY < resMinY || minY > resMaxY)) {
                    return false; // Ranges overlap
                }
                
                continue; // Same source, no conflict, check next reservation
            }

            // Rule 2: Same target CANNOT share lane - must conflict
            if (toCourse && res.toCourse && toCourse === res.toCourse) {
                // Different sources going to same target - CANNOT share lane
                return false; // Conflict
            }

            // Calculate reservation bounds once
            const resMinY = Math.min(res.y1, res.y2);
            const resMaxY = Math.max(res.y1, res.y2);

            // Quick check: if ranges are far apart (no overlap even with buffer), skip detailed checks
            if (maxY + BUFFER < resMinY || minY - BUFFER > resMaxY) {
                continue; // No overlap, check next reservation
            }

            // Ranges overlap or are close - check for conflicts
            const verticalOverlap = true; // We already know they overlap from above check

            // Check for crossing paths
            if (thisGoingDown !== null && res.startY !== null && res.endY !== null) {
                const resGoingDown = res.startY < res.endY;

                // If going in opposite directions and Y-ranges overlap, they will cross
                if (thisGoingDown !== resGoingDown) {
                    return false; // Conflict - paths cross
                }
            }

            // Check if horizontal segments at start/end conflict
            if (startY !== null) {
                if ((res.startY !== null && Math.abs(startY - res.startY) < BUFFER) ||
                    (res.endY !== null && Math.abs(startY - res.endY) < BUFFER)) {
                    return false; // Horizontal conflict at start
                }
            }

            if (endY !== null) {
                if ((res.startY !== null && Math.abs(endY - res.startY) < BUFFER) ||
                    (res.endY !== null && Math.abs(endY - res.endY) < BUFFER)) {
                    return false; // Horizontal conflict at end
                }
            }

            // Vertical overlap exists - this is a conflict
            return false;
        }

        // No conflicts found
        return true;
    }

    // Helper: Check if a horizontal lane segment is available
    // âœ… PHASE 1.3: Optimized with early exits
    function isHorizontalLaneAvailable(lane, x1, x2, checkingFor = null) {
        // Early exit: if no reservations, lane is available
        if (lane.reservations.length === 0) {
            return true;
        }

        const minX = Math.min(x1, x2);
        const maxX = Math.max(x1, x2);
        
        // If this is a vertical line (x1 === x2), it doesn't reserve horizontal lane space
        if (minX === maxX) {
            return true; // Vertical lines can always use any horizontal lane without conflict
        }
        
        // Use traditional for loop for better performance
        for (let i = 0; i < lane.reservations.length; i++) {
            const res = lane.reservations[i];
            
            // Skip reservations that are also vertical lines
            if (res.x1 === res.x2) {
                continue; // Vertical lines don't conflict with anything
            }
            
            const resMinX = Math.min(res.x1, res.x2);
            const resMaxX = Math.max(res.x1, res.x2);
            
            // Check for overlap
            if (!(maxX < resMinX || minX > resMaxX)) {
                return false; // Conflict found
            }
        }
        
        return true; // No conflicts
    }

    // Helper: Find closest available horizontal lane in a semester to a target Y
    function findClosestAvailableHorizontalLane(semester, x1, x2, targetY, preferTopLane = false, debugCourse = null) {
        const lanes = horizontalLanesBySemester[semester];
        if (!lanes || lanes.length === 0) return null;

        let availableLanes = lanes.filter(lane => isHorizontalLaneAvailable(lane, x1, x2, debugCourse));
        if (availableLanes.length === 0) return null;

        // ADDITIONAL FILTER: Avoid Y-positions that conflict with vertical lanes AND stubs
        // Check all gaps adjacent to this semester
        const semIdx = semesterIndexMap.get(semester);
        // Reduce conflict buffer when not preferring top lane - allows more flexibility for bottom courses
        const conflictBuffer = preferTopLane ? CONFIG.HORIZONTAL_CONFLICT_BUFFER_TOP : CONFIG.HORIZONTAL_CONFLICT_BUFFER_BOTTOM;
        const stubBuffer = CONFIG.STUB_BUFFER;

        availableLanes = availableLanes.filter(lane => {
            // If we're preferring top lane and this IS the top lane, skip stub conflict checks
            // The top lane is above all courses, so stub conflicts don't matter
            if (preferTopLane && lane.isAboveAll) {
                // Still need to check vertical lane conflicts below, but skip stub checks
            } else {
                // First check: Does this lane conflict with any stubs in this semester?
                const coursesInSemester = visibleCourses.filter(k => courseRecords[k].semester === semester);
                for (const courseKey of coursesInSemester) {
                    const record = courseRecords[courseKey];

                    // Check left stubs (input stubs)
                    for (const stub of record.leftStubs) {
                        if (Math.abs(lane.y - stub.y) < stubBuffer) {
                            return false; // Lane conflicts with input stub
                        }
                    }

                    // Check right stubs (output stubs)
                    for (const stub of record.rightStubs) {
                        if (Math.abs(lane.y - stub.y) < stubBuffer) {
                            return false; // Lane conflicts with output stub
                        }
                    }
                }
            }

            // Skip conflict detection for non-top lanes when we're not preferring top lane
            // This allows bottom courses to use nearby lanes even if there are vertical conflicts
            if (!preferTopLane && !lane.isAboveAll) {
                return true;
            }

            // When preferring top lane, also skip vertical conflict checks for the top lane itself
            // The top lane is high enough that it shouldn't conflict with most connections
            if (preferTopLane && lane.isAboveAll) {
                return true;
            }

            let hasConflict = false;

            // Check gap to the left (previous semester | this semester)
            if (semIdx > 0) {
                const leftGapKey = `${semesterOrder[semIdx - 1]}|${semester}`;
                const leftGap = semesterGaps[leftGapKey];
                if (leftGap) {
                    // Check if any vertical lane in this gap has a reservation at this Y-position
                    leftGap.lanes.forEach(vLane => {
                        vLane.reservations.forEach(res => {
                            // Check if this horizontal lane's Y conflicts with the vertical lane's Y-range
                            const resMinY = Math.min(res.y1, res.y2);
                            const resMaxY = Math.max(res.y1, res.y2);
                            if (lane.y >= resMinY - conflictBuffer && lane.y <= resMaxY + conflictBuffer) {
                                hasConflict = true;
                            }
                            // Also check startY and endY (horizontal segment positions)
                            if (res.startY !== null && Math.abs(lane.y - res.startY) < conflictBuffer) {
                                hasConflict = true;
                            }
                            if (res.endY !== null && Math.abs(lane.y - res.endY) < conflictBuffer) {
                                hasConflict = true;
                            }
                        });
                    });
                }
            }

            // Check gap to the right (this semester | next semester)
            if (semIdx < semesterOrder.length - 1) {
                const rightGapKey = `${semester}|${semesterOrder[semIdx + 1]}`;
                const rightGap = semesterGaps[rightGapKey];
                if (rightGap) {
                    rightGap.lanes.forEach(vLane => {
                        vLane.reservations.forEach(res => {
                            const resMinY = Math.min(res.y1, res.y2);
                            const resMaxY = Math.max(res.y1, res.y2);
                            if (lane.y >= resMinY - conflictBuffer && lane.y <= resMaxY + conflictBuffer) {
                                hasConflict = true;
                            }
                            if (res.startY !== null && Math.abs(lane.y - res.startY) < conflictBuffer) {
                                hasConflict = true;
                            }
                            if (res.endY !== null && Math.abs(lane.y - res.endY) < conflictBuffer) {
                                hasConflict = true;
                            }
                        });
                    });
                }
            }

            return !hasConflict;
        });

        if (availableLanes.length === 0) return null;

        availableLanes.sort((a, b) => {
            const distA = Math.abs(a.y - targetY);
            const distB = Math.abs(b.y - targetY);

            if (preferTopLane) {
                const topLaneDistanceThreshold = CONFIG.TOP_LANE_DISTANCE_THRESHOLD;
                if (a.isAboveAll && distA <= topLaneDistanceThreshold && !b.isAboveAll) return -1;
                if (b.isAboveAll && distB <= topLaneDistanceThreshold && !a.isAboveAll) return 1;
            }

            if (Math.abs(distA - distB) < 50) {
                if ((a.isPrimary && !a.isAboveAll) && !(b.isPrimary && !b.isAboveAll)) return -1;
                if (!(a.isPrimary && !a.isAboveAll) && (b.isPrimary && !b.isAboveAll)) return 1;
            }

            return distA - distB;
        });

        return availableLanes[0];
    }

    function reserveHorizontalLane(lane, x1, x2, fromCourse) {
        lane.reservations.push({ x1, x2, fromCourse });
    }

    // Helper: Reserve vertical lane segment
    function reserveVerticalLane(lane, y1, y2, fromCourse, startY = null, endY = null, toCourse = null, isAdjacentSemester = false) {
        // y1, y2: vertical segment range
        // startY: Y-position of horizontal segment at the start (from course output to vertical lane)
        // endY: Y-position of horizontal segment at the end (from vertical lane to course input)
        // toCourse: destination course (to enforce same-target cannot share lane rule)
        // isAdjacentSemester: true for adjacent semester direct connections, false for multi-semester
        lane.reservations.push({ y1, y2, fromCourse, startY, endY, toCourse, isAdjacentSemester });
    }

    // Group connections by source course (all connections from same course share one lane)
    const connectionsByCourse = {};
    connections.forEach(conn => {
        if (!connectionsByCourse[conn.from]) {
            connectionsByCourse[conn.from] = [];
        }
        connectionsByCourse[conn.from].push(conn);
    });

    // Helper: Find available lane for specific Y-range in a gap
    function findAvailableLaneForRange(gap, y1, y2, startY = null, endY = null, fromCourse = null, toCourse = null, isAdjacentSemester = false) {
        if (!gap) return null;

        // Simplified: Always use first available lane for all cross-semester courses
        // Adjacent and cross-semester courses for the same source course use DIFFERENT lanes
        for (const lane of gap.lanes) {
            if (isLaneAvailable(lane, y1, y2, startY, endY, fromCourse, toCourse, isAdjacentSemester)) {
                return lane;
            }
        }
        return null; // No available lane
    }

    // 10 distinct high-contrast colors ordered to maximize contrast between adjacent colors
    // Order alternates between warm/cool and light/dark hues for maximum visual separation
    // Pre-computed outside function to avoid array recreation on every call
    const DISTINCT_COLORS = [
        '#e6194b', // Bright Red (warm, saturated)
        '#0891b2', // Cyan (cool, medium)
        '#d4a017', // Golden Yellow (warm, medium-dark)
        '#911eb4', // Purple (cool, dark)
        '#f58231', // Orange (warm, bright)
        '#008080', // Teal (cool, dark)
        '#f032e6', // Magenta (warm-cool, bright)
        '#3cb44b', // Bright Green (cool, saturated)
        '#9a6324', // Brown (warm, dark)
        '#4363d8'  // Bright Blue (cool, saturated)
    ];

    // Helper: Generate a unique color for each course
    function getCourseColor(courseKey, index) {
        // Use modulo to cycle through the 10 colors
        return DISTINCT_COLORS[index % DISTINCT_COLORS.length];
    }

    // Assign colors to courses using graph coloring algorithm
    // Build a conflict graph: courses that overlap in lanes need different colors
    const courseColors = {};
    const conflicts = {}; // conflicts[courseKey] = Set of conflicting courseKeys

    // Initialize conflict tracking
    Object.keys(connectionsByCourse).forEach(courseKey => {
        conflicts[courseKey] = new Set();
    });

    // Detect conflicts using actual bounding box intersection
    const courseKeys = Object.keys(connectionsByCourse);

    // Helper: Calculate bounding box for a connection path
    const getConnectionBoundingBox = (conn) => {
        const fromSem = courseData[conn.from].semester;
        const toSem = courseData[conn.to].semester;

        // Get pre-computed sorted course lists by semester (avoid rebuilding for each call)
        const fromSemesterCourses = courseListBySemester[fromSem];
        const toSemesterCourses = courseListBySemester[toSem];

        const fromIndex = fromSemesterCourses.indexOf(conn.from);
        const toIndex = toSemesterCourses.indexOf(conn.to);

        // Get semester indices for proper numeric comparison
        const fromSemIdx = semesterIndexMap.get(fromSem);
        const toSemIdx = semesterIndexMap.get(toSem);

        // Return bounding box: min/max semester and min/max vertical position
        return {
            semMin: Math.min(fromSemIdx, toSemIdx),
            semMax: Math.max(fromSemIdx, toSemIdx),
            posMin: Math.min(fromIndex, toIndex),
            posMax: Math.max(fromIndex, toIndex),
            fromSem: fromSem,
            toSem: toSem,
            fromIndex: fromIndex,
            toIndex: toIndex
        };
    };

    // Helper: Check if two bounding boxes intersect or are very close
    const boundingBoxesConflict = (box1, box2) => {
        // No horizontal overlap means no conflict
        if (box1.semMax < box2.semMin || box2.semMax < box1.semMin) {
            return false;
        }

        // Same semester connections - only conflict if very close vertically
        if (box1.semMin === box1.semMax && box2.semMin === box2.semMax && box1.semMin === box2.semMin) {
            // Both are same-semester connections in the same semester
            return Math.abs(box1.fromIndex - box2.fromIndex) <= 2 || Math.abs(box1.toIndex - box2.toIndex) <= 2;
        }

        // Calculate overlap in semester space
        const semOverlapStart = Math.max(box1.semMin, box2.semMin);
        const semOverlapEnd = Math.min(box1.semMax, box2.semMax);

        // No semester overlap at all
        if (semOverlapEnd < semOverlapStart) {
            return false;
        }

        // Check vertical overlap - be more conservative
        // Only use tolerance of 1 to avoid over-detecting conflicts
        const expandedBox1Min = box1.posMin - 1;
        const expandedBox1Max = box1.posMax + 1;
        const expandedBox2Min = box2.posMin - 1;
        const expandedBox2Max = box2.posMax + 1;

        // Check if expanded boxes overlap
        const verticalOverlap = !(expandedBox1Max < expandedBox2Min || expandedBox2Max < expandedBox1Min);

        if (!verticalOverlap) return false;

        // Additional check: if lines cross (going in opposite vertical directions) in overlapping semesters
        const direction1 = box1.toIndex - box1.fromIndex; // positive = downward
        const direction2 = box2.toIndex - box2.fromIndex;

        // If they cross each other (opposite directions), that's a strong conflict indicator
        if (direction1 * direction2 < 0) { // Opposite signs
            // But only if they're in the same general area
            const overlap = Math.min(box1.posMax, box2.posMax) - Math.max(box1.posMin, box2.posMin);
            return overlap >= 0;
        }

        // For parallel paths (same direction), only conflict if they're very close
        const verticalDistance = Math.min(
            Math.abs(box1.posMin - box2.posMin),
            Math.abs(box1.posMax - box2.posMax),
            Math.abs(box1.posMin - box2.posMax),
            Math.abs(box1.posMax - box2.posMin)
        );

        return verticalDistance <= 1;
    };

    // PERFORMANCE OPTIMIZATION: Pre-compute all bounding boxes before conflict detection
    // Build a Map to cache bounding boxes for each connection to avoid recalculation in triple-nested loop
    const connectionBoundingBoxes = new Map();
    
    // Pre-compute bounding boxes for all connections in all courses
    Object.keys(connectionsByCourse).forEach(courseKey => {
        connectionsByCourse[courseKey].forEach(conn => {
            connectionBoundingBoxes.set(conn, getConnectionBoundingBox(conn));
        });
    });

    // Build conflict graph based on bounding box intersections
    for (let i = 0; i < courseKeys.length; i++) {
        const course1 = courseKeys[i];
        const conns1 = connectionsByCourse[course1];

        for (let j = i + 1; j < courseKeys.length; j++) {
            const course2 = courseKeys[j];
            const conns2 = connectionsByCourse[course2];

            // Check if any pair of connections from these courses conflict
            let hasConflict = false;
            for (const conn1 of conns1) {
                const box1 = connectionBoundingBoxes.get(conn1);

                for (const conn2 of conns2) {
                    const box2 = connectionBoundingBoxes.get(conn2);

                    if (boundingBoxesConflict(box1, box2)) {
                        hasConflict = true;
                        break;
                    }
                }
                if (hasConflict) break;
            }

            if (hasConflict) {
                conflicts[course1].add(course2);
                conflicts[course2].add(course1);
            }
        }
    }

    // Greedy graph coloring: assign minimum color that doesn't conflict
    // Use maximally distinct colors with good contrast on white background
    const colorPalette = [
        '#e6194b', // Vivid Red
        '#3cb44b', // Vivid Green
        '#4363d8', // Vivid Blue
        '#f58231', // Vivid Orange
        '#911eb4', // Vivid Purple
        '#008080', // Teal
        '#9a6324', // Brown
        '#800000', // Maroon
        '#808000', // Olive
        '#000075', // Navy
        '#ff6b6b', // Coral Red
        '#4ecdc4', // Turquoise
        '#00d2d3', // Aqua
        '#ff6348', // Tomato
        '#1dd1a1', // Seafoam
        '#d4a017', // Golden Yellow
        '#10ac84', // Emerald
        '#576574', // Gray
        '#ee5a6f', // Rose
        '#c44569', // Blush
        '#d68910', // Dark Gold
        '#2e86ab', // Ocean Blue
        '#a23b72', // Plum
        '#7209b7', // Deep Purple
        '#06a77d', // Jade
        '#d62828', // Crimson
        '#f77f00', // Pumpkin
        '#2a9d8f', // Persian Green
        '#e76f51', // Burnt Sienna
        '#6a4c93', // Royal Purple
        '#1982c4', // Blue NCS
        '#8ac926', // Android Green
        '#ff595e', // Red Salsa
        '#06aed5', // Blue Green
        '#dd1c1a', // Fire Engine Red
        '#023e8a', // USAFA Blue
        '#0077b6', // Blue Sapphire
        '#7209b7', // Purple X11
        '#9d0208', // Rosewood
        '#ba181b'  // Engineering Red
    ];

    // Sort courses by visual position: top-to-bottom, left-to-right (by semester, then by vertical position)
    const sortedCourses = courseKeys.sort((a, b) => {
        const semA = courseData[a].semester;
        const semB = courseData[b].semester;
        
        // First, sort by semester order (O(1) lookup with map instead of O(n) indexOf)
        const semIndexA = semesterIndexMap.get(semA);
        const semIndexB = semesterIndexMap.get(semB);
        
        if (semIndexA !== semIndexB) {
            return semIndexA - semIndexB;
        }
        
        // Within same semester, sort by vertical position (top to bottom)
        // Use pre-computed course lists instead of rebuilding
        const semesterCourses = courseListBySemester[semA];
        
        const indexA = semesterCourses.indexOf(a);
        const indexB = semesterCourses.indexOf(b);
        
        return indexA - indexB;
    });

    // Helper: Calculate color distance (perceptual difference)
    const hexToRgb = (hex) => {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    };

    const colorDistance = (color1, color2) => {
        const rgb1 = hexToRgb(color1);
        const rgb2 = hexToRgb(color2);
        if (!rgb1 || !rgb2) return 1000; // Large distance for invalid colors

        // Use weighted Euclidean distance (closer to perceptual difference)
        const rDiff = rgb1.r - rgb2.r;
        const gDiff = rgb1.g - rgb2.g;
        const bDiff = rgb1.b - rgb2.b;
        return Math.sqrt(2 * rDiff * rDiff + 4 * gDiff * gDiff + 3 * bDiff * bDiff);
    };

    // Helper: Check if color has sufficient contrast against white background
    const hasGoodContrast = (color) => {
        const rgb = hexToRgb(color);
        if (!rgb) return false;

        // Calculate relative luminance (WCAG formula)
        const rsRGB = rgb.r / 255;
        const gsRGB = rgb.g / 255;
        const bsRGB = rgb.b / 255;

        const r = rsRGB <= 0.03928 ? rsRGB / 12.92 : Math.pow((rsRGB + 0.055) / 1.055, 2.4);
        const g = gsRGB <= 0.03928 ? gsRGB / 12.92 : Math.pow((gsRGB + 0.055) / 1.055, 2.4);
        const b = bsRGB <= 0.03928 ? bsRGB / 12.92 : Math.pow((bsRGB + 0.055) / 1.055, 2.4);

        const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;

        // White has luminance of 1.0
        // Contrast ratio = (lighter + 0.05) / (darker + 0.05)
        const contrastRatio = (1.0 + 0.05) / (luminance + 0.05);

        // Require contrast ratio of at least 3:1 for good visibility
        return contrastRatio >= 3.0;
    };

    // Assign colors with gap-awareness: ensure no duplicate colors in same gap
    const numColors = 10;
    
    // First, assign initial colors sequentially
    sortedCourses.forEach((courseKey, index) => {
        courseColors[courseKey] = getCourseColor(courseKey, index);
    });
    
    // Now check each gap and reassign colors if there are conflicts
    // Build a map of which courses appear in each gap
    const coursesPerGap = {}; // gapKey -> Set of courseKeys
    
    sortedCourses.forEach(courseKey => {
        const conns = connectionsByCourse[courseKey];
        if (!conns) return;
        
        conns.forEach(conn => {
            const fromSem = courseData[conn.from].semester;
            const toSem = courseData[conn.to].semester;
            const fromSemIdx = semesterIndexMap.get(fromSem);
            const toSemIdx = semesterIndexMap.get(toSem);
            
            // Track all gaps this connection crosses
            for (let semIdx = fromSemIdx; semIdx < toSemIdx; semIdx++) {
                const currentSem = semesterOrder[semIdx];
                const nextSem = semesterOrder[semIdx + 1];
                const gapKey = `${currentSem}|${nextSem}`;
                
                if (!coursesPerGap[gapKey]) {
                    coursesPerGap[gapKey] = new Set();
                }
                coursesPerGap[gapKey].add(courseKey);
            }
        });
    });
    
    // For each gap, check for color conflicts and reassign if needed
    Object.keys(coursesPerGap).forEach(gapKey => {
        const coursesInGap = Array.from(coursesPerGap[gapKey]);
        const usedColors = new Set();
        const conflicts = [];
        
        // Find conflicts
        coursesInGap.forEach(courseKey => {
            const color = courseColors[courseKey];
            if (usedColors.has(color)) {
                conflicts.push(courseKey);
            } else {
                usedColors.add(color);
            }
        });
        
        // Reassign colors for conflicting courses
        conflicts.forEach(courseKey => {
            // Find a color not used in this gap
            for (let i = 0; i < numColors; i++) {
                const candidateColor = getCourseColor(courseKey, i);
                if (!usedColors.has(candidateColor)) {
                    courseColors[courseKey] = candidateColor;
                    usedColors.add(candidateColor);
                    break;
                }
            }
        });
    });

    // Global tracking: which course owns which lane in each gap
    // Format: globalVerticalLanes[courseKey][gapKey] = lane object
    const globalVerticalLanes = {};
    // Format: globalHorizontalLanes[courseKey][semester] = lane object
    const globalHorizontalLanes = {};

    // Initialize tracking for all courses
    Object.keys(connectionsByCourse).forEach(fromCourseKey => {
        globalVerticalLanes[fromCourseKey] = {};
        globalHorizontalLanes[fromCourseKey] = {};
    });

    // âœ… PHASE 2.3: Create LaneRouter instances for each gap (vertical lanes)
    const verticalLaneRouters = {};
    Object.keys(semesterGaps).forEach(gapKey => {
        const gap = semesterGaps[gapKey];
        if (gap && gap.lanes) {
            verticalLaneRouters[gapKey] = new LaneRouter(gap.lanes, true);
        }
    });

    // âœ… PHASE 2.3: Create LaneRouter instances for horizontal lanes
    const horizontalLaneRouters = {};
    Object.keys(horizontalLanesBySemester).forEach(semester => {
        const lanes = horizontalLanesBySemester[semester];
        if (lanes) {
            horizontalLaneRouters[semester] = new LaneRouter(lanes, false);
        }
    });

    // Route connections course by course
    Object.keys(connectionsByCourse).forEach(fromCourseKey => {
        const courseConnections = connectionsByCourse[fromCourseKey];
        const fromRecord = courseRecords[fromCourseKey];

        if (!fromRecord || !fromRecord.rightStubs[0]) return;

        const outputStub = fromRecord.rightStubs[0];

        // Get the color for this course (all its lines will be this color)
        const courseColor = courseColors[fromCourseKey];

        // Sort connections by priority for stub assignment
        // Priority: same semester (top down) > earlier semesters (earliest first, top down) > later semesters (top down)
        const fromSemIdx = semesterIndexMap.get(fromRecord.semester);

        const sortedConnections = [...courseConnections].sort((connA, connB) => {
            const toSemIdxA = semesterIndexMap.get(connA.toRecord.semester);
            const toSemIdxB = semesterIndexMap.get(connB.toRecord.semester);

            const isSameSemA = toSemIdxA === fromSemIdx;
            const isSameSemB = toSemIdxB === fromSemIdx;
            const isEarlierA = toSemIdxA < fromSemIdx;
            const isEarlierB = toSemIdxB < fromSemIdx;

            // NEW PRIORITY ORDER:
            // 1. Cross-semester connections (non-adjacent) - highest priority
            // 2. Same semester connections (adjacent)
            // 3. Within each group, by position

            // Cross-semester (not same semester) gets priority
            if (!isSameSemA && isSameSemB) return -1;  // A is cross-semester, B is same
            if (isSameSemA && !isSameSemB) return 1;   // B is cross-semester, A is same

            // If both same semester, sort by position in semester (higher courses first)
            if (isSameSemA && isSameSemB) {
                return connA.toRecord.rect.top - connB.toRecord.rect.top;
            }

            // If both cross-semester, earlier semesters get priority
            if (!isSameSemA && !isSameSemB) {
                // Earlier semester connections first
                if (isEarlierA && !isEarlierB) return -1;
                if (!isEarlierA && isEarlierB) return 1;
                
                // If both earlier or both later, sort by semester distance
                if (toSemIdxA !== toSemIdxB) return toSemIdxA - toSemIdxB;
                
                // Same semester, sort by position
                return connA.toRecord.rect.top - connB.toRecord.rect.top;
            }

            // Fallback
            return connA.toRecord.rect.top - connB.toRecord.rect.top;
        });

        // Now route each connection from this course (in priority order)
        sortedConnections.forEach(conn => {
            const toRecord = conn.toRecord;

            const availableInputStubs = toRecord.leftStubs.filter(s => !s.used);
            if (availableInputStubs.length === 0) return;

            // Prioritize input stubs based on connection type
            // 2. Adjacent same semester (highest stub)
            // 3. Adjacent same semester (lower stubs)

            const fromSemester = fromRecord.semester;
            const toSemester = toRecord.semester;
            const fromSemIdx = semesterIndexMap.get(fromSemester);
            const toSemIdx = semesterIndexMap.get(toSemester);
            const isSameSemester = fromSemIdx === toSemIdx;

            // Sort available input stubs based on priority
            availableInputStubs.sort((a, b) => {
                if (!isSameSemester) {
                    // Cross-semester connection
                    // Priority 1: Highest cross semester output gets highest stub (lowest Y value)
                    // Simply assign top to bottom for cross-semester
                    return a.y - b.y;
                } else {
                    // Same semester (adjacent) connection
                    // Priority 2: Highest stub first (lowest Y)
                    // Priority 3: Then lower stubs (higher Y)
                    return a.y - b.y;
                }
            });

            const inputStub = availableInputStubs[0];
            inputStub.used = true;
            inputStub.fromCourse = conn.from;

            // Determine if connection crosses semesters
            const sameSemester = conn.fromRecord.semester === conn.toRecord.semester;

            if (sameSemester) {
                // Same-semester connection - use vertical lanes and horizontal lane routing
                const currentSemester = conn.fromRecord.semester;

                // Determine if going down (use bottom->top stubs) or up (use top->bottom stubs)
                const fromRect = conn.fromRecord.rect;
                const toRect = conn.toRecord.rect;
                const goingDown = fromRect.centerY < toRect.centerY;

                // Allocate a single vertical lane for this connection
                // All connections from the same source course share the same vertical lane
                // Both source and target use the same X position for their vertical segments

                // Track vertical lanes per SOURCE COURSE in this semester
                if (!window.sameSemesterVerticalLanesByCourse) {
                    window.sameSemesterVerticalLanesByCourse = {};
                }
                if (!window.sameSemesterVerticalLanesBySemester) {
                    window.sameSemesterVerticalLanesBySemester = {};
                }
                if (!window.sameSemesterVerticalLanesBySemester[currentSemester]) {
                    window.sameSemesterVerticalLanesBySemester[currentSemester] = [];
                }

                // Check if this source course already has a vertical lane assigned
                const courseKey = `${currentSemester}:${conn.from}`;
                let sharedX;

                if (window.sameSemesterVerticalLanesByCourse[courseKey]) {
                    // Reuse existing lane for this source course
                    sharedX = window.sameSemesterVerticalLanesByCourse[courseKey];
                } else {
                    // Allocate a new lane for this source course
                    const semesterLeft = semesterPositions[currentSemester].left;
                    const semesterRight = semesterPositions[currentSemester].right;
                    const semesterWidth = semesterRight - semesterLeft;
                    const semesterCenterX = (semesterLeft + semesterRight) / 2;

                    const existingLanes = window.sameSemesterVerticalLanesBySemester[currentSemester].length;
                    const laneSpacing = semesterWidth / 10; // Space lanes across semester width

                    // Start from center and alternate left/right for each new lane
                    if (existingLanes === 0) {
                        sharedX = semesterCenterX; // First lane at center of semester
                    } else if (existingLanes % 2 === 1) {
                        // Odd number of lanes: place to the right
                        sharedX = semesterCenterX + laneSpacing * Math.ceil(existingLanes / 2);
                    } else {
                        // Even number of lanes: place to the left
                        sharedX = semesterCenterX - laneSpacing * (existingLanes / 2);
                    }

                    // Track this lane globally for the semester
                    window.sameSemesterVerticalLanesBySemester[currentSemester].push({
                        x: sharedX,
                        reserved: true,
                        forCourse: conn.from,
                        minY: Math.min(fromRect.centerY, toRect.centerY),
                        maxY: Math.max(fromRect.centerY, toRect.centerY)
                    });

                    // Store the lane X position for this source course
                    window.sameSemesterVerticalLanesByCourse[courseKey] = sharedX;
                }

                // Create stub positions using the shared vertical lane X position
                let startStub, endStub;
                if (goingDown) {
                    // Going down: use bottom of source, top of target
                    startStub = { x: sharedX, y: fromRect.bottom };
                    endStub = { x: sharedX, y: toRect.top };
                } else {
                    // Going up: use top of source, bottom of target
                    startStub = { x: sharedX, y: fromRect.top };
                    endStub = { x: sharedX, y: toRect.bottom };
                }

                // Find appropriate horizontal lane between the two courses
                // IMPORTANT: Each connection needs its own lane to avoid overlaps
                let horizLane = null;
                const semesterLanes = horizontalLanesBySemester[currentSemester];
                if (semesterLanes && semesterLanes.length > 0) {
                    const minY = Math.min(startStub.y, endStub.y);
                    const maxY = Math.max(startStub.y, endStub.y);
                    const minX = Math.min(startStub.x, endStub.x);
                    const maxX = Math.max(startStub.x, endStub.x);

                    // Filter lanes that are ONLY between the two courses
                    // Do NOT use the top lane for same-semester connections
                    const lanesBetween = semesterLanes.filter(lane =>
                        !lane.isAboveAll && lane.y > minY && lane.y < maxY
                    );

                    if (lanesBetween.length > 0) {
                        // Sort lanes by preference (primary first)
                        const prioritizedLanes = lanesBetween.sort((a, b) => {
                            if (a.isPrimary && !b.isPrimary) return -1;
                            if (!a.isPrimary && b.isPrimary) return 1;
                            return 0;
                        });

                        // Find first available lane (checking for conflicts)
                        for (const lane of prioritizedLanes) {
                            if (isHorizontalLaneAvailable(lane, minX, maxX, `${fromCourseKey}->${conn.to}`)) {
                                horizLane = lane;
                                break;
                            }
                        }

                        // If no available lane in between, try closest available
                        if (!horizLane) {
                            horizLane = findClosestAvailableHorizontalLane(
                                currentSemester,
                                minX,
                                maxX,
                                (startStub.y + endStub.y) / 2
                            );
                        }
                    } else {
                        // No lanes between - use closest available lane
                        horizLane = findClosestAvailableHorizontalLane(
                            currentSemester,
                            minX,
                            maxX,
                            (startStub.y + endStub.y) / 2
                        );
                    }

                    if (horizLane) {
                        // Reserve this lane for this specific connection
                        reserveHorizontalLane(horizLane, minX, maxX, `${fromCourseKey}->${conn.to}`);
                    }
                }

                if (horizLane) {
                    // Route through horizontal lane using top/bottom stubs:
                    // start stub -> horizontal lane -> end stub
                    const path = `M ${startStub.x} ${startStub.y} L ${startStub.x} ${horizLane.y} L ${endStub.x} ${horizLane.y} L ${endStub.x} ${endStub.y}`;
                    const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    pathEl.setAttribute('d', path);
                    pathEl.setAttribute('stroke', courseColor);
                    pathEl.setAttribute('stroke-width', '2.5');
                    pathEl.setAttribute('fill', 'none');
                    pathEl.setAttribute('opacity', '0.6'); // Slightly transparent since it goes behind boxes
                    pathEl.style.zIndex = '1'; // Behind boxes (boxes are z-index 10+)
                    // Add data attributes for highlighting
                    pathEl.setAttribute('data-from-course', fromCourseKey);
                    pathEl.setAttribute('data-to-course', conn.to);
                    pathEl.setAttribute('class', 'connection-path');
                    // Apply dashed line for corequisites, solid for prerequisites
                    if (conn.type === 'coreq') {
                        pathEl.setAttribute('stroke-dasharray', '3 2'); // 3px dash, 2px gap
                    }
                    svgFragment.appendChild(pathEl);

                    // Add visual indicators where the line enters/exits the boxes
                    // Start point (filled circle) at start stub
                    const startPoint = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    startPoint.setAttribute('cx', startStub.x);
                    startPoint.setAttribute('cy', startStub.y);
                    startPoint.setAttribute('r', '4');
                    startPoint.setAttribute('fill', courseColor);
                    startPoint.style.zIndex = '100'; // Above everything
                    // Add data attributes for highlighting
                    startPoint.setAttribute('data-from-course', fromCourseKey);
                    startPoint.setAttribute('data-to-course', conn.to);
                    startPoint.setAttribute('class', 'connection-indicator');
                    svgFragment.appendChild(startPoint);

                    // End arrow (triangle) at end stub to show direction
                    const endArrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    const arrowPointSize = 5;
                    // Create arrow pointing in the direction of connection (toward the box)
                    let arrowPoints;
                    if (goingDown) {
                        // Arrow pointing down (into top of box)
                        arrowPoints = `${endStub.x},${endStub.y} ${endStub.x - arrowPointSize},${endStub.y - arrowPointSize * 1.5} ${endStub.x + arrowPointSize},${endStub.y - arrowPointSize * 1.5}`;
                    } else {
                        // Arrow pointing up (into bottom of box)
                        arrowPoints = `${endStub.x},${endStub.y} ${endStub.x - arrowPointSize},${endStub.y + arrowPointSize * 1.5} ${endStub.x + arrowPointSize},${endStub.y + arrowPointSize * 1.5}`;
                    }
                    endArrow.setAttribute('points', arrowPoints);
                    endArrow.setAttribute('fill', courseColor);
                    endArrow.style.zIndex = '100';
                    // Add data attributes for highlighting
                    endArrow.setAttribute('data-from-course', fromCourseKey);
                    endArrow.setAttribute('data-to-course', conn.to);
                    endArrow.setAttribute('class', 'connection-indicator');
                    svgFragment.appendChild(endArrow);
                } else {
                    const path = `M ${startStub.x} ${startStub.y} L ${endStub.x} ${endStub.y}`;
                    const connectionPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    connectionPath.setAttribute('d', path);
                    connectionPath.setAttribute('stroke', courseColor);
                    connectionPath.setAttribute('stroke-width', '2.5');
                    connectionPath.setAttribute('fill', 'none');
                    // Add data attributes for highlighting
                    connectionPath.setAttribute('data-from-course', fromCourseKey);
                    connectionPath.setAttribute('data-to-course', conn.to);
                    connectionPath.setAttribute('class', 'connection-path');
                    // Apply dashed line for corequisites, solid for prerequisites
                    if (conn.type === 'coreq') {
                        connectionPath.setAttribute('stroke-dasharray', '3 2');
                    }
                    svgFragment.appendChild(connectionPath);
                }
            } else {
                // Multi-semester routing
                const fromSemIdx = semesterOrder.indexOf(conn.fromRecord.semester);
                const toSemIdx = semesterOrder.indexOf(conn.toRecord.semester);
                const semesterJump = toSemIdx - fromSemIdx;

                if (semesterJump === 1) {
                    // Adjacent semester - get or allocate vertical lane for this gap
                    const gapKey = `${semesterOrder[fromSemIdx]}|${semesterOrder[fromSemIdx + 1]}`;
                    const gap = semesterGaps[gapKey];

                    // Check if we already have a lane assigned for this source course in this gap. Same source MUST use same lane
                    let verticalLane = globalVerticalLanes[fromCourseKey][gapKey];

                    if (!verticalLane) {
                        // First connection from this source: find available lane for Y-range. Adjacent connections prefer early/inner lanes
                        verticalLane = findAvailableLaneForRange(gap, outputStub.y, inputStub.y, outputStub.y, inputStub.y, fromCourseKey, conn.to, true);

                        if (!verticalLane) return;

                        globalVerticalLanes[fromCourseKey][gapKey] = verticalLane;
                    }

                    // Reserve the lane for THIS connection's Y-range
                    // Include horizontal segment positions (start at outputStub.y, end at inputStub.y)
                    reserveVerticalLane(verticalLane, outputStub.y, inputStub.y, fromCourseKey, outputStub.y, inputStub.y, conn.to, true);

                    const path = `M ${outputStub.x} ${outputStub.y} L ${verticalLane.x} ${outputStub.y} L ${verticalLane.x} ${inputStub.y} L ${inputStub.x} ${inputStub.y}`;
                    const connectionPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    connectionPath.setAttribute('d', path);
                    connectionPath.setAttribute('stroke', courseColor);
                    connectionPath.setAttribute('stroke-width', '2.5');
                    connectionPath.setAttribute('fill', 'none');
                    // Add data attributes for highlighting
                    connectionPath.setAttribute('data-from-course', fromCourseKey);
                    connectionPath.setAttribute('data-to-course', conn.to);
                    connectionPath.setAttribute('class', 'connection-path');
                    // Apply dashed line for corequisites, solid for prerequisites
                    if (conn.type === 'coreq') {
                        connectionPath.setAttribute('stroke-dasharray', '3 2');
                    }
                    svgFragment.appendChild(connectionPath);

                    // Add visual indicators at entry and exit points
                    // Start point (filled circle) at output stub
                    const startPoint = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    startPoint.setAttribute('cx', outputStub.x);
                    startPoint.setAttribute('cy', outputStub.y);
                    startPoint.setAttribute('r', '4');
                    startPoint.setAttribute('fill', courseColor);
                    // Add data attributes for highlighting
                    startPoint.setAttribute('data-from-course', fromCourseKey);
                    startPoint.setAttribute('data-to-course', conn.to);
                    startPoint.setAttribute('class', 'connection-indicator');
                    svgFragment.appendChild(startPoint);

                    // End arrow (triangle) at input stub pointing right (into left side of box)
                    const endArrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    const arrowPointSize = 5;
                    // Arrow pointing right (into the input stub from the left)
                    const arrowPoints = `${inputStub.x},${inputStub.y} ${inputStub.x - arrowPointSize * 1.5},${inputStub.y - arrowPointSize} ${inputStub.x - arrowPointSize * 1.5},${inputStub.y + arrowPointSize}`;
                    endArrow.setAttribute('points', arrowPoints);
                    endArrow.setAttribute('fill', courseColor);
                    // Add data attributes for highlighting
                    endArrow.setAttribute('data-from-course', fromCourseKey);
                    endArrow.setAttribute('data-to-course', conn.to);
                    endArrow.setAttribute('class', 'connection-indicator');
                    svgFragment.appendChild(endArrow);
                } else {
                    // Multi-semester jump - allocate lanes per gap
                    const pathSegments = [];
                    let currentX = outputStub.x;
                    let currentY = outputStub.y;
                    let selectedHorizontalY = null; // Track the Y position once a horizontal lane is chosen

                    pathSegments.push(`M ${currentX} ${currentY}`);

                    // For each gap this connection crosses
                    for (let semIdx = fromSemIdx; semIdx < toSemIdx; semIdx++) {
                        const currentSem = semesterOrder[semIdx];
                        const nextSem = semesterOrder[semIdx + 1];
                        const gapKey = `${currentSem}|${nextSem}`;
                        const gap = semesterGaps[gapKey];

                        if (!gap) continue;

                        const isLastGap = (semIdx === toSemIdx - 1);
                        const isFirstGap = (semIdx === fromSemIdx);

                        // For non-last gaps, determine the horizontal lane FIRST so we know the target Y
                        let horizLane = null;
                        let targetY = currentY;

                        if (!isLastGap) {
                            // Need to determine horizontal lane before allocating vertical lane
                            const nextSemester = nextSem;
                            horizLane = globalHorizontalLanes[fromCourseKey][nextSemester];

                            if (!horizLane) {
                                // First connection through this semester - allocate horizontal lane
                                const fromSemesterBounds = semesterPositions[fromRecord.semester];
                                // Check if the course box itself is in the upper half of the semester
                                const isInUpperHalf = fromSemesterBounds &&
                                    fromRecord.rect.top < (fromSemesterBounds.top + fromSemesterBounds.bottom) / 2;

                                // Determine target Y for lane selection
                                let laneTargetY;
                                let shouldPreferTopLane;
                                
                                if (isFirstGap) {
                                    // First gap: use output stub position
                                    laneTargetY = currentY;
                                    
                                    // Only prefer top lane if this is the topmost course in its semester
                                    const fromSemesterBounds = semesterPositions[fromRecord.semester];
                                    const coursesInSemester = visibleCourses.filter(k => courseRecords[k].semester === fromRecord.semester);
                                    const sortedCourses = coursesInSemester
                                        .map(k => ({ key: k, top: courseRecords[k].rect.top }))
                                        .sort((a, b) => a.top - b.top);
                                    const isTopCourse = sortedCourses.length > 0 && sortedCourses[0].key === fromCourseKey;
                                    
                                    shouldPreferTopLane = isTopCourse;
                                } else if (selectedHorizontalY !== null) {
                                    laneTargetY = selectedHorizontalY;
                                    shouldPreferTopLane = false;
                                } else {
                                    laneTargetY = currentY;
                                    shouldPreferTopLane = false;
                                }

                                horizLane = findClosestAvailableHorizontalLane(
                                    nextSemester,
                                    semesterPositions[nextSemester]?.left || 0,
                                    semesterPositions[semesterOrder[semIdx + 2]]?.right || 1000,
                                    laneTargetY,
                                    shouldPreferTopLane,
                                    fromCourseKey
                                );

                                if (!horizLane) {
                                    return;
                                }
                                
                                // CRITICAL CHECK: Make sure no other course is using a lane at this same Y in the current semester
                                // OR in any future semester this connection will traverse
                                // This prevents visual overlaps when crossing multiple gaps
                                let hasConflictInAnyAdjacentSemester = false;
                                const conflictingSemesters = [];
                                
                                // Check current semester (the one we're leaving from)
                                const currentSemesterLanes = horizontalLanesBySemester[currentSem];
                                if (currentSemesterLanes) {
                                    const conflictInCurrent = currentSemesterLanes.find(lane => 
                                        Math.abs(lane.y - horizLane.y) < 1 && lane.reservations.length > 0
                                    );
                                    if (conflictInCurrent) {
                                        hasConflictInAnyAdjacentSemester = true;
                                        conflictingSemesters.push(currentSem);
                                    }
                                }
                                
                                // Check all future semesters this connection will traverse
                                for (let futureIdx = semIdx + 2; futureIdx <= toSemIdx; futureIdx++) {
                                    const futureSem = semesterOrder[futureIdx];
                                    const futureLanes = horizontalLanesBySemester[futureSem];
                                    if (futureLanes) {
                                        const conflictInFuture = futureLanes.find(lane =>
                                            Math.abs(lane.y - horizLane.y) < 1 && lane.reservations.length > 0
                                        );
                                        if (conflictInFuture) {
                                            hasConflictInAnyAdjacentSemester = true;
                                            conflictingSemesters.push(futureSem);
                                        }
                                    }
                                }
                                
                                if (hasConflictInAnyAdjacentSemester) {
                                    // Find the closest available lane that doesn't conflict with any adjacent semester
                                    const allLanesInNext = horizontalLanesBySemester[nextSemester];
                                    const candidateLanes = allLanesInNext.filter(lane => {
                                        // Must not be the top lane
                                        if (lane.isAboveAll) return false;
                                        
                                        // Check if available in next semester
                                        if (!isHorizontalLaneAvailable(lane, 
                                            semesterPositions[nextSemester]?.left || 0,
                                            semesterPositions[semesterOrder[semIdx + 2]]?.right || 1000,
                                            fromCourseKey)) {
                                            return false;
                                        }
                                        
                                        // Check if conflicts with current semester
                                        if (currentSemesterLanes) {
                                            const conflictInCurrent = currentSemesterLanes.find(l => 
                                                Math.abs(l.y - lane.y) < 1 && l.reservations.length > 0
                                            );
                                            if (conflictInCurrent) return false;
                                        }
                                        
                                        // Check if conflicts with any future semester this connection traverses
                                        for (let futureIdx = semIdx + 2; futureIdx <= toSemIdx; futureIdx++) {
                                            const futureSem = semesterOrder[futureIdx];
                                            const futureLanes = horizontalLanesBySemester[futureSem];
                                            if (futureLanes) {
                                                const conflictInFuture = futureLanes.find(l =>
                                                    Math.abs(l.y - lane.y) < 1 && l.reservations.length > 0
                                                );
                                                if (conflictInFuture) return false;
                                            }
                                        }
                                        
                                        return true;
                                    });
                                    
                                    if (candidateLanes.length === 0) {
                                        console.error(`Could not find non-conflicting lane for ${fromCourseKey} between ${currentSem} and ${nextSemester}`);
                                        return;
                                    }
                                    
                                    // Find the closest candidate to the target Y
                                    horizLane = candidateLanes.reduce((closest, lane) => {
                                        const currentDist = Math.abs(lane.y - laneTargetY);
                                        const closestDist = Math.abs(closest.y - laneTargetY);
                                        return currentDist < closestDist ? lane : closest;
                                    });
                                }

                                globalHorizontalLanes[fromCourseKey][nextSemester] = horizLane;
                                
                                // Remember this Y position for subsequent gaps (only set once in first gap)
                                if (isFirstGap) {
                                    selectedHorizontalY = horizLane.y;
                                }
                            } else {
                                // Lane already exists for this semester - but make sure we update selectedHorizontalY if not set
                                if (isFirstGap && selectedHorizontalY === null) {
                                    selectedHorizontalY = horizLane.y;
                                }
                            }

                            targetY = horizLane.y; // Use horizontal lane Y as target
                        } else {
                            targetY = inputStub.y; // Last gap goes to input stub
                        }

                        // Now allocate vertical lane knowing the correct target Y
                        // Get or allocate vertical lane for this source course in this gap
                        // Same source MUST use same lane
                        let verticalLane = globalVerticalLanes[fromCourseKey][gapKey];

                        if (!verticalLane) {
                            // First connection from this source course through this gap
                            // For multi-semester, we need to reserve space considering horizontal segments
                            // startY: where horizontal segment enters the vertical lane (currentY)
                            // endY: where horizontal segment exits the vertical lane (targetY)
                            verticalLane = findAvailableLaneForRange(gap, currentY, targetY, currentY, targetY, fromCourseKey, conn.to, false);

                            if (!verticalLane) return;

                            globalVerticalLanes[fromCourseKey][gapKey] = verticalLane;
                        } else {
                            // Reusing vertical lane from earlier connection
                        }

                        // Before moving to the new vertical lane, reserve any horizontal segment we're about to traverse
                        // If we're currently on a horizontal lane (currentY is at a lane Y), reserve from currentX to verticalLane.x
                        if (semIdx > fromSemIdx) {
                            // Not the first gap - we came from a horizontal lane in the previous iteration
                            const prevSemester = semesterOrder[semIdx];
                            const prevHorizLane = globalHorizontalLanes[fromCourseKey][prevSemester];
                            if (prevHorizLane && Math.abs(currentY - prevHorizLane.y) < 1) {
                                // We're on the horizontal lane - reserve the segment we're about to traverse
                                reserveHorizontalLane(prevHorizLane, currentX, verticalLane.x, fromCourseKey);
                            }
                        }

                        // Move horizontally to the vertical lane
                        pathSegments.push(`L ${verticalLane.x} ${currentY}`);
                        currentX = verticalLane.x;

                        // Determine where to go next (using isLastGap and horizLane already calculated above)

                        if (isLastGap) {
                            // Last gap - go directly to destination
                            // Horizontal segment enters at currentY, exits at inputStub.y
                            reserveVerticalLane(verticalLane, currentY, inputStub.y, fromCourseKey, currentY, inputStub.y, conn.to, false);
                            pathSegments.push(`L ${currentX} ${inputStub.y}`);
                            currentY = inputStub.y;
                        } else {
                            // Not last gap - use horizontal lane allocated above. Reserve vertical lane and drop/rise to horizontal lane
                            reserveVerticalLane(verticalLane, currentY, horizLane.y, fromCourseKey, currentY, horizLane.y, conn.to, false);

                            // Drop/rise to horizontal lane
                            pathSegments.push(`L ${currentX} ${horizLane.y}`);
                            currentY = horizLane.y;
                        }
                    }

                    // Final horizontal segment to input stub
                    pathSegments.push(`L ${inputStub.x} ${inputStub.y}`);

                    const path = pathSegments.join(' ');
                    const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    pathEl.setAttribute('d', path);
                    pathEl.setAttribute('stroke', courseColor);
                    pathEl.setAttribute('stroke-width', '2.5');
                    pathEl.setAttribute('fill', 'none');
                    // Add data attributes for highlighting
                    pathEl.setAttribute('data-from-course', fromCourseKey);
                    pathEl.setAttribute('data-to-course', conn.to);
                    pathEl.setAttribute('class', 'connection-path');
                    // Apply dashed line for corequisites, solid for prerequisites
                    if (conn.type === 'coreq') {
                        pathEl.setAttribute('stroke-dasharray', '3 2');
                    }
                    svgFragment.appendChild(pathEl);

                    // Add visual indicators at entry and exit points
                    // Start point (filled circle) at output stub
                    const startPoint = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    startPoint.setAttribute('cx', outputStub.x);
                    startPoint.setAttribute('cy', outputStub.y);
                    startPoint.setAttribute('r', '4');
                    startPoint.setAttribute('fill', courseColor);
                    // Add data attributes for highlighting
                    startPoint.setAttribute('data-from-course', fromCourseKey);
                    startPoint.setAttribute('data-to-course', conn.to);
                    startPoint.setAttribute('class', 'connection-indicator');
                    svgFragment.appendChild(startPoint);

                    // End arrow (triangle) at input stub pointing right (into left side of box)
                    const endArrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    const arrowPointSize = 5;
                    // Arrow pointing right (into the input stub from the left)
                    const arrowPoints = `${inputStub.x},${inputStub.y} ${inputStub.x - arrowPointSize * 1.5},${inputStub.y - arrowPointSize} ${inputStub.x - arrowPointSize * 1.5},${inputStub.y + arrowPointSize}`;
                    endArrow.setAttribute('points', arrowPoints);
                    endArrow.setAttribute('fill', courseColor);
                    // Add data attributes for highlighting
                    endArrow.setAttribute('data-from-course', fromCourseKey);
                    endArrow.setAttribute('data-to-course', conn.to);
                    endArrow.setAttribute('class', 'connection-indicator');
                    svgFragment.appendChild(endArrow);
                }
            }
        });
    });


    // Analyze connection types
    let sameSemesterCount = 0;
    let adjacentSemesterCount = 0;
    let multiSemesterCount = 0;

    connections.forEach(conn => {
        const fromIdx = semesterOrder.indexOf(conn.fromRecord.semester);
        const toIdx = semesterOrder.indexOf(conn.toRecord.semester);
        const jump = toIdx - fromIdx;

        if (jump === 0) sameSemesterCount++;
        else if (jump === 1) adjacentSemesterCount++;
        else if (jump > 1) multiSemesterCount++;
    });

    // âœ… PHASE 1.2: Append all elements at once (single paint)
    svg.appendChild(svgFragment);

    // âœ… PHASE 1.3: End conflict detection tracking
    performance.mark('conflict-detection-end');
    performance.measure('conflict-detection', 'conflict-detection-start', 'conflict-detection-end');
    const conflictMeasure = performance.getEntriesByName('conflict-detection')[0];
    console.log(`âœ… Conflict detection optimized: ${conflictMeasure.duration.toFixed(2)}ms (${conflictChecks} checks)`);

    // âœ… PHASE 1.2: End performance measurement
    performance.mark('svg-render-end');
    performance.measure('svg-render', 'svg-render-start', 'svg-render-end');
    const measure = performance.getEntriesByName('svg-render')[0];
    console.log(`âœ… SVG batch rendering: ${measure.duration.toFixed(2)}ms`);
}


        window.highlightRelatedCourses = function(courseKey) {
            try {
                window.clearHighlights();

                const course = courseData[courseKey];
                const leadsTo = leadsToMap[courseKey];

                if (!course || !leadsTo) return;

            // Combine highlighting and drawing in a single requestAnimationFrame
            requestAnimationFrame(() => {
                    try {
                        // Highlight the selected course
                        highlightSelectedCourse(courseKey);

                        // Dim all other courses
                        dimOtherCourses(courseKey);

                        // Highlight prerequisites
                        highlightPrerequisites(course.prereqs);

                        // Highlight corequisites
                        highlightCorequisites(course.coreqs);

                        // Sort courses by position (now in same frame)
                        const prereqsSorted = sortCoursesByPosition(course.prereqs);
                        const coreqsSorted = sortCoursesByPosition(course.coreqs);

                        // Combine leads-to arrays once and reuse
                        const allLeadsToKeys = [...leadsTo.asPrereq, ...leadsTo.asCoreq];
                        const leadsToSorted = sortCoursesByPosition(allLeadsToKeys);

                        // OPTIMIZATION: Convert coreqs to Set for O(1) lookup during filtering
                        const coreqSet = new Set(course.coreqs || []);
                        // Highlight courses this leads to (filter out duplicates)
                        const allLeadsTo = allLeadsToKeys.filter(
                            key => !coreqSet.has(key)
                        );
                        highlightLeadsTo(allLeadsTo);

                        // Calculate connection counts
                        const { destConnectionCounts, srcConnectionCounts } = calculateConnectionCounts(
                            courseKey,
                            prereqsSorted,
                            coreqsSorted,
                            leadsToSorted
                        );

                        window.destTotalConnections = destConnectionCounts;
                        window.srcTotalConnections = srcConnectionCounts;

                        // Draw all connection lines
                        drawAllConnections(
                            courseKey,
                            course,
                            prereqsSorted,
                            coreqsSorted,
                            leadsToSorted,
                            destConnectionCounts,
                            srcConnectionCounts
                        );

                        // Announce the selection
                        announceSelection(courseKey, course, leadsToSorted);

                        // Update SVG size
                        updateSVGSize();

            // Draw all connections automatically on load (static version)
            setTimeout(() => {
                drawAllConnections();
            }, 100);
                    } catch (error) {
                        console.error('Error highlighting and drawing connections:', error);
                    }
                });

                selectedCourseKey = courseKey;
            } catch (error) {
                console.error('Error in highlightRelatedCourses:', error);
                // Clean up on error
                window.clearHighlights();
            }
        };
        
        function announceSelection(courseKey, course, leadsTo) {
            const announcer = domCache.announcements;
            if (!announcer) return;
            
            const courseInfo = courseData[courseKey];
            if (!courseInfo) return;
            
            const prereqCount = course.prereqs.length;
            const coreqCount = course.coreqs.length;
            const leadsToCount = leadsTo.length;
            
            let message = `${courseInfo.code} ${courseInfo.name} selected. `;
            
            if (prereqCount === 0 && coreqCount === 0 && leadsToCount === 0) {
                message += 'This course has no prerequisites, co-requisites, or courses it leads to.';
            } else {
                const parts = [];
                
                if (prereqCount > 0) {
                    const prereqNames = course.prereqs.map(p => courseData[p]?.code || p).join(', ');
                    parts.push(`${prereqCount} prerequisite${prereqCount > 1 ? 's' : ''}: ${prereqNames}`);
                }
                
                if (coreqCount > 0) {
                    const coreqNames = course.coreqs.map(c => courseData[c]?.code || c).join(', ');
                    parts.push(`${coreqCount} co-requisite${coreqCount > 1 ? 's' : ''}: ${coreqNames}`);
                }
                
                if (leadsToCount > 0) {
                    const leadsToNames = leadsTo.map(l => courseData[l]?.code || l).join(', ');
                    parts.push(`leads to ${leadsToCount} course${leadsToCount > 1 ? 's' : ''}: ${leadsToNames}`);
                }
                
                message += parts.join('. ') + '.';
            }
            
            announcer.textContent = message;
        }
        
        // Store event handlers for cleanup
        const eventHandlers = new WeakMap();

        function buildFlowchart(isProgramSwitch = false) {
            const container = domCache.flowchartContainer;
            if (!container) return;
            
            const courseBySemester = {};
            semesterOrder.forEach(sem => courseBySemester[sem] = []);
            
            Object.entries(courseData).forEach(([key, course]) => {
                courseBySemester[course.semester].push({key, ...course});
            });

            // Sort priority map for efficient course ordering
            const sortPriorityPrefixes = [
                ['CHE-', 1],
                ['BIOENG-', 1],
                ['ELEC-CHE', 2],
                ['ELEC-BIOENG', 2],
                ['CELL-MOL-', 2],  // Cell & Molecular electives - treat like bioeng electives
                ['ENGR-', 3],
                ['EE-', 3],  // Electrical Engineering
                ['CE-', 3],  // Civil Engineering
                ['ELEC-TECH', 4],
                ['CHEM-', 5],
                ['MBIOS-', 5],  // Treat MBIOS like chemistry
                ['MATH-', 6],
                ['PHYS-', 7],
                ['BIOLOGY-', 8],
                ['ENGL-', 9],
                ['HIST-', 10],
                ['ECONS-', 11],
                ['ELEC-', 12],
                ['STAT-', 13]
            ];

            function getSortPriority(courseCode) {
                for (const [prefix, priority] of sortPriorityPrefixes) {
                    if (courseCode.startsWith(prefix)) {
                        return priority;
                    }
                }
                return 14;  // Default priority
            }
            
            semesterOrder.forEach(semester => {
                courseBySemester[semester].sort((a, b) => {
                    const priorityA = getSortPriority(a.key);
                    const priorityB = getSortPriority(b.key);
                    if (priorityA !== priorityB) {
                        return priorityA - priorityB;
                    }
                    return a.key.localeCompare(b.key);
                });
            });
            
            semesterOrder.forEach(semester => {
                const column = document.createElement('div');
                column.className = 'semester-column';

                // Calculate total credits for this semester
                const totalCredits = courseBySemester[semester].reduce((sum, course) => sum + course.credits, 0);

                const header = document.createElement('div');
                header.className = 'semester-header';
                const parts = semester.split(' ');
                header.innerHTML = `${parts[0]} ${parts[1]}<br>${parts[2]}<br><span class="credits">${totalCredits} Credits</span>`;
                column.appendChild(header);

                courseBySemester[semester].forEach(course => {
                    const courseDiv = document.createElement('div');
                    courseDiv.className = `course ${course.type}`;
                    // Removed tabindex to disable keyboard focus/interaction
                    courseDiv.setAttribute('data-course-key', course.key);
                    
                    const prereqText = course.prereqs.length > 0
                        ? ` Prereq: ${course.prereqs.map(p => courseData[p]?.code || p).join(', ')}.`
                        : '';

                    const coreqText = course.coreqs.length > 0
                        ? ` Coreq: ${course.coreqs.map(c => courseData[c]?.code || c).join(', ')}.`
                        : '';

                    // Calculate "required for" courses (outgoing connections)
                    const requiredForKeys = [];
                    Object.entries(courseData).forEach(([otherKey, otherCourse]) => {
                        if (otherCourse.prereqs && otherCourse.prereqs.includes(course.key)) {
                            requiredForKeys.push(otherKey);
                        }
                    });

                    const requiredForText = requiredForKeys.length > 0
                        ? ` Required for: ${requiredForKeys.map(k => courseData[k]?.code || k).join(', ')}.`
                        : '';

                    const alternativesText = course.alternatives && course.alternatives.length > 0
                        ? ` Has ${course.alternatives.length} alternative course${course.alternatives.length > 1 ? 's' : ''}, press I to view.`
                        : '';

                    const semesterRestrictionText = course.semesterRestriction
                        ? ` Only offered in ${course.semesterRestriction}.`
                        : '';

                    const ariaLabel = `${course.code}, ${course.credits} credits.${semesterRestrictionText}${prereqText}${coreqText}${requiredForText}${alternativesText}`;
                    courseDiv.setAttribute('aria-label', ariaLabel);

                    // Build tooltip text for hover
                    let tooltipText = `${course.code} - ${course.name}\n${course.credits} credits`;
                    if (semesterRestrictionText) {
                        tooltipText += `\n${semesterRestrictionText}`;
                    }
                    if (prereqText) {
                        tooltipText += `\n${prereqText}`;
                    }
                    if (coreqText) {
                        tooltipText += `\n${coreqText.trim()}`;
                    }
                    courseDiv.setAttribute('title', tooltipText);

                    // AAA Compliance: Use abbreviation tags for course prefixes
                    const formattedCode = formatCourseCodeWithAbbr(course.code);
                    courseDiv.innerHTML = `
                        <span class="course-code">${formattedCode}</span>
                        <span class="course-name">${course.shortName || course.name}</span>
                        <span class="course-credits">${course.credits} cr</span>
                    `;
                    
                    if (course.notes && course.notes.trim() !== '') {
                        const notesIndicator = document.createElement('div');
                        notesIndicator.className = 'notes-indicator';
                        notesIndicator.textContent = 'i';
                        // Convert <br> tags to newlines for plain text attributes
                        const plainTextNotes = course.notes.replace(/<br\s*\/?>/gi, '\n');
                        notesIndicator.setAttribute('aria-hidden', 'true'); // Hidden from screen readers - info in parent aria-label
                        notesIndicator.setAttribute('title', plainTextNotes);
                        // Removed role="button" and tabindex - not independently interactive
                        notesIndicator.style.cursor = 'pointer';

                        // Click handler - but stops propagation handled by parent
                        notesIndicator.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const courseKey = courseDiv.getAttribute('data-course-key');
                            showCourseInfo(courseKey, 'notes');
                        });

                        courseDiv.appendChild(notesIndicator);
                        courseDiv.setAttribute('data-has-notes', 'true');
                    }

                    if (course.semesterRestriction) {
                        const restrictionBadge = document.createElement('div');
                        const semester = course.semesterRestriction.toLowerCase();
                        restrictionBadge.className = `semester-restriction-badge ${semester}`;

                        // Display text: "F" for Fall, "Sp" for Spring, "Su" for Summer
                        let displayText = course.semesterRestriction;
                        if (course.semesterRestriction === 'Fall') {
                            displayText = 'F';
                        } else if (course.semesterRestriction === 'Spring') {
                            displayText = 'Sp';
                        } else if (course.semesterRestriction === 'Summer') {
                            displayText = 'Su';
                        }

                        restrictionBadge.textContent = displayText;
                        restrictionBadge.setAttribute('aria-hidden', 'true');
                        restrictionBadge.setAttribute('title', `Only offered in ${course.semesterRestriction}`);

                        courseDiv.appendChild(restrictionBadge);
                    }

                    if (course.alternatives && course.alternatives.length > 0) {
                        const alternativesIndicator = document.createElement('div');
                        alternativesIndicator.className = 'alternatives-indicator';
                        alternativesIndicator.textContent = 'OR';
                        alternativesIndicator.setAttribute('aria-hidden', 'true'); // Hidden from screen readers - info in parent aria-label
                        alternativesIndicator.setAttribute('title', `Alternative: ${course.alternatives.join(', ')}`);
                        // Removed role="button" and tabindex - not independently interactive

                        // Click handler - but stops propagation handled by parent
                        alternativesIndicator.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const courseKey = courseDiv.getAttribute('data-course-key');
                            showCourseInfo(courseKey, 'alternatives');
                        });

                        courseDiv.appendChild(alternativesIndicator);
                        courseDiv.setAttribute('data-has-alternatives', 'true');
                    }
                    
                    // STATIC VERSION: Course clicks disabled
                    // courseDiv.addEventListener('click', (e) => {
                        // Close any open tooltips first
                    // const notesTooltip = domCache.notesTooltip;
                    // const alternativesTooltip = domCache.alternativesTooltip;

                    // if (!e.target.closest('.notes-indicator')) {
                    // if (notesTooltip && notesTooltip.classList.contains('visible')) {
                    // closeNotesTooltip();
                    // }
                    // }

                    // if (!e.target.closest('.alternatives-indicator')) {
                    // if (alternativesTooltip && alternativesTooltip.classList.contains('visible')) {
                    // closeAlternativesTooltip();
                    // }
                    // }

                    // e.stopPropagation();
                    // if (selectedCourseKey === course.key) {
                    // window.clearHighlights();
                    // } else {
                    // window.highlightRelatedCourses(course.key);
                    // }
                    // });
                    
                    // STATIC VERSION: Course keydown disabled
                    // courseDiv.addEventListener('keydown', (e) => {
                    // if (e.key === 'Enter' || e.key === ' ') {
                    // e.preventDefault();
                    // if (selectedCourseKey === course.key) {
                    // window.clearHighlights();
                    // } else {
                    // window.highlightRelatedCourses(course.key);
                    // }
                    // }

                    // if ((e.key === 'i' || e.key === 'I') && courseDiv.getAttribute('data-has-notes') === 'true') {
                    // e.preventDefault();
                    // const rect = courseDiv.getBoundingClientRect();
                    // const syntheticEvent = {
                    // clientX: rect.left + rect.width / 2,
                    // clientY: rect.top + rect.height / 2,
                    // stopPropagation: () => {}
                    // };
                    // showNotesTooltip(course.key, syntheticEvent, courseDiv);
                    // }

                    // if ((e.key === 'a' || e.key === 'A') && courseDiv.getAttribute('data-has-alternatives') === 'true') {
                    // e.preventDefault();
                    // const rect = courseDiv.getBoundingClientRect();
                    // const syntheticEvent = {
                    // clientX: rect.left + rect.width / 2,
                    // clientY: rect.bottom,
                    // stopPropagation: () => {}
                    // };
                    // const altIndicator = courseDiv.querySelector('.alternatives-indicator');
                    // showAlternativesTooltip(course.key, syntheticEvent, altIndicator);
                    // }
                    // });
                    
                    column.appendChild(courseDiv);
                });
                
                container.appendChild(column);
            });

            // Only reset scroll position on initial load, not on program switch
            if (!isProgramSwitch) {
                setTimeout(() => {
                    centerFlowchartOnInit();
                }, 0);
            }
        }

        function centerFlowchartOnInit() {
            const wrapper = domCache.visualView;
            if (!wrapper) return;

            // Always start with Year 1 Fall visible (leftmost position)
            wrapper.scrollLeft = 0;
        }

        window.switchProgram = function() {
            const select = domCache.programSelect;
            if (!select) return;

            const newProgram = select.value;

            if (newProgram === currentProgram) return;

            // Save current scroll position before switching
            const wrapper = domCache.visualView;
            const savedScrollLeft = wrapper ? wrapper.scrollLeft : 0;

            // Close any open tooltips
            window.closeCourseInfo();

            // Clear highlights
            window.clearHighlights();

            // âœ… FIX #1: COMPREHENSIVE CACHE CLEANUP (prevents memory leaks)
            cleanupAllCaches();

            // Update current program
            currentProgram = newProgram;
            courseData = programsData[currentProgram].courseData;
            semesterOrder = programsData[currentProgram].semesterOrder;

            // Update global references
            window.courseData = courseData;
            window.semesterOrder = semesterOrder;

            // Update page title
            const programTitle = domCache.programTitle;
            if (programTitle) {
                programTitle.textContent = programsData[currentProgram].fullTitle;
            }

            // Clear existing flowchart and text view efficiently
            const flowchartContainer = domCache.flowchartContainer;
            const textContent = domCache.textContent;
            const svg = domCache.connectionsSvg;

            // Clear course element cache since DOM is being rebuilt
            clearCourseElementCache();

            // Preserve the SVG element before clearing
            const svgElement = svg ? svg.cloneNode(false) : null;

            // Clear containers efficiently
            if (flowchartContainer) {
                while (flowchartContainer.firstChild) {
                    flowchartContainer.removeChild(flowchartContainer.firstChild);
                }
            }
            if (textContent) {
                while (textContent.firstChild) {
                    textContent.removeChild(textContent.firstChild);
                }
            }

            // Re-add the SVG element to the container
            if (svgElement && flowchartContainer) {
                // Update cache reference
                domCache.connectionsSvg = svgElement;
                flowchartContainer.appendChild(svgElement);
            }

            // Rebuild everything (with scroll preservation flag)
            leadsToMap = buildLeadsToMap();
            buildFlowchart(true); // Pass true to indicate program switch
            buildTextView();
            setupScrollIndicators();
            createArrowMarkers();
            updateSVGSize();
            
            // OPTIMIZATION: Rebuild caches after layout is complete
            rectCache.rebuild();
            courseElementCache.rebuild();
            
            // Re-attach click handlers to new course elements
            attachCourseClickHandlers();

            // Draw all connections automatically on load (static version)
            setTimeout(() => {
                drawAllConnections();
                // Build highlighting cache AFTER connections are drawn
                highlightingCache.rebuild();
            }, 100);

            // Restore scroll position after rebuild
            if (wrapper) {
                setTimeout(() => {
                    wrapper.scrollLeft = savedScrollLeft;
                    updateActiveIndicator();
                }, 10);
            }

            // Announce the change with detailed context
            const announcer = domCache.announcements;
            if (announcer) {
                const courseCount = Object.keys(courseData).length;
                const semesterCount = semesterOrder.length;
                const totalCredits = Object.values(courseData).reduce((sum, c) => sum + parseInt(c.credits || 0), 0);
                announcer.textContent = `Loaded ${programsData[currentProgram].name} program flowchart. ${courseCount} courses across ${semesterCount} semesters. Total ${totalCredits} credits. Use Tab to navigate between courses.`;
            }
        };

        // Disclaimer Modal Functions
        let modalPreviousFocus = null;

        // Utility function to safely write to localStorage
        function safeLocalStorageSet(key, value) {
            // Validate key to prevent prototype pollution
            if (typeof key !== 'string' || key.includes('__proto__') || key.includes('constructor') || key.includes('prototype')) {
                console.warn('Invalid localStorage key');
                return false;
            }

            try {
                // Only store boolean true as string 'true'
                const sanitizedValue = value === true ? 'true' : 'false';
                localStorage.setItem(key, sanitizedValue);
                return true;
            } catch (e) {
                // localStorage might be disabled or full
                console.warn('Could not save to localStorage');
                return false;
            }
        }

        // Utility function to safely read from localStorage
        function safeLocalStorageGet(key) {
            // Validate key
            if (typeof key !== 'string' || key.includes('__proto__') || key.includes('constructor') || key.includes('prototype')) {
                console.warn('Invalid localStorage key');
                return null;
            }

            try {
                const value = localStorage.getItem(key);
                // Validate that value is exactly 'true' or 'false'
                if (value === 'true') {
                    return true;
                } else if (value === 'false') {
                    return false;
                }
                return null;
            } catch (e) {
                // localStorage might be disabled
                console.warn('Could not read from localStorage');
                return null;
            }
        }

        window.closeDisclaimerModal = function() {
            const modal = domCache.disclaimerModal;
            if (modal) {
                modal.classList.add('hidden');
                // Remove focus trap
                removeFocusTrap(modal);
                // Store that user has seen the disclaimer
                safeLocalStorageSet('flowchartDisclaimerShown', true);
                // Return focus to previously focused element
                if (modalPreviousFocus && modalPreviousFocus.focus) {
                    modalPreviousFocus.focus();
                }
            }
        };

        // Focus trap for modal
        let modalFocusTrapHandler = null;

        function trapFocus(element) {
            const focusableElements = element.querySelectorAll(
                'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
            );
            const firstFocusable = focusableElements[0];
            const lastFocusable = focusableElements[focusableElements.length - 1];

            // Remove previous handler if it exists
            if (modalFocusTrapHandler) {
                element.removeEventListener('keydown', modalFocusTrapHandler);
            }

            // Create and store new handler
            modalFocusTrapHandler = function(e) {
                if (e.key !== 'Tab') return;

                if (e.shiftKey) {
                    if (document.activeElement === firstFocusable) {
                        lastFocusable.focus();
                        e.preventDefault();
                    }
                } else {
                    if (document.activeElement === lastFocusable) {
                        firstFocusable.focus();
                        e.preventDefault();
                    }
                }
            };

            element.addEventListener('keydown', modalFocusTrapHandler);
        }

        function removeFocusTrap(element) {
            if (modalFocusTrapHandler) {
                element.removeEventListener('keydown', modalFocusTrapHandler);
                modalFocusTrapHandler = null;
            }
        }

        function checkAndShowDisclaimer() {
            // Use safe localStorage getter
            const hasSeenDisclaimer = safeLocalStorageGet('flowchartDisclaimerShown');

            const modal = domCache.disclaimerModal;
            if (modal) {
                // Show modal if user hasn't seen it (null or false)
                if (hasSeenDisclaimer === true) {
                    modal.classList.add('hidden');
                } else {
                    modal.classList.remove('hidden');
                    // Store current focus
                    modalPreviousFocus = document.activeElement;
                    // Set up focus trap
                    trapFocus(modal);
                    // Focus the button for keyboard accessibility
                    setTimeout(() => {
                        const button = modal.querySelector('.modal-button');
                        if (button) button.focus();
                    }, 100);
                }
            }
        }

        // Allow Escape key to close modal or tooltips
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const modal = domCache.disclaimerModal;
                if (modal && !modal.classList.contains('hidden')) {
                    closeDisclaimerModal();
                    return;
                }
            }

            const focusedElement = document.activeElement;

            const courseInfoPane = domCache.courseInfoPane;

            if (e.key === 'Escape') {
                if (courseInfoPane && courseInfoPane.getAttribute('aria-hidden') === 'false') {
                    window.closeCourseInfo();
                }

                window.clearHighlights();
                return;
            }

            if (e.key === 'v' || e.key === 'V') {
                if (!focusedElement.matches('input, textarea')) {
                    toggleView();
                }
                return;
            }

            if (!focusedElement.classList.contains('course')) return;

            const allCourses = Array.from(document.querySelectorAll('.course'));
            const currentIndex = allCourses.indexOf(focusedElement);
            let nextIndex = currentIndex;

            const currentColumn = focusedElement.closest('.semester-column');
            const columns = Array.from(document.querySelectorAll('.semester-column'));
            const columnIndex = columns.indexOf(currentColumn);
            const coursesInColumn = Array.from(currentColumn.querySelectorAll('.course'));
            const positionInColumn = coursesInColumn.indexOf(focusedElement);

            switch(e.key) {
                case 'ArrowRight':
                    e.preventDefault();
                    if (columnIndex < columns.length - 1) {
                        const nextColumn = columns[columnIndex + 1];
                        const nextColumnCourses = Array.from(nextColumn.querySelectorAll('.course'));
                        const targetCourse = nextColumnCourses[Math.min(positionInColumn, nextColumnCourses.length - 1)];
                        if (targetCourse) targetCourse.focus();
                    }
                    break;

                case 'ArrowLeft':
                    e.preventDefault();
                    if (columnIndex > 0) {
                        const prevColumn = columns[columnIndex - 1];
                        const prevColumnCourses = Array.from(prevColumn.querySelectorAll('.course'));
                        const targetCourse = prevColumnCourses[Math.min(positionInColumn, prevColumnCourses.length - 1)];
                        if (targetCourse) targetCourse.focus();
                    }
                    break;

                case 'ArrowDown':
                    e.preventDefault();
                    if (positionInColumn < coursesInColumn.length - 1) {
                        coursesInColumn[positionInColumn + 1].focus();
                    }
                    break;

                case 'ArrowUp':
                    e.preventDefault();
                    if (positionInColumn > 0) {
                        coursesInColumn[positionInColumn - 1].focus();
                    }
                    break;
            }
        });

        // Function to populate program selector dynamically
        function populateProgramSelector() {
            const select = domCache.programSelect;
            if (!select) return;
            
            // Safety check: ensure programsData is loaded
            if (typeof programsData === 'undefined' || !programsData) {
                console.warn('programsData not loaded yet, retrying...');
                setTimeout(populateProgramSelector, 100);
                return;
            }

            // Clear existing options efficiently
            while (select.firstChild) {
                select.removeChild(select.firstChild);
            }

            // Get all programs and add version metadata
            const programs = Object.keys(programsData).map(key => {
                const program = programsData[key];
                let displayLabel = program.name || 'Unknown Program';
                
                // Get status with fallback
                const status = program.status || 'current';
                const version = program.version || '1.0';
                const effectiveDate = program.effectiveDate || '';
                const effectiveUntil = program.effectiveUntil || '';
                
                // Debug logging (remove in production if needed)
                if (!effectiveDate && status === 'current') {
                    console.warn(`Missing effectiveDate for ${key}:`, program);
                }
                
                // Add version information to label based on status
                if (status === 'current') {
                    displayLabel += ` (Current - Effective ${effectiveDate})`;
                } else if (status === 'proposed') {
                    displayLabel += ` (Proposed - Effective ${effectiveDate})`;
                } else if (status === 'archived') {
                    if (effectiveUntil) {
                        displayLabel += ` (Archived - Effective Until ${effectiveUntil})`;
                    } else {
                        displayLabel += ` (Archived - v${version})`;
                    }
                }
                
                return {
                    key: key,
                    name: program.name || 'Unknown',
                    displayLabel: displayLabel,
                    status: status,
                    effectiveDate: effectiveDate,
                    sortOrder: status === 'current' ? 1 : status === 'proposed' ? 2 : 3
                };
            });

            // Sort: Current first, then proposed, then archived. CHE always first within each group
            programs.sort((a, b) => {
                // Sort by status first (current < proposed < archived)
                if (a.sortOrder !== b.sortOrder) {
                    return a.sortOrder - b.sortOrder;
                }
                
                // Within same status, CHE always first
                if (a.key === 'CHE' || a.key.startsWith('CHE-')) return -1;
                if (b.key === 'CHE' || b.key.startsWith('CHE-')) return 1;
                
                // Otherwise sort alphabetically by name
                return a.name.localeCompare(b.name);
            });

            // Add all programs as individual options with separators between status groups
            let lastStatus = null;
            programs.forEach(program => {
                // Add separator when status changes
                if (lastStatus !== null && lastStatus !== program.status) {
                    const separator = document.createElement('option');
                    separator.disabled = true;
                    separator.textContent = 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€';
                    select.appendChild(separator);
                }
                
                const option = document.createElement('option');
                option.value = program.key;
                option.textContent = program.displayLabel;
                select.appendChild(option);
                
                lastStatus = program.status;
            });
        }

        document.addEventListener('DOMContentLoaded', function() {
            try {
                // Initialize DOM cache first
                initDOMCache();

                // Set print date for footer
                try {
                    const printDate = new Date().toLocaleDateString('en-US', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric'
                    });
                    document.body.setAttribute('data-print-date', printDate);
                } catch (error) {
                    console.error('Error setting print date:', error);
                }

                // Populate program selector from programsData
                try {
                    populateProgramSelector();
                } catch (error) {
                    console.error('Error populating program selector:', error);
                }

                // Check and show disclaimer if needed
                try {
                    checkAndShowDisclaimer();
                } catch (error) {
                    console.error('Error checking disclaimer:', error);
                }

                // Check for URL parameter to set initial program
                try {
                    const urlParams = new URLSearchParams(window.location.search);
                    const programParam = urlParams.get('program');

                    // Validate program parameter against whitelist
                    if (programParam) {
                        // Sanitize input - only allow alphanumeric, hyphens, and underscores
                        const sanitizedParam = programParam.replace(/[^a-zA-Z0-9\-_]/g, '');

                        // Check if sanitized param exists in programsData
                        if (sanitizedParam && Object.prototype.hasOwnProperty.call(programsData, sanitizedParam)) {
                            currentProgram = sanitizedParam;
                            courseData = programsData[currentProgram].courseData;
                            semesterOrder = programsData[currentProgram].semesterOrder;
                            window.courseData = courseData;
                            window.semesterOrder = semesterOrder;

                            // Update dropdown
                            const select = domCache.programSelect;
                            if (select) select.value = currentProgram;

                            // Update title
                            const programTitle = domCache.programTitle;
                            if (programTitle) {
                                programTitle.textContent = programsData[currentProgram].fullTitle;
                            }
                        } else {
                            // Invalid program parameter - log but continue with default
                            console.warn('Invalid program parameter provided');
                        }
                    }
                } catch (error) {
                    console.error('Error processing URL parameters:', error);
                }

                // Build and render flowchart
                try {
                    leadsToMap = buildLeadsToMap();
                    buildFlowchart();
                    buildTextView();
                    setupScrollIndicators();
                    createArrowMarkers();
                    updateSVGSize();

            // OPTIMIZATION: Build caches after initial layout
            setTimeout(() => {
                rectCache.rebuild();
                courseElementCache.rebuild();
                // Draw all connections automatically on load (static version)
                drawAllConnections();
                // Build highlighting cache AFTER connections are drawn
                highlightingCache.rebuild();
            }, 100);
                } catch (error) {
                    console.error('Error building flowchart:', error);
                    alert('Error loading flowchart. Please refresh the page.');
                }

                // Initialize dot states after everything is rendered
                try {
                    setTimeout(() => {
                        updateActiveIndicator();
                    }, 100);
                } catch (error) {
                    console.error('Error initializing scroll indicators:', error);
                }

                // Add resize listener
                try {
                    window.addEventListener('resize', () => {
                        updateSVGSize();
                        // OPTIMIZATION: Rebuild caches on resize since layout changed
                        rectCache.rebuild();
                        courseElementCache.rebuild();
                        highlightingCache.rebuild();
                    });
                } catch (error) {
                    console.error('Error adding resize listener:', error);
                }

                // Add event listeners for buttons
                try {
                    const disclaimerButton = domCache.disclaimerModal?.querySelector('.modal-button');
                    if (disclaimerButton) {
                        disclaimerButton.addEventListener('click', closeDisclaimerModal);
                    }

                    const guideToggle = domCache.guideToggle;
                    if (guideToggle) {
                        guideToggle.addEventListener('click', toggleGuide);
                    }

                    const toggleBtn = domCache.toggleBtn;
                    if (toggleBtn) {
                        toggleBtn.addEventListener('click', toggleView);
                    }

                    const closeCourseInfoBtn = domCache.closeCourseInfoBtn;
                    if (closeCourseInfoBtn) {
                        closeCourseInfoBtn.addEventListener('click', window.closeCourseInfo);
                    }

                    const scrollLeftBtn = domCache.scrollLeftBtn;
                    const scrollRightBtn = domCache.scrollRightBtn;
                    if (scrollLeftBtn && scrollRightBtn) {
                        function scrollStep(direction) {
                            const wrapper = domCache.visualView;
                            if (!wrapper) return;
                            
                            // Calculate scroll amount (approximately one semester width)
                            const scrollAmount = 250;
                            const currentScroll = wrapper.scrollLeft;
                            const targetScroll = direction === 'left' 
                                ? Math.max(0, currentScroll - scrollAmount)
                                : currentScroll + scrollAmount;
                            
                            wrapper.scrollTo({
                                left: targetScroll,
                                behavior: 'auto'
                            });
                        }
                        
                        scrollLeftBtn.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            scrollStep('left');
                        });
                        scrollRightBtn.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            scrollStep('right');
                        });
                    }

                    const programSelect = domCache.programSelect;
                    if (programSelect) {
                        programSelect.addEventListener('change', switchProgram);
                    }

                    document.addEventListener('click', (e) => {
                        // Close pane if clicking outside
                        const courseInfoPane = domCache.courseInfoPane;

                        if (courseInfoPane && courseInfoPane.getAttribute('aria-hidden') === 'false') {
                            // Don't close pane if clicking on program selector, scroll arrows, or scroll dots (they have their own handlers)
                            if (!e.target.closest('#courseInfoPane') && !e.target.closest('.course') && !e.target.closest('.program-selector') && !e.target.closest('.scroll-arrow') && !e.target.closest('.scroll-dot')) {
                                window.closeCourseInfo();
                            }
                        }

                        // Clear course highlights if clicking outside
                        if (!e.target.closest('.course') && selectedCourseKey) {
                            window.clearHighlights();
                        }
                    });
                } catch (error) {
                    console.error('Error setting up event listeners:', error);
                }
            } catch (error) {
                console.error('Critical error during initialization:', error);
                alert('An error occurred while loading the application. Please refresh the page.');
            }
        });
        
        function setupScrollIndicators() {
            const container = domCache.flowchartContainer;
            const indicatorsDiv = domCache.scrollIndicators;
            const wrapper = domCache.visualView;

            if (!container || !indicatorsDiv || !wrapper) return;

            // Clear existing indicators efficiently
            while (indicatorsDiv.firstChild) {
                indicatorsDiv.removeChild(indicatorsDiv.firstChild);
            }

            semesterOrder.forEach((semester, index) => {
                const dot = document.createElement('button');
                dot.className = 'scroll-dot';
                dot.setAttribute('type', 'button');

                // Add visually-hidden text for visible label requirement
                const label = document.createElement('span');
                label.className = 'visually-hidden';
                if (index === 0) {
                    dot.classList.add('active');
                    label.textContent = `Jump to ${semester} (current)`;
                } else {
                    label.textContent = `Jump to ${semester}`;
                }
                dot.appendChild(label);
                
                dot.addEventListener('click', () => {
                    const columns = container.querySelectorAll('.semester-column');
                    if (columns[index]) {
                        columns[index].scrollIntoView({
                            behavior: 'smooth',
                            block: 'nearest',
                            inline: 'start'
                        });
                        // Move focus to first course in the scrolled semester
                        setTimeout(() => {
                            const firstCourse = columns[index].querySelector('.course');
                            if (firstCourse) {
                                firstCourse.focus();
                            }
                        }, 500);
                    }
                });
                
                indicatorsDiv.appendChild(dot);
            });
            
            let scrollTimeout;
            wrapper.addEventListener('scroll', () => {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    updateActiveIndicator();
                }, 100);
            });
        }
        
        function updateActiveIndicator() {
            const wrapper = domCache.visualView;
            const container = domCache.flowchartContainer;
            const dots = document.querySelectorAll('.scroll-dot');

            if (!wrapper || !container || dots.length === 0) return;
            
            const scrollLeft = wrapper.scrollLeft;
            const wrapperWidth = wrapper.clientWidth;
            const scrollWidth = wrapper.scrollWidth;
            const columns = container.querySelectorAll('.semester-column');
            
            const visibleLeft = scrollLeft;
            const visibleRight = scrollLeft + wrapperWidth;
            
            if (scrollLeft + wrapperWidth >= scrollWidth - 5) {
                dots.forEach((dot, index) => {
                    const semester = window.semesterOrder[index];
                    if (index === dots.length - 1) {
                        dot.classList.add('active');
                        dot.setAttribute('aria-label', `Jump to ${semester} (current)`);
                    } else {
                        dot.classList.remove('active');
                        dot.setAttribute('aria-label', `Jump to ${semester}`);
                    }
                    
                    const column = columns[index];
                    const columnLeft = column.offsetLeft - container.offsetLeft;
                    const columnRight = columnLeft + column.offsetWidth;
                    const isInView = columnRight > visibleLeft && columnLeft < visibleRight;
                    
                    if (isInView) {
                        dot.classList.remove('out-of-view');
                    } else {
                        dot.classList.add('out-of-view');
                    }
                });
                return;
            }
            
            if (scrollLeft <= 5) {
                dots.forEach((dot, index) => {
                    const semester = window.semesterOrder[index];
                    if (index === 0) {
                        dot.classList.add('active');
                        dot.setAttribute('aria-label', `Jump to ${semester} (current)`);
                    } else {
                        dot.classList.remove('active');
                        dot.setAttribute('aria-label', `Jump to ${semester}`);
                    }
                    
                    const column = columns[index];
                    const columnLeft = column.offsetLeft - container.offsetLeft;
                    const columnRight = columnLeft + column.offsetWidth;
                    const isInView = columnRight > visibleLeft && columnLeft < visibleRight;
                    
                    if (isInView) {
                        dot.classList.remove('out-of-view');
                    } else {
                        dot.classList.add('out-of-view');
                    }
                });
                return;
            }
            
            let activeIndex = 0;
            let minDistance = Infinity;
            
            columns.forEach((column, index) => {
                const columnLeft = column.offsetLeft - container.offsetLeft;
                const distance = Math.abs(scrollLeft - columnLeft);
                
                if (distance < minDistance) {
                    minDistance = distance;
                    activeIndex = index;
                }
            });
            
            dots.forEach((dot, index) => {
                const semester = window.semesterOrder[index];
                if (index === activeIndex) {
                    dot.classList.add('active');
                    dot.setAttribute('aria-label', `Jump to ${semester} (current)`);
                } else {
                    dot.classList.remove('active');
                    dot.setAttribute('aria-label', `Jump to ${semester}`);
                }
                
                const column = columns[index];
                const columnLeft = column.offsetLeft - container.offsetLeft;
                const columnRight = columnLeft + column.offsetWidth;
                const isInView = columnRight > visibleLeft && columnLeft < visibleRight;
                
                if (isInView) {
                    dot.classList.remove('out-of-view');
                } else {
                    dot.classList.add('out-of-view');
                }
            });
        }
        
        function buildTextView() {
            const container = domCache.textContent;
            if (!container) return;

            // Clear existing content before rebuilding
            container.innerHTML = '';

            const courseBySemester = {};
            semesterOrder.forEach(sem => courseBySemester[sem] = []);

            Object.entries(courseData).forEach(([key, course]) => {
                courseBySemester[course.semester].push({key, ...course});
            });

            semesterOrder.forEach((semester, semesterIndex) => {
                const semesterSection = document.createElement('section');
                semesterSection.className = 'text-semester';
                semesterSection.setAttribute('aria-labelledby', `text-sem${semesterIndex}-heading`);

                const header = document.createElement('h3');
                header.id = `text-sem${semesterIndex}-heading`;
                header.textContent = semester;
                semesterSection.appendChild(header);

                courseBySemester[semester].forEach(course => {
                    const courseDiv = document.createElement('div');
                    courseDiv.className = `text-course ${course.type}`;

                    const heading = document.createElement('h4');
                    // AAA Compliance: Format course code with abbreviation
                    const formattedCode = formatCourseCodeWithAbbr(course.code);
                    heading.innerHTML = `${formattedCode} - ${course.name} (${course.credits} credits)`;
                    courseDiv.appendChild(heading);

                    // Add description if available
                    if (course.description) {
                        const descP = document.createElement('p');
                        descP.innerHTML = `<em>${course.description}</em>`;
                        descP.style.color = '#555';
                        descP.style.marginTop = '5px';
                        descP.style.marginBottom = '10px';
                        courseDiv.appendChild(descP);
                    }

                    if (course.semesterRestriction) {
                        const restrictionP = document.createElement('p');
                        restrictionP.innerHTML = `<strong>Availability:</strong> ${course.semesterRestriction} only`;
                        restrictionP.style.color = '#8B4513'; // Darkened for AA contrast
                        restrictionP.style.fontWeight = '600';
                        courseDiv.appendChild(restrictionP);
                    }

                    // Prerequisites
                    const prereqP = document.createElement('p');
                    if (course.prereqs.length > 0) {
                        const prereqNames = course.prereqs.map(p => courseData[p]?.code || p).join(', ');
                        prereqP.innerHTML = `<strong>Prerequisites:</strong> ${prereqNames}`;
                        prereqP.style.color = '#b83600'; // Match PRE badge color
                    } else {
                        prereqP.innerHTML = `<strong>Prerequisites:</strong> None`;
                    }
                    courseDiv.appendChild(prereqP);

                    // Co-requisites
                    if (course.coreqs.length > 0) {
                        const coreqP = document.createElement('p');
                        const coreqNames = course.coreqs.map(c => courseData[c]?.code || c).join(', ');
                        coreqP.innerHTML = `<strong>Co-requisites:</strong> ${coreqNames}`;
                        coreqP.style.color = '#0a2f6e'; // Match CO badge color
                        courseDiv.appendChild(coreqP);
                    }

                    // Required For (outgoing connections)
                    const requiredForKeys = [];
                    Object.entries(courseData).forEach(([otherKey, otherCourse]) => {
                        if (otherCourse.prereqs && otherCourse.prereqs.includes(course.key)) {
                            requiredForKeys.push(otherKey);
                        }
                    });
                    
                    if (requiredForKeys.length > 0) {
                        const requiredForP = document.createElement('p');
                        const requiredForNames = requiredForKeys.map(k => courseData[k]?.code || k).join(', ');
                        requiredForP.innerHTML = `<strong>Required For:</strong> ${requiredForNames}`;
                        requiredForP.style.color = '#7b1fa2'; // Match purple leadsto badge color
                        courseDiv.appendChild(requiredForP);
                    }

                    // Alternatives
                    if (course.alternatives && course.alternatives.length > 0) {
                        const altP = document.createElement('p');
                        if (course.alternatives.length === 1) {
                            altP.innerHTML = `<strong>Alternative:</strong> ${course.alternatives[0]}`;
                        } else {
                            const altList = course.alternatives.map((alt, index) =>
                                `<br>&nbsp;&nbsp;Option ${index + 1}: ${alt}`
                            ).join('');
                            altP.innerHTML = `<strong>Alternatives:</strong>${altList}`;
                        }
                        courseDiv.appendChild(altP);
                    }

                    // Notes
                    if (course.notes && course.notes.trim() !== '') {
                        const notesP = document.createElement('p');
                        notesP.style.fontStyle = 'italic';
                        notesP.style.color = '#444';

                        // Add "Notes:" label
                        const strong = document.createElement('strong');
                        strong.textContent = 'Notes: ';
                        notesP.appendChild(strong);

                        // Safely create links from notes text
                        const safeContent = createSafeLinksFromText(course.notes);
                        notesP.appendChild(safeContent);

                        courseDiv.appendChild(notesP);
                    }

                    semesterSection.appendChild(courseDiv);
                });

                container.appendChild(semesterSection);
            });
        }

        window.toggleGuide = function() {
            const heading = domCache.guideToggle;
            const content = domCache.guideContent;

            if (!heading || !content) return;

            const isCollapsed = heading.classList.toggle('collapsed');
            content.classList.toggle('hidden');

            heading.setAttribute('aria-expanded', !isCollapsed);
        };

        let currentView = 'visual';
        window.toggleView = function() {
            const visualView = domCache.visualView;
            const textView = domCache.textView;
            const scrollControls = domCache.scrollControls;
            const btn = domCache.toggleBtn;
            const announcer = domCache.announcements;

            if (!visualView || !textView || !btn) return;

            if (currentView === 'visual') {
                visualView.style.display = 'none';
                textView.style.display = 'block';
                scrollControls.style.display = 'none';
                btn.textContent = 'Switch to Visual Flowchart';

                if (announcer) {
                    announcer.textContent = 'Switched to text-only view. Courses are now listed by semester with prerequisites, corequisites, and Required For relationships. Use heading navigation to jump between semesters.';
                }

                currentView = 'text';

                // Move focus to the first heading in text view
                setTimeout(() => {
                    const firstHeading = textView.querySelector('h3');
                    if (firstHeading) {
                        firstHeading.setAttribute('tabindex', '-1');
                        firstHeading.focus();
                    }
                }, 100);
            } else {
                visualView.style.display = 'block';
                textView.style.display = 'none';
                scrollControls.style.display = 'block';
                btn.textContent = 'Switch to Text-Only View';

                if (announcer) {
                    announcer.textContent = 'Switched to visual flowchart view. Interactive course boxes are now displayed.';
                }

                currentView = 'visual';

                // Apply centering and focus to the first course
                setTimeout(() => {
                    // Apply centering styles
                    applyCenteringLogic();
                    
                    // Move focus to the first course in visual view
                    const firstCourse = visualView.querySelector('.course');
                    if (firstCourse) {
                        firstCourse.focus();
                    }
                }, 10);
            }
        };

        // Line highlighting functionality
        let currentlyHighlightedCourse = null;

        window.highlightCourseLines = function(courseKey) {
            if (currentlyHighlightedCourse === courseKey) {
                // Already highlighted, clear it
                window.clearHighlights();
                return;
            }

            // Clear any previous highlights
            window.clearHighlights();

            // Mark current
            currentlyHighlightedCourse = courseKey;

            // OPTIMIZATION: Use single requestAnimationFrame to batch DOM operations
            requestAnimationFrame(() => {
                // OPTIMIZATION #4: Use cached collections instead of querying DOM
                const allPaths = highlightingCache.allPaths || document.querySelectorAll('.connection-path');
                const allIndicators = highlightingCache.allIndicators || document.querySelectorAll('.connection-indicator');
                const courseDivs = highlightingCache.allCourses || document.querySelectorAll('[data-course-key]');

                // Track which courses are relevant
                const relevantCourses = new Set();
                relevantCourses.add(courseKey); // The selected course itself

                // Find and highlight all paths and indicators connected to this course
                const highlightedPaths = new Set();
                const highlightedIndicators = new Set();
                const matchedPaths = [];
                const svg = domCache.connectionsSvg;
                const fadedSvg = document.getElementById('fadedConnectionsSvg');
                
                // Identify what needs to be highlighted
                allPaths.forEach(path => {
                    const fromCourse = path.getAttribute('data-from-course');
                    const toCourse = path.getAttribute('data-to-course');

                    // Highlight if this course is source or destination
                    if (fromCourse === courseKey || toCourse === courseKey) {
                        matchedPaths.push({fromCourse, toCourse});
                        highlightedPaths.add(path);
                        
                        // Track connected courses as relevant
                        relevantCourses.add(fromCourse);
                        relevantCourses.add(toCourse);

                        // Find associated indicators
                        allIndicators.forEach(indicator => {
                            const indFromCourse = indicator.getAttribute('data-from-course');
                            const indToCourse = indicator.getAttribute('data-to-course');
                            if (indFromCourse === fromCourse && indToCourse === toCourse) {
                                highlightedIndicators.add(indicator);
                            }
                        });
                    }
                });

                // Batch all DOM modifications together
                // Highlight the clicked course
                courseDivs.forEach(courseDiv => {
                    if (courseDiv.getAttribute('data-course-key') === courseKey) {
                        courseDiv.classList.add('highlighted');
                        courseDiv.classList.add('selected');
                        courseDiv.setAttribute('aria-pressed', 'true');
                    }
                });

                // Apply path highlighting and move to appropriate SVG
                allPaths.forEach(path => {
                    if (highlightedPaths.has(path)) {
                        path.classList.add('highlighted');
                        // Move to main SVG (z-index 5)
                        if (svg) {
                            svg.appendChild(path);
                        }
                    } else {
                        path.classList.add('faded');
                        // Move to faded SVG layer
                        if (fadedSvg) {
                            fadedSvg.appendChild(path);
                        }
                    }
                });

                // Apply indicator highlighting
                allIndicators.forEach(indicator => {
                    if (highlightedIndicators.has(indicator)) {
                        indicator.classList.add('highlighted');
                        if (svg) {
                            svg.appendChild(indicator);
                        }
                    } else {
                        indicator.classList.add('faded');
                        if (fadedSvg) {
                            fadedSvg.appendChild(indicator);
                        }
                    }
                });

                // Highlight and dim courses in one pass
                courseDivs.forEach(courseDiv => {
                    const otherCourseKey = courseDiv.getAttribute('data-course-key');
                    if (relevantCourses.has(otherCourseKey) && otherCourseKey !== courseKey) {
                        courseDiv.classList.add('highlighted');
                    } else if (!relevantCourses.has(otherCourseKey)) {
                        courseDiv.classList.add('dimmed');
                    }
                });

                // Add relationship badges to relevant courses
                const selectedCourse = courseData[courseKey];
                if (selectedCourse) {
                    // Track which courses get badges (to enforce one badge per course)
                    const badgesAdded = new Set();

                    // Priority 1: CO badges (corequisites)
                    if (selectedCourse.coreqs && selectedCourse.coreqs.length > 0) {
                        selectedCourse.coreqs.forEach(coreqKey => {
                            if (!badgesAdded.has(coreqKey)) {
                                const coreqDiv = courseElementCache.get(coreqKey);
                                if (coreqDiv) {
                                    const badge = document.createElement('div');
                                    badge.className = 'relationship-badge coreq';
                                    badge.textContent = 'CO';
                                    badge.title = 'Co-requisite for selected course';
                                    coreqDiv.appendChild(badge);
                                    coreqDiv.classList.add('coreq-glow'); // Add blue glow
                                    badgesAdded.add(coreqKey);
                                }
                            }
                        });
                    }

                    // Priority 2: PRE badges (prerequisites)
                    if (selectedCourse.prereqs && selectedCourse.prereqs.length > 0) {
                        selectedCourse.prereqs.forEach(prereqKey => {
                            if (!badgesAdded.has(prereqKey)) {
                                const prereqDiv = courseElementCache.get(prereqKey);
                                if (prereqDiv) {
                                    const badge = document.createElement('div');
                                    badge.className = 'relationship-badge prereq';
                                    badge.textContent = 'PRE';
                                    badge.title = 'Prerequisite for selected course';
                                    prereqDiv.appendChild(badge);
                                    prereqDiv.classList.add('prereq-glow'); // Add orange glow
                                    badgesAdded.add(prereqKey);
                                }
                            }
                        });
                    }

                    // Priority 3: â–¶ badges to courses this course leads to
                    // OPTIMIZATION: Use pre-computed leadsToMap instead of iterating all courses
                    const leadsTo = leadsToMap[courseKey];
                    if (leadsTo) {
                        const leadsToKeys = [...leadsTo.asPrereq, ...leadsTo.asCoreq];
                        leadsToKeys.forEach(otherKey => {
                            if (!badgesAdded.has(otherKey)) {
                                const otherCourse = courseData[otherKey];
                                const otherDiv = document.querySelector(`[data-course-key="${otherKey}"]`);
                                if (otherDiv && otherCourse) {
                                    const badge = document.createElement('div');
                                    badge.className = 'relationship-badge leadsto';
                                    badge.textContent = 'â–¶';
                                    badge.title = 'This course leads to: ' + otherCourse.code;
                                    otherDiv.appendChild(badge);
                                    otherDiv.classList.add('leadsto-glow'); // Add green glow
                                    badgesAdded.add(otherKey);
                                }
                            }
                        });
                    }
                }
            });

        };

        window.clearHighlights = function() {
            currentlyHighlightedCourse = null;

            const allPaths = document.querySelectorAll('.connection-path');
            const allIndicators = document.querySelectorAll('.connection-indicator');
            const courseDivs = document.querySelectorAll('[data-course-key]');
            const svg = domCache.connectionsSvg;

            allPaths.forEach(path => {
                path.classList.remove('highlighted');
                path.classList.remove('faded');
                // Move all paths back to main SVG when clearing
                if (svg) {
                    svg.appendChild(path);
                }
            });

            allIndicators.forEach(indicator => {
                indicator.classList.remove('highlighted');
                indicator.classList.remove('faded');
                // Move all indicators back to main SVG when clearing
                if (svg) {
                    svg.appendChild(indicator);
                }
            });

            courseDivs.forEach(courseDiv => {
                courseDiv.classList.remove('highlighted');
                courseDiv.classList.remove('selected');
                courseDiv.classList.remove('dimmed');
                courseDiv.classList.remove('prereq-glow');
                courseDiv.classList.remove('coreq-glow');
                courseDiv.classList.remove('leadsto-glow');
                courseDiv.setAttribute('aria-pressed', 'false');
                
                // Remove relationship badges (PRE, CO, â–¶)
                const badges = courseDiv.querySelectorAll('.relationship-badge');
                badges.forEach(badge => {
                    badge.remove();
                });
            });
        };

        // Keyboard navigation support
        let focusedCourseKey = null;

        function getFocusableCourses() {
            return Array.from(document.querySelectorAll('.course[data-course-key]'));
        }

        function getCurrentCourse() {
            if (!focusedCourseKey) return null;
            return document.querySelector(`.course[data-course-key="${focusedCourseKey}"]`);
        }

        function getClosestCourse(courses, direction) {
            const currentCourse = getCurrentCourse();
            if (!currentCourse) {
                // No course focused, return first course
                return courses[0];
            }

            const currentRect = currentCourse.getBoundingClientRect();
            const currentCenterX = currentRect.left + currentRect.width / 2;
            const currentCenterY = currentRect.top + currentRect.height / 2;

            let closest = null;
            let closestDistance = Infinity;

            courses.forEach(course => {
                if (course === currentCourse) return; // Skip current course

                const rect = course.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                let isInDirection = false;
                let distance = 0;

                if (direction === 'right') {
                    if (centerX > currentCenterX) {
                        isInDirection = true;
                        distance = Math.hypot(centerX - currentCenterX, centerY - currentCenterY);
                    }
                } else if (direction === 'left') {
                    if (centerX < currentCenterX) {
                        isInDirection = true;
                        distance = Math.hypot(centerX - currentCenterX, centerY - currentCenterY);
                    }
                } else if (direction === 'down') {
                    if (centerY > currentCenterY) {
                        isInDirection = true;
                        distance = Math.hypot(centerX - currentCenterX, centerY - currentCenterY);
                    }
                } else if (direction === 'up') {
                    if (centerY < currentCenterY) {
                        isInDirection = true;
                        distance = Math.hypot(centerX - currentCenterX, centerY - currentCenterY);
                    }
                }

                if (isInDirection && distance < closestDistance) {
                    closestDistance = distance;
                    closest = course;
                }
            });

            // If no course found in that direction, wrap around or return first
            if (!closest) {
                // Simple fallback: return first course
                return courses[0];
            }

            return closest;
        }

        function focusCourse(courseKey) {
            const courseDiv = document.querySelector(`.course[data-course-key="${courseKey}"]`);
            if (courseDiv) {
                focusedCourseKey = courseKey;
                courseDiv.focus();
                courseDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
                window.highlightCourseLines(courseKey);
            }
        }

        function navigateCourses(direction) {
            const courses = getFocusableCourses();
            if (courses.length === 0) return;

            const nextCourse = getClosestCourse(courses, direction);
            if (nextCourse) {
                const nextCourseKey = nextCourse.getAttribute('data-course-key');
                focusCourse(nextCourseKey);
            }
        }

        // Add keyboard event listener
        function setupKeyboardNavigation() {
            document.addEventListener('keydown', (e) => {
                // Only handle keyboard navigation in visual view
                if (currentView !== 'visual') return;

                // Check if focus is on an input or select element (skip keyboard nav in these cases)
                if (['INPUT', 'SELECT', 'TEXTAREA'].includes(document.activeElement.tagName)) {
                    return;
                }

                // Escape closes pane first
                if (e.key === 'Escape') {
                    const courseInfoPane = domCache.courseInfoPane;
                    
                    if (courseInfoPane && courseInfoPane.getAttribute('aria-hidden') === 'false') {
                        window.closeCourseInfo();
                        return;
                    }
                    
                    // If no pane open, clear highlights
                    window.clearHighlights();
                    focusedCourseKey = null;
                    return;
                }

                switch(e.key) {
                    case 'ArrowRight':
                    case 'ArrowDown':
                        e.preventDefault();
                        navigateCourses(e.key === 'ArrowRight' ? 'right' : 'down');
                        break;
                    case 'ArrowLeft':
                    case 'ArrowUp':
                        e.preventDefault();
                        navigateCourses(e.key === 'ArrowLeft' ? 'left' : 'up');
                        break;
                    case 'Enter':
                    case ' ':
                        // If a course is focused, highlight it
                        if (focusedCourseKey) {
                            window.highlightCourseLines(focusedCourseKey);
                        }
                        break;
                    case 'i':
                    case 'I':
                        // Show course info pane for focused course
                        if (focusedCourseKey) {
                            e.preventDefault();
                            showCourseInfo(focusedCourseKey, 'details');
                        }
                        break;
                }
            });
        }

        // Add click handlers to course boxes
        function attachCourseClickHandlers() {
            const courseDivs = document.querySelectorAll('.course[data-course-key]');
            courseDivs.forEach(courseDiv => {
                courseDiv.addEventListener('click', (e) => {
                    const courseKey = courseDiv.getAttribute('data-course-key');
                    
                    // If clicking the same course that's currently highlighted, deselect it
                    if (currentlyHighlightedCourse === courseKey) {
                        window.clearHighlights();
                        window.closeCourseInfo();
                        return;
                    }
                    
                    // Highlight the new course and show pane
                    window.highlightCourseLines(courseKey);
                    showCourseInfo(courseKey, 'details');
                });
                
                // Make courses keyboard focusable
                courseDiv.setAttribute('tabindex', '0');
                courseDiv.setAttribute('role', 'button');
                courseDiv.setAttribute('aria-pressed', 'false');
            });
        }

        window.addEventListener('DOMContentLoaded', () => {
            attachCourseClickHandlers();
            setupKeyboardNavigation();
        });

        // Make it globally available so switchProgram can call it
        window.attachCourseClickHandlers = attachCourseClickHandlers;

        // Function to apply centering based on window width
        function applyCenteringLogic() {
            const visualView = domCache.visualView;
            const flowchartContainer = domCache.flowchartContainer;
            
            if (!visualView || !flowchartContainer) return;
            
            if (window.innerWidth >= 1700) {
                visualView.style.justifyContent = 'center';
                visualView.style.alignItems = 'flex-start';
                flowchartContainer.style.margin = '0 auto';
            } else {
                visualView.style.justifyContent = 'flex-start';
                visualView.style.alignItems = 'flex-start';
                flowchartContainer.style.margin = '0';
            }
        }

        window.applyCenteringLogic = applyCenteringLogic;
    </script>
</body>
</html>
