<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WSU Engineering Curriculum Flowchart</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸŽ“</text></svg>">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; line-height: 1.6; padding: 1.25rem; background: #f5f5f5; }

        /* Standardized focus indicator for accessibility */
        *:focus {
            outline: 3px solid #A60F2D;
            outline-offset: 2px;
        }

        .skip-link { position: absolute; top: -2.5rem; left: 0; background: #A60F2D; color: white; padding: 0.5rem 1rem; text-decoration: none; z-index: 100; font-weight: bold; }
        .skip-link:focus { top: 0; }

        .visually-hidden { position: absolute; left: -10000px; width: 1px; height: 1px; overflow: hidden; }
        
        header { background: #A60F2D; color: white; padding: 1.25rem; margin-bottom: 1.875rem; border-radius: 0.5rem; }
        h1 { font-size: 1.8em; margin-bottom: 0.625rem; }
        .subtitle { font-size: 1.1em; opacity: 0.9; }

        .program-selector { margin-top: 0.938rem; }
        .program-selector label { font-size: 1em; font-weight: bold; margin-right: 0.625rem; display: inline-block; }
        .program-selector select {
            font-size: 1em;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            border: 2px solid white;
            background: white;
            color: #A60F2D;
            font-weight: bold;
            cursor: pointer;
            max-width: 100%;
            min-width: min(300px, 100%);
        }
        .program-selector select:focus {
            outline: 3px solid #fff;
            outline-offset: 2px;
        }
        .program-selector select option {
            font-weight: bold;
        }
        .program-selector select optgroup {
            font-weight: bold;
        }
        .diagram-wrapper { background: white; padding: 1.875rem; border-radius: 0.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1); overflow-x: auto; position: relative; scroll-behavior: smooth; display: flex; justify-content: flex-start; }
        .diagram-container { position: relative; min-width: 1600px; display: flex; gap: 70px; scroll-snap-type: x mandatory; }

        @media (min-width: 1700px) {
            .diagram-wrapper { justify-content: center; }
        }
        .semester-column { flex: 0 0 180px; display: flex; flex-direction: column; gap: 20px; scroll-snap-align: start; }
        .semester-header { font-size: 1em; font-weight: bold; color: white; background: #A60F2D; padding: 0.625rem; border-radius: 0.375rem; text-align: center; margin-bottom: 0.313rem; }
        .semester-header .credits { font-weight: normal; font-size: 0.85em; opacity: 0.9; }
        .course { padding: 0.625rem; border-radius: 0.375rem; border: 3px solid #333; min-height: 4.688rem; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; cursor: default; position: relative; z-index: 10; }
        /* .course:focus removed for static version - no interaction */
        /* .course:hover removed for static version */
        .course.engineering { background: #8fc9f7; border-color: #1565c0; color: #002942; }
        .course.science { background: #a5d6a7; border-color: #2e7d32; color: #003d0a; }
        .course.ucore { background: #ce93d8; border-color: #6a1b9a; color: #1f0030; }
        .course.technical { background: #bdbdbd; border-color: #616161; color: #212121; }
        .course-code { font-weight: bold; font-size: 1em; display: block; margin-bottom: 0.25rem; text-align: center; }
        .course-name { font-size: 0.9em; font-weight: 600; display: block; margin-bottom: 0.25rem; text-align: center; line-height: 1.3; }
        .course-credits { font-size: 0.8em; display: block; text-align: center; }
        
        .relationship-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #ff9800;
            color: white;
            border-radius: 4px;
            padding: 0.188rem 0.375rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7em;
            font-weight: bold;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            z-index: 200;
        }
        
        .relationship-badge.prereq { background: #c44100; }
        .relationship-badge.coreq { background: #0d47a1; }
        .relationship-badge.leadsto { background: #1b5e20; }

        .semester-restriction-badge {
            position: absolute;
            bottom: -8px;
            right: -8px;
            background: #D2691E;
            color: white;
            border-radius: 4px;
            padding: 0.188rem 0.375rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7em;
            font-weight: bold;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            z-index: 200;
        }

        .semester-restriction-badge.fall { background: #8B4513; }
        .semester-restriction-badge.spring { background: #1b5e20; }
        .semester-restriction-badge.summer { background: #c44100; }

        .notes-indicator {
            position: absolute;
            top: -8px;
            left: -8px;
            background: #757575;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75em;
            font-weight: bold;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            z-index: 200;
        }

        .notes-indicator:hover {
            background: #616161;
        }

        .alternatives-indicator {
            position: absolute;
            bottom: -8px;
            left: -8px;
            background: #616161;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6em;
            font-weight: bold;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            z-index: 200;
            cursor: pointer;
            transition: transform 0.2s ease;
            line-height: 1;
        }

        .alternatives-indicator:hover {
            transform: scale(1.1);
            background: #424242;
        }
        
        .notes-tooltip {
            position: fixed;
            background: white;
            border: 2px solid #757575;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            width: 400px;
            max-width: calc(100vw - 40px);
            z-index: 10000;
            display: none;
        }
        
        .notes-tooltip.visible {
            display: block;
        }
        
        .notes-tooltip[role="tooltip"] {
            outline: none;
        }
        
        .notes-tooltip-header {
            font-weight: bold;
            color: #424242;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .notes-tooltip-content {
            color: #333;
            line-height: 1.5;
        }
        
        .notes-tooltip-close {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            font-size: 1.2em;
            color: #666;
            cursor: pointer;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }
        
        .notes-tooltip-close:hover {
            background: #f0f0f0;
            color: #333;
        }

        .alternatives-tooltip {
            border-color: #616161;
        }

        .alternatives-tooltip .notes-tooltip-header {
            color: #424242;
            border-bottom-color: #616161;
        }
        
        .text-semester { margin-bottom: 40px; }
        .text-semester h3 { color: #A60F2D; font-size: 1.4em; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 3px solid #A60F2D; }
        .text-semester h4 { font-size: 1.1em; margin-bottom: 8px; color: #333; }
        .text-course { margin-bottom: 15px; padding: 15px; border-left: 5px solid #1565c0; background: #f5f5f5; border-radius: 4px; }
        .text-course.science { border-left-color: #2e7d32; }
        .text-course.ucore { border-left-color: #6a1b9a; }
        .text-course p { margin: 5px 0; color: #666; }
        kbd { background: #fff; border: 1px solid #ccc; border-radius: 3px; padding: 2px 6px; font-family: monospace; font-weight: bold; }
        
        .legend { background: #f0f0f0; padding: 0.938rem; margin-bottom: 1.25rem; border-radius: 0.375rem; border-left: 4px solid #A60F2D; }
        #guideToggle { font-size: 1em; margin-bottom: 0.5rem; color: #A60F2D; cursor: pointer; user-select: none; display: flex; align-items: center; justify-content: space-between; font-weight: bold; border: none; background: none; padding: 0; text-align: left; width: 100%; font-family: Arial, sans-serif; }
        #guideToggle:hover { color: #8a0c24; }
        #guideToggle::after { content: 'â–¼'; font-size: 0.8em; transition: transform 0.3s ease; }
        #guideToggle.collapsed::after { transform: rotate(-90deg); }
        .legend-content { transition: all 0.3s ease; overflow: hidden; }
        .legend-content.hidden { max-height: 0; opacity: 0; margin: 0; }
        .legend-section { margin-bottom: 20px; }
        .legend-section:last-child { margin-bottom: 0; }
        .legend-items { display: flex; flex-wrap: wrap; gap: 20px; }
        .legend-item { display: flex; align-items: center; gap: 8px; }
        .legend-box { width: 30px; height: 30px; border-radius: 4px; border: 3px solid; }
        .legend-box.engineering { background: #8fc9f7; border-color: #1565c0; }
        .legend-box.science { background: #a5d6a7; border-color: #2e7d32; }
        .legend-box.ucore { background: #ce93d8; border-color: #6a1b9a; }
        .legend-box.technical { background: #bdbdbd; border-color: #616161; }
        .legend-label { font-size: 0.9em; font-weight: 500; }
        
        .scroll-indicators { display: flex; justify-content: center; gap: 0.625rem; margin-top: 0.938rem; padding: 0.625rem; }
        .scroll-dot { width: 10px; height: 10px; border-radius: 50%; background: #ff6b6b; cursor: pointer; transition: all 0.3s ease; border: 2px solid #ff5252; }
        .scroll-dot:hover { background: #A60F2D; border-color: #8a0c24; transform: scale(1.2); }
        .scroll-dot:focus {
            background: #A60F2D;
        }
        .scroll-dot.active { background: #A60F2D; width: 14px; height: 14px; border: 3px solid #8a0c24; box-shadow: 0 0 8px rgba(166, 15, 45, 0.5); }
        .scroll-dot.out-of-view { background: white; border: 2px solid #333; opacity: 1; }
        .scroll-hint { text-align: center; color: #666; font-size: 0.9em; margin-top: 0.625rem; padding: 0.5rem; background: #f9f9f9; border-radius: 0.25rem; }
        
        @media (max-width: 768px) {
            .scroll-hint { font-size: 0.85em; }
        }
        
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }
            .course:hover { transform: none; }
            .scroll-dot { transition: none; }
        }

        /* Disclaimer Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10001;
            padding: 20px;
        }

        .modal-overlay.hidden {
            display: none;
        }

        .modal-content {
            background: white;
            border-radius: 8px;
            padding: 30px;
            max-width: 600px;
            width: 100%;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .modal-content h2 {
            color: #A60F2D;
            font-size: 1.5em;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .modal-content p {
            line-height: 1.6;
            margin-bottom: 15px;
            color: #333;
        }

        .modal-content ul {
            margin: 15px 0 15px 25px;
            line-height: 1.8;
        }

        .modal-content li {
            margin-bottom: 8px;
        }

        .modal-content a {
            color: #A60F2D;
            text-decoration: underline;
        }

        .modal-content a:hover {
            color: #8a0c24;
        }

        .modal-button {
            background: #A60F2D;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1.1em;
            font-weight: bold;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 20px;
            width: 100%;
        }

        .modal-button:hover {
            background: #8a0c24;
        }

        /* Modal button uses default focus style */

        /* Print Styles */
        @media print {
            /* Page setup for landscape single page */
            @page {
                size: landscape;
                margin: 0.4in;
            }

            /* Hide interactive elements only */
            .skip-link,
            .program-selector,
            .scroll-indicators,
            .scroll-hint,
            #toggleBtn,
            .modal-overlay {
                display: none !important;
            }

            /* Keep body and main container as-is */
            body {
                background: white;
            }

            /* Header - minimal adjustments */
            header {
                page-break-after: avoid;
            }

            /* Legend - keep visible but compact */
            .legend {
                page-break-after: avoid;
                margin-bottom: 0.1in;
            }

            /* Main flowchart container */
            main {
                padding: 0;
            }

            .diagram-wrapper {
                overflow: visible !important;
                box-shadow: none !important;
                /* Scale down to fit all semesters on one page */
                transform: scale(0.72);
                transform-origin: top left;
                page-break-inside: avoid;
            }

            /* Ensure SVG connections are visible */
            #connectionsSvg {
                display: block !important;
                print-color-adjust: exact;
                -webkit-print-color-adjust: exact;
            }

            /* Ensure connection lines print */
            #connectionsSvg path,
            #connectionsSvg circle,
            #connectionsSvg polygon {
                print-color-adjust: exact;
                -webkit-print-color-adjust: exact;
            }

            /* Ensure course colors print */
            .course {
                print-color-adjust: exact;
                -webkit-print-color-adjust: exact;
                page-break-inside: avoid;
            }

            /* Remove transitions for faster printing */
            * {
                transition: none !important;
                animation: none !important;
            }

            /* Hide tooltips */
            .notes-tooltip,
            .alternatives-tooltip {
                display: none !important;
            }
        }
    
        /* Lane routing styles for static flowchart */
        .diagram-wrapper {
            padding-top: 30px !important;
            padding-bottom: 30px !important;
        }

        .routing-lane {
            position: absolute;
            left: 0;
            right: 0;
            height: 80px;
            background: rgba(230, 230, 230, 0.3);
            border-top: 2px dashed #999;
            border-bottom: 2px dashed #999;
            z-index: 1;
            pointer-events: none;
        }

        .routing-lane.top {
            top: 20px;
        }

        .routing-lane.bottom {
            bottom: 20px;
        }

        .routing-lane-label {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.8em;
            color: #666;
            font-weight: bold;
            background: white;
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid #999;
        }
    
    </style>
</head>
<body>
    <!-- Disclaimer Modal -->
    <div id="disclaimerModal" class="modal-overlay" role="dialog" aria-labelledby="disclaimerTitle" aria-modal="true">
        <div class="modal-content">
            <h2 id="disclaimerTitle">Important: Planning Tool Disclaimer</h2>
            <p>This flowchart is provided for <strong>convenience only</strong> to help you visualize your degree plan. The official <a href="https://catalog.wsu.edu/" target="_blank" rel="noopener noreferrer" aria-label="WSU catalog (opens in new window)">WSU catalog</a> is the authoritative reference for all degree requirements.</p>

            <p><strong>Students are responsible for:</strong></p>
            <ul>
                <li>Verifying all course information against the official catalog</li>
                <li>Following <a href="https://registrar.wsu.edu/academic-regulations/#108" target="_blank" rel="noopener noreferrer" aria-label="WSU academic regulations (opens in new window)">WSU academic regulations</a></li>
                <li>Consulting with their academic advisor for questions or concerns</li>
            </ul>

            <p>By using this tool, you acknowledge that it is for planning purposes only and may not reflect the most current information.</p>

            <button class="modal-button" id="disclaimerButton">I Understand</button>
        </div>
    </div>

    <a href="#main-content" class="skip-link">Skip to main content</a>
    
    <header role="banner">
        <h1>Washington State University</h1>
        <p class="subtitle">Voiland School of Chemical Engineering and Bioengineering</p>
        <p class="subtitle" id="programTitle">Bachelor of Science - Chemical Engineering (4 Year Plan)</p>
        <div class="program-selector">
            <label for="programSelect">Select Program:</label>
            <select id="programSelect">
                <!-- Options will be populated dynamically from programsData -->
            </select>
        </div>
    </header>
    
    <main role="main" id="main-content">
        <h2 class="visually-hidden">Curriculum Flowchart</h2>
        <div id="announcements" style="position: absolute; left: -10000px; width: 1px; height: 1px; overflow: hidden;" aria-live="polite" aria-atomic="true"></div>

        <div style="text-align: center; margin-bottom: 20px;">
            <button id="toggleBtn" style="display: none;" style="padding: 12px 24px; font-size: 1em; font-weight: bold; background: #A60F2D; color: white; border: 2px solid #A60F2D; border-radius: 6px; cursor: pointer;">
                Switch to Text-Only View
            </button>
        </div>
        
        <div class="diagram-wrapper" id="visualView" role="application" aria-label="Course flowchart showing prerequisites and corequisites">
            <div class="diagram-container" id="flowchartContainer">
                <svg id="connectionsSvg" aria-hidden="true" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1;">
                </svg>
            </div>
        </div>
        <div class="scroll-controls">
            <div class="scroll-indicators" role="navigation" aria-label="Semester navigation">
                <div id="scrollIndicators"></div>
            </div>
            <div class="scroll-hint"><span aria-hidden="true">ðŸ’¡</span> Swipe or scroll horizontally to view all semesters â€¢ Click dots to jump to a semester</div>
        </div>
        
        <div id="textView" style="display: none; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
            <h2 style="color: #A60F2D; margin-bottom: 20px;">Text-Based Course Listing</h2>
            <div id="textContent"></div>
        </div>
        
        <!-- Notes tooltip -->
        <div id="notesTooltip" class="notes-tooltip" role="tooltip" aria-live="polite">
            <button class="notes-tooltip-close" id="closeNotesBtn" aria-label="Close notes">âœ•</button>
            <div class="notes-tooltip-header" id="tooltipHeader"></div>
            <div class="notes-tooltip-content" id="tooltipContent"></div>
        </div>

        <!-- Alternatives tooltip -->
        <div id="alternativesTooltip" class="notes-tooltip alternatives-tooltip" role="tooltip" aria-live="polite">
            <button class="notes-tooltip-close" id="closeAlternativesBtn" aria-label="Close alternatives">âœ•</button>
            <div class="notes-tooltip-header" id="alternativesHeader"></div>
            <div class="notes-tooltip-content" id="alternativesContent"></div>
        </div>
    </main>

    <!-- Load external course data (with cache busting timestamp) -->
    <script src="programsData.js?v=20251021"></script>

    <script>
        (function checkBrowserCompatibility() {
            try {
                const testArrow = () => true;
                const testDestructure = { a: 1 };
                const { a } = testDestructure;
                const testTemplate = `test`;

                const missingFeatures = [];

                if (typeof requestAnimationFrame !== 'function') {
                    missingFeatures.push('requestAnimationFrame');
                }
                if (typeof document.querySelector !== 'function') {
                    missingFeatures.push('querySelector');
                }
                if (!('classList' in document.createElement('div'))) {
                    missingFeatures.push('classList');
                }
                if (typeof Array.prototype.forEach !== 'function') {
                    missingFeatures.push('Array.forEach');
                }

                if (missingFeatures.length > 0) {
                    console.warn('Browser compatibility issue. Missing features:', missingFeatures.join(', '));
                    console.warn('Please use a modern browser (Chrome 80+, Firefox 75+, Safari 13.1+, Edge 80+)');
                    alert('This application requires a modern browser. Please update your browser or use Chrome, Firefox, Safari, or Edge.');
                }
            } catch (e) {
                console.error('Browser compatibility check failed:', e);
                alert('This application requires a modern browser. Please update your browser.');
            }
        })();

        // Program data loaded from external file: programsData.js

        // Current program state
        let currentProgram = 'CHE';
        let courseData = programsData[currentProgram].courseData;
        let semesterOrder = programsData[currentProgram].semesterOrder;

        // Make courseData and semesterOrder available globally
        window.courseData = courseData;
        window.semesterOrder = semesterOrder;

        // Cached DOM elements for performance
        const domCache = {
            flowchartContainer: null,
            visualView: null,
            textView: null,
            textContent: null,
            connectionsSvg: null,
            scrollIndicators: null,
            notesTooltip: null,
            alternativesTooltip: null,
            tooltipHeader: null,
            tooltipContent: null,
            alternativesHeader: null,
            alternativesContent: null,
            announcements: null,
            guideToggle: null,
            guideContent: null,
            toggleBtn: null,
            programSelect: null,
            programTitle: null,
            scrollControls: null,
            disclaimerModal: null
        };

        // Initialize DOM cache
        function initDOMCache() {
            domCache.flowchartContainer = document.getElementById('flowchartContainer');
            domCache.visualView = document.getElementById('visualView');
            domCache.textView = document.getElementById('textView');
            domCache.textContent = document.getElementById('textContent');
            domCache.connectionsSvg = document.getElementById('connectionsSvg');
            domCache.scrollIndicators = document.getElementById('scrollIndicators');
            domCache.notesTooltip = document.getElementById('notesTooltip');
            domCache.alternativesTooltip = document.getElementById('alternativesTooltip');
            domCache.tooltipHeader = document.getElementById('tooltipHeader');
            domCache.tooltipContent = document.getElementById('tooltipContent');
            domCache.alternativesHeader = document.getElementById('alternativesHeader');
            domCache.alternativesContent = document.getElementById('alternativesContent');
            domCache.announcements = document.getElementById('announcements');
            domCache.guideToggle = document.getElementById('guideToggle');
            domCache.guideContent = document.getElementById('guideContent');
            domCache.toggleBtn = document.getElementById('toggleBtn');
            domCache.programSelect = document.getElementById('programSelect');
            domCache.programTitle = document.getElementById('programTitle');
            domCache.scrollControls = document.querySelector('.scroll-controls');
            domCache.disclaimerModal = document.getElementById('disclaimerModal');
        }

        function buildLeadsToMap() {
            try {
                const leadsToMap = {};

                if (!courseData || typeof courseData !== 'object') {
                    console.error('Invalid courseData');
                    return {};
                }

                Object.keys(courseData).forEach(key => {
                    leadsToMap[key] = { asPrereq: [], asCoreq: [] };
                });

                Object.entries(courseData).forEach(([courseKey, course]) => {
                    if (!course) return;

                    if (Array.isArray(course.prereqs)) {
                        course.prereqs.forEach(prereqKey => {
                            if (leadsToMap[prereqKey]) {
                                leadsToMap[prereqKey].asPrereq.push(courseKey);
                            }
                        });
                    }

                    if (Array.isArray(course.coreqs)) {
                        course.coreqs.forEach(coreqKey => {
                            if (leadsToMap[coreqKey]) {
                                leadsToMap[coreqKey].asCoreq.push(courseKey);
                            }
                        });
                    }
                });

                return leadsToMap;
            } catch (error) {
                console.error('Error building leads-to map:', error);
                return {};
            }
        }
        
        let leadsToMap = {};
        let selectedCourseKey = null;
        let connectionCounts = {};
        let sourceConnectionCounts = {};
        let currentNotesIndicator = null;

        // Course element cache for performance optimization
        let courseElementCache = new Map();

        // Helper function: Get course element from cache or DOM
        function getCourseElement(courseKey) {
            if (!courseElementCache.has(courseKey)) {
                const element = document.querySelector(`[data-course-key="${courseKey}"]`);
                if (element) {
                    courseElementCache.set(courseKey, element);
                }
                return element;
            }
            return courseElementCache.get(courseKey);
        }

        // Helper function: Clear course element cache
        function clearCourseElementCache() {
            courseElementCache.clear();
        }


        // Utility function to safely create links from text
        function createSafeLinksFromText(text) {
            // Clear the container
            const container = document.createElement('div');

            // Split text by URL pattern
            const urlPattern = /(https?:\/\/[^\s<]+)/g;
            const parts = text.split(urlPattern);

            parts.forEach((part, index) => {
                if (index % 2 === 0) {
                    // Text part - use textContent for safety
                    if (part) {
                        const textNode = document.createTextNode(part);
                        container.appendChild(textNode);
                    }
                } else {
                    // URL part - validate and create link
                    try {
                        const url = new URL(part);
                        // Only allow http and https protocols
                        if (url.protocol === 'http:' || url.protocol === 'https:') {
                            const link = document.createElement('a');
                            link.href = url.href;
                            link.textContent = url.href; // Use textContent, not innerHTML
                            link.target = '_blank';
                            link.rel = 'noopener noreferrer';
                            link.setAttribute('aria-label', `${url.href} (opens in new window)`);
                            link.style.color = '#A60F2D';
                            link.style.textDecoration = 'underline';
                            container.appendChild(link);
                        } else {
                            // Invalid protocol - treat as text
                            container.appendChild(document.createTextNode(part));
                        }
                    } catch (e) {
                        // Invalid URL - treat as text
                        container.appendChild(document.createTextNode(part));
                    }
                }
            });

            return container;
        }

        function showNotesTooltip(courseKey, event, indicatorElement) {
            event.stopPropagation();

            // Close any open tooltips first
            closeAlternativesTooltip();

            const course = courseData[courseKey];
            if (!course || !course.notes || course.notes.trim() === '') return;

            // Use cached DOM elements
            const tooltip = domCache.notesTooltip;
            const header = domCache.tooltipHeader;
            const content = domCache.tooltipContent;
            const announcer = domCache.announcements;

            if (!tooltip || !header || !content) return;

            header.textContent = `${course.code} - ${course.name}`;

            // Safely create links from notes text
            content.textContent = ''; // Clear existing content
            const safeContent = createSafeLinksFromText(course.notes);
            content.appendChild(safeContent);

            const x = event.clientX;
            const y = event.clientY;

            tooltip.style.left = `${x + 10}px`;
            tooltip.style.top = `${y + 10}px`;

            tooltip.classList.add('visible');

            const tooltipId = 'notesTooltip';
            indicatorElement.setAttribute('aria-describedby', tooltipId);
            currentNotesIndicator = indicatorElement;

            // Store trigger for focus return
            notesTooltipTrigger = document.activeElement;
            
            if (announcer) {
                announcer.textContent = `Notes for ${course.code}: ${course.notes}`;
            }

            // Position tooltip and set focus
            const rect = tooltip.getBoundingClientRect();
            if (rect.right > window.innerWidth) {
                tooltip.style.left = `${window.innerWidth - rect.width - 20}px`;
            }
            if (rect.bottom > window.innerHeight) {
                tooltip.style.top = `${window.innerHeight - rect.height - 20}px`;
            }

            const closeBtn = tooltip.querySelector('.notes-tooltip-close');
            if (closeBtn) {
                closeBtn.focus();
                if (announcer) {
                    announcer.textContent = `Notes for ${course.code}: ${course.notes}. Press Escape to close.`;
                }
            }
        }
        
        let notesTooltipTrigger = null;

        window.closeNotesTooltip = function() {
            const tooltip = domCache.notesTooltip;
            if (tooltip) {
                tooltip.classList.remove('visible');
            }

            if (currentNotesIndicator) {
                currentNotesIndicator.removeAttribute('aria-describedby');
                currentNotesIndicator = null;
            }

            // Return focus to trigger element
            if (notesTooltipTrigger && notesTooltipTrigger.focus) {
                notesTooltipTrigger.focus();
                notesTooltipTrigger = null;
            }
        };

        let currentAlternativesIndicator = null;

        function showAlternativesTooltip(courseKey, event, indicatorElement) {
            event.stopPropagation();

            // Close any open tooltips first
            closeNotesTooltip();

            const course = courseData[courseKey];
            if (!course || !course.alternatives || course.alternatives.length === 0) return;

            // Use cached DOM elements
            const tooltip = domCache.alternativesTooltip;
            const header = domCache.alternativesHeader;
            const content = domCache.alternativesContent;
            const announcer = domCache.announcements;

            if (!tooltip || !header || !content) return;

            header.textContent = `${course.code} - Alternative Courses`;

            // Clear existing content
            content.textContent = '';

            if (course.alternatives.length === 1) {
                content.textContent = course.alternatives[0];
            } else {
                // Safely build alternatives list using DOM manipulation
                course.alternatives.forEach((alt, index) => {
                    const optionDiv = document.createElement('div');
                    optionDiv.style.marginBottom = '10px';

                    const strong = document.createElement('strong');
                    strong.textContent = `Option ${index + 1}: `;
                    optionDiv.appendChild(strong);

                    const textNode = document.createTextNode(alt);
                    optionDiv.appendChild(textNode);

                    content.appendChild(optionDiv);
                });
            }

            const x = event.clientX;
            const y = event.clientY;

            tooltip.style.left = `${x + 10}px`;
            tooltip.style.top = `${y + 10}px`;

            tooltip.classList.add('visible');

            const tooltipId = 'alternativesTooltip';
            indicatorElement.setAttribute('aria-describedby', tooltipId);
            currentAlternativesIndicator = indicatorElement;

            // Store trigger for focus return
            alternativesTooltipTrigger = document.activeElement;

            if (announcer) {
                if (course.alternatives.length === 1) {
                    announcer.textContent = `Alternative course for ${course.code}: ${course.alternatives[0]}`;
                } else {
                    const altText = course.alternatives.map((alt, index) =>
                        `Option ${index + 1}: ${alt}`
                    ).join('. ');
                    announcer.textContent = `Alternative courses for ${course.code}. ${altText}`;
                }
            }

            // Position tooltip and set focus
            const rect = tooltip.getBoundingClientRect();
            if (rect.right > window.innerWidth) {
                tooltip.style.left = `${window.innerWidth - rect.width - 20}px`;
            }
            if (rect.bottom > window.innerHeight) {
                tooltip.style.top = `${window.innerHeight - rect.height - 20}px`;
            }

            const closeBtn = tooltip.querySelector('.notes-tooltip-close');
            if (closeBtn) {
                closeBtn.focus();
                if (announcer) {
                    announcer.textContent += '. Press Escape to close.';
                }
            }
        }

        let alternativesTooltipTrigger = null;

        window.closeAlternativesTooltip = function() {
            const tooltip = domCache.alternativesTooltip;
            if (tooltip) {
                tooltip.classList.remove('visible');
            }

            if (currentAlternativesIndicator) {
                currentAlternativesIndicator.removeAttribute('aria-describedby');
                currentAlternativesIndicator = null;
            }

            // Return focus to trigger element
            if (alternativesTooltipTrigger && alternativesTooltipTrigger.focus) {
                alternativesTooltipTrigger.focus();
                alternativesTooltipTrigger = null;
            }
        };
        
        window.clearHighlights = function() {
            // Batch DOM reads and writes for better performance
            // Query once and reuse
            const courses = document.querySelectorAll('.course');

            // Remove all badges and reset styles in a single loop
            courses.forEach(courseDiv => {
                // Remove badge
                const badge = courseDiv.querySelector('.relationship-badge');
                if (badge) badge.remove();

                // Reset classes and styles
                courseDiv.classList.remove('selected', 'highlighted-prereq', 'highlighted-coreq', 'highlighted-leadsto', 'dimmed');
                courseDiv.style.cssText = ''; // Clear all inline styles at once
            });

            // Clear SVG efficiently
            const svg = domCache.connectionsSvg;
            if (svg) {
                // More efficient than innerHTML = ''
                while (svg.firstChild) {
                    svg.removeChild(svg.firstChild);
                }
            }

            connectionCounts = {};
            sourceConnectionCounts = {};

            if (selectedCourseKey) {
                const announcer = domCache.announcements;
                if (announcer) {
                    announcer.textContent = 'Course selection cleared.';
                }
            }

            selectedCourseKey = null;
        };
        
        function updateSVGSize() {
            const svg = domCache.connectionsSvg;
            const container = domCache.flowchartContainer;
            const wrapper = domCache.visualView;

            if (!svg || !container || !wrapper) return;

            // Calculate actual content dimensions based on semester columns
            const columns = container.querySelectorAll('.semester-column');
            let contentWidth = 0;
            let contentHeight = 0;

            if (columns.length > 0) {
                // Get the rightmost edge of the last column
                const lastColumn = columns[columns.length - 1];
                const containerRect = container.getBoundingClientRect();
                const lastColumnRect = lastColumn.getBoundingClientRect();
                contentWidth = (lastColumnRect.right - containerRect.left) + 30; // Add some padding

                // Get the tallest column
                columns.forEach(col => {
                    contentHeight = Math.max(contentHeight, col.offsetHeight);
                });
            }

            // Fallback to offsetWidth/Height if no columns found
            const fullWidth = contentWidth || container.offsetWidth;
            const fullHeight = contentHeight || container.offsetHeight;

            svg.style.width = fullWidth + 'px';
            svg.style.height = fullHeight + 'px';
            svg.setAttribute('width', fullWidth);
            svg.setAttribute('height', fullHeight);
            svg.setAttribute('viewBox', `0 0 ${fullWidth} ${fullHeight}`);
        }
        
        function drawConnection(fromKey, toKey, color, type, sourcePositionIndex) {
            const fromDiv = getCourseElement(fromKey);
            const toDiv = getCourseElement(toKey);
            const svg = domCache.connectionsSvg;
            const wrapper = domCache.visualView;
            const container = domCache.flowchartContainer;

            if (!fromDiv || !toDiv || !svg || !wrapper || !container) return;

            const fromRect = fromDiv.getBoundingClientRect();
            const toRect = toDiv.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();

            const fromCourse = courseData[fromKey];
            const toCourse = courseData[toKey];
            const sameSemester = fromCourse.semester === toCourse.semester;

            let fromX, fromY, toX, toY;

            if (sameSemester) {
                const fromIsAbove = fromRect.top < toRect.top;

                if (fromIsAbove) {
                    fromX = fromRect.left - containerRect.left + fromRect.width / 2;
                    fromY = fromRect.top - containerRect.top + fromRect.height;
                    toX = toRect.left - containerRect.left + toRect.width / 2;
                    toY = toRect.top - containerRect.top;
                } else {
                    fromX = fromRect.left - containerRect.left + fromRect.width / 2;
                    fromY = fromRect.top - containerRect.top;
                    toX = toRect.left - containerRect.left + toRect.width / 2;
                    toY = toRect.top - containerRect.top + toRect.height;
                }
            } else {
                if (!sourceConnectionCounts[fromKey]) {
                    sourceConnectionCounts[fromKey] = 0;
                }

                const sourceIndex = sourceConnectionCounts[fromKey];
                const totalSourceConnections = window.srcTotalConnections[fromKey] || 1;

                let sourceVerticalOffset = 0;
                if (totalSourceConnections > 1) {
                    const spacing = 15;
                    const totalSpread = (totalSourceConnections - 1) * spacing;
                    sourceVerticalOffset = (sourceIndex * spacing) - (totalSpread / 2);
                }

                sourceConnectionCounts[fromKey]++;

                // Use sourcePositionIndex to determine destination point
                // Sources with higher positions get higher destination points
                const totalConnections = window.destTotalConnections[toKey] || 1;

                let destVerticalOffset = 0;
                if (totalConnections > 1 && sourcePositionIndex !== undefined) {
                    const spacing = 15;
                    const totalSpread = (totalConnections - 1) * spacing;
                    destVerticalOffset = (sourcePositionIndex * spacing) - (totalSpread / 2);
                }

                fromX = fromRect.left - containerRect.left + fromRect.width;
                fromY = fromRect.top - containerRect.top + fromRect.height / 2 + sourceVerticalOffset;

                toX = toRect.left - containerRect.left;
                toY = toRect.top - containerRect.top + toRect.height / 2 + destVerticalOffset;
            }
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const d = `M ${fromX} ${fromY} L ${toX} ${toY}`;

            path.setAttribute('d', d);
            path.setAttribute('stroke', color);
            path.setAttribute('stroke-width', '3');
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke-opacity', '0.7');

            svg.appendChild(path);
        }
        
        function createArrowMarkers() {
            // Arrow markers removed - not currently used
        }

        // Helper function: Highlight selected course
        function highlightSelectedCourse(courseKey) {
            const selectedDiv = getCourseElement(courseKey);
            if (selectedDiv) {
                selectedDiv.classList.add('selected');
                selectedDiv.style.border = '5px solid #000';
                selectedDiv.style.boxShadow = '0 0 0 4px #A60F2D, 0 0 20px rgba(166, 15, 45, 0.5)';
                selectedDiv.style.zIndex = '100';
                selectedDiv.style.opacity = '1';
                selectedDiv.style.filter = 'none';
            }
            return selectedDiv;
        }

        // Helper function: Dim all other courses
        function dimOtherCourses(courseKey, coursesCache = null) {
            // Use cached courses if provided, otherwise query
            const courses = coursesCache || document.querySelectorAll('.course');
            courses.forEach(courseDiv => {
                if (courseDiv.getAttribute('data-course-key') !== courseKey) {
                    courseDiv.classList.add('dimmed');
                    courseDiv.style.opacity = '0.25';
                    courseDiv.style.filter = 'grayscale(80%)';
                }
            });
        }

        // Helper function: Apply relationship styling to a course
        function applyRelationshipStyle(courseDiv, type, badgeText) {
            if (!courseDiv) return;

            const styles = {
                prereq: { border: '5px solid #ff9800', boxShadow: '0 0 15px rgba(255, 152, 0, 0.8)', class: 'highlighted-prereq' },
                coreq: { border: '5px solid #2196f3', boxShadow: '0 0 15px rgba(33, 150, 243, 0.8)', class: 'highlighted-coreq' },
                leadsto: { border: '5px solid #4caf50', boxShadow: '0 0 15px rgba(76, 175, 80, 0.8)', class: 'highlighted-leadsto' }
            };

            const style = styles[type];
            if (!style) return;

            courseDiv.classList.remove('dimmed');
            courseDiv.classList.add(style.class);
            courseDiv.style.border = style.border;
            courseDiv.style.boxShadow = style.boxShadow;
            courseDiv.style.opacity = '1';
            courseDiv.style.filter = 'none';

            const badge = document.createElement('div');
            badge.className = `relationship-badge ${type}`;
            badge.textContent = badgeText;
            badge.setAttribute('aria-hidden', 'true');
            courseDiv.appendChild(badge);
        }

        // Helper function: Highlight prerequisites
        function highlightPrerequisites(prereqKeys) {
            prereqKeys.forEach(prereqKey => {
                const prereqDiv = getCourseElement(prereqKey);
                applyRelationshipStyle(prereqDiv, 'prereq', 'PR');
            });
        }

        // Helper function: Highlight corequisites
        function highlightCorequisites(coreqKeys) {
            coreqKeys.forEach(coreqKey => {
                const coreqDiv = getCourseElement(coreqKey);
                applyRelationshipStyle(coreqDiv, 'coreq', 'CO');
            });
        }

        // Helper function: Highlight courses this leads to
        function highlightLeadsTo(leadsToKeys) {
            leadsToKeys.forEach(leadsToKey => {
                const leadsToDiv = getCourseElement(leadsToKey);
                applyRelationshipStyle(leadsToDiv, 'leadsto', 'â–¶');
            });
        }

        // Helper function: Sort course keys by vertical position
        function sortCoursesByPosition(courseKeys) {
            // Pre-calculate all bounding rectangles to avoid repeated layout calculations
            const positions = new Map();
            courseKeys.forEach(key => {
                const div = getCourseElement(key);
                if (div) {
                    positions.set(key, div.getBoundingClientRect().top);
                }
            });

            return [...courseKeys].sort((a, b) => {
                const posA = positions.get(a);
                const posB = positions.get(b);
                if (posA === undefined || posB === undefined) return 0;
                return posA - posB;
            });
        }

        // Helper function: Calculate connection counts
        function calculateConnectionCounts(courseKey, prereqsSorted, coreqsSorted, leadsToSorted) {
            const destConnectionCounts = {};
            const srcConnectionCounts = {};

            prereqsSorted.forEach(prereqKey => {
                if (!destConnectionCounts[courseKey]) destConnectionCounts[courseKey] = 0;
                destConnectionCounts[courseKey]++;

                if (!srcConnectionCounts[prereqKey]) srcConnectionCounts[prereqKey] = 0;
                srcConnectionCounts[prereqKey]++;
            });

            coreqsSorted.forEach(coreqKey => {
                if (!destConnectionCounts[courseKey]) destConnectionCounts[courseKey] = 0;
                destConnectionCounts[courseKey]++;

                if (!srcConnectionCounts[coreqKey]) srcConnectionCounts[coreqKey] = 0;
                srcConnectionCounts[coreqKey]++;
            });

            leadsToSorted.forEach(leadsToKey => {
                if (!destConnectionCounts[leadsToKey]) destConnectionCounts[leadsToKey] = 0;
                destConnectionCounts[leadsToKey]++;

                if (!srcConnectionCounts[courseKey]) srcConnectionCounts[courseKey] = 0;
                srcConnectionCounts[courseKey]++;
            });

            return { destConnectionCounts, srcConnectionCounts };
        }

        // Helper function: Draw all connection lines
        // ORIGINAL FUNCTION COMMENTED OUT FOR STATIC VERSION
        /*
        function drawAllConnections(courseKey, course, prereqsSorted, coreqsSorted, leadsToSorted, destConnectionCounts, srcConnectionCounts) {
            const courseDiv = getCourseElement(courseKey);
            const courseRect = courseDiv ? courseDiv.getBoundingClientRect() : null;

            // Filter out coreqs in same semester (they use vertical connections without offsets)
            const coreqsDifferentSemester = coreqsSorted.filter(key => {
                const coreqCourse = courseData[key];
                return coreqCourse && coreqCourse.semester !== course.semester;
            });

            const incomingConnections = [
                ...prereqsSorted.map(key => ({ key, type: 'prereq', color: '#ff9800' })),
                ...coreqsDifferentSemester.map(key => ({ key, type: 'coreq', color: '#2196f3' }))
            ];

            // Calculate position and angle from each source to destination
            incomingConnections.forEach(conn => {
                const sourceDiv = getCourseElement(conn.key);
                if (sourceDiv && courseRect) {
                    const sourceRect = sourceDiv.getBoundingClientRect();
                    conn.verticalPos = sourceRect.top + sourceRect.height / 2;
                    const dx = courseRect.left - (sourceRect.left + sourceRect.width);
                    const dy = (courseRect.top + courseRect.height / 2) - (sourceRect.top + sourceRect.height / 2);
                    conn.angle = Math.atan2(dy, dx);
                } else {
                    conn.verticalPos = 0;
                    conn.angle = 0;
                }
            });

            // Sort primarily by vertical position, secondarily by angle
            incomingConnections.sort((a, b) => {
                const verticalDiff = a.verticalPos - b.verticalPos;
                if (Math.abs(verticalDiff) > 20) {
                    return verticalDiff;
                }
                return a.angle - b.angle;
            });

            // Draw all incoming connections
            incomingConnections.forEach((conn, index) => {
                drawConnection(conn.key, courseKey, conn.color, conn.type, index);
            });

            // Draw coreqs in same semester
            const coreqsSameSemester = coreqsSorted.filter(key => {
                const coreqCourse = courseData[key];
                return coreqCourse && coreqCourse.semester === course.semester;
            });
            coreqsSameSemester.forEach(coreqKey => {
                drawConnection(coreqKey, courseKey, '#2196f3', 'coreq', undefined);
            });

            // Calculate and draw outgoing connections
            const outgoingConnections = leadsToSorted.map(key => ({
                key,
                type: 'leadsto',
                color: '#4caf50'
            }));

            outgoingConnections.forEach(conn => {
                const destDiv = getCourseElement(conn.key);
                if (destDiv && courseRect) {
                    const destRect = destDiv.getBoundingClientRect();
                    conn.verticalPos = destRect.top + destRect.height / 2;
                    const dx = destRect.left - (courseRect.left + courseRect.width);
                    const dy = (destRect.top + destRect.height / 2) - (courseRect.top + courseRect.height / 2);
                    conn.angle = Math.atan2(dy, dx);
                } else {
                    conn.verticalPos = 0;
                    conn.angle = 0;
                }
            });

            outgoingConnections.sort((a, b) => {
                const verticalDiff = a.verticalPos - b.verticalPos;
                if (Math.abs(verticalDiff) > 20) {
                    return verticalDiff;
                }
                return a.angle - b.angle;
            });

            outgoingConnections.forEach((conn, index) => {
                drawConnection(courseKey, conn.key, conn.color, conn.type, index);
            });
        }
        */

        // Replacement drawAllConnections function with lane routing
// This replaces the entire original drawAllConnections function

function drawAllConnections() {
    const svg = document.getElementById('connectionsSvg');
    if (!svg) return;

    // Clear existing
    while (svg.firstChild) {
        svg.removeChild(svg.firstChild);
    }

    const courseData = window.courseData;
    const semesterOrder = window.semesterOrder;

    if (!courseData || !semesterOrder) {
        console.error('Missing courseData or semesterOrder');
        return;
    }

    // Initialize global tracking for same-semester vertical lanes
    window.sameSemesterVerticalLanesBySemester = {};
    window.sameSemesterVerticalLanesByCourse = {}; // Track lanes per source course

    // STEP 1: Create internal records for each course
    const courseRecords = {};
    const semesterGaps = {}; // Track gaps between semesters

    // Helper to get course DOM element
    function getCourseElement(courseKey) {
        return document.querySelector(`[data-course-key="${courseKey}"]`);
    }

    // Helper to get course position and dimensions
    function getCourseRect(courseKey) {
        const el = getCourseElement(courseKey);
        if (!el) return null;
        const rect = el.getBoundingClientRect();
        const svgRect = svg.getBoundingClientRect();
        return {
            left: rect.left - svgRect.left,
            right: rect.right - svgRect.left,
            top: rect.top - svgRect.top,
            bottom: rect.bottom - svgRect.top,
            width: rect.width,
            height: rect.height,
            centerX: (rect.left + rect.right) / 2 - svgRect.left,
            centerY: (rect.top + rect.bottom) / 2 - svgRect.top
        };
    }

    // PERFORMANCE OPTIMIZATION: Convert prerequisite/corequisite arrays to Sets for O(1) lookup
    // Pre-compute sets once to avoid repeated .includes() calls which are O(n)
    const prereqSetsByKey = {};
    const coreqSetsByKey = {};
    Object.keys(courseData).forEach(courseKey => {
        const course = courseData[courseKey];
        prereqSetsByKey[courseKey] = new Set(course.prereqs || []);
        coreqSetsByKey[courseKey] = new Set(course.coreqs || []);
    });

    // Build course records
    Object.keys(courseData).forEach(courseKey => {
        const course = courseData[courseKey];
        const allPrereqs = [...(course.prereqs || []), ...(course.coreqs || [])];

        // Find courses that this course is a prereq/coreq for
        const isPrereqFor = [];
        const isPrereqForWithType = []; // Track type (prereq vs coreq)
        Object.keys(courseData).forEach(otherKey => {
            const other = courseData[otherKey];
            // Use pre-computed Sets for O(1) lookup instead of array .includes()
            if (prereqSetsByKey[otherKey].has(courseKey)) {
                isPrereqFor.push(otherKey);
                isPrereqForWithType.push({ courseKey: otherKey, type: 'prereq' });
            } else if (coreqSetsByKey[otherKey].has(courseKey)) {
                isPrereqFor.push(otherKey);
                isPrereqForWithType.push({ courseKey: otherKey, type: 'coreq' });
            }
        });

        courseRecords[courseKey] = {
            courseKey,
            semester: course.semester,
            prereqCount: allPrereqs.length,
            isPrereqForCount: isPrereqFor.length,
            allPrereqs,
            isPrereqFor,
            isPrereqForWithType, // New: track connection types
            leftStubs: [],  // Will be populated with stub positions
            rightStubs: [], // Will be populated with stub positions
            rect: null      // Will be populated with actual position
        };
    });

    // Get actual positions for all courses
    Object.keys(courseRecords).forEach(key => {
        courseRecords[key].rect = getCourseRect(key);
    });

    // PERFORMANCE OPTIMIZATION: Cache all bounding rects once to avoid repeated reflow triggers
    const boundingRectCache = new Map();
    const svgElement = document.getElementById('connectionsSvg');
    const svgRect = svgElement.getBoundingClientRect();
    boundingRectCache.set('svg', svgRect);
    
    // Cache all course element bounding rects
    Object.keys(courseRecords).forEach(key => {
        const element = getCourseElement(key);
        if (element) {
            boundingRectCache.set(key, element.getBoundingClientRect());
        }
    });

    // PERFORMANCE OPTIMIZATION: Pre-compute sorted course lists by semester
    // These are used in conflict detection and bounding box calculations - avoid rebuilding for each connection
    const courseListBySemester = {};
    semesterOrder.forEach(semester => {
        courseListBySemester[semester] = Object.keys(courseData)
            .filter(k => courseData[k].semester === semester)
            .sort((a, b) => a.localeCompare(b));
    });

    // PERFORMANCE OPTIMIZATION: Build semester index map for O(1) lookups
    // Replace expensive indexOf() calls with O(1) Map.get() operations
    const semesterIndexMap = new Map();
    semesterOrder.forEach((semester, index) => {
        semesterIndexMap.set(semester, index);
    });

    // Filter out courses without positions (not visible)
    const visibleCourses = Object.keys(courseRecords).filter(key => courseRecords[key].rect !== null);

    // STEP 2: Create stubs on left side (one for each prereq/coreq)
    visibleCourses.forEach(courseKey => {
        const record = courseRecords[courseKey];
        const rect = record.rect;
        const count = record.prereqCount;

        if (count > 0) {
            // Distribute stubs evenly on the left side
            for (let i = 0; i < count; i++) {
                const y = rect.top + (rect.height * (i + 1) / (count + 1));
                record.leftStubs.push({
                    x: rect.left,
                    y: y,
                    used: false,
                    fromCourse: null
                });
            }
            // Sort top to bottom
            record.leftStubs.sort((a, b) => a.y - b.y);
        }
    });

    // STEP 3: Create ONE stub on right side per course (all outputs share this stub)
    visibleCourses.forEach(courseKey => {
        const record = courseRecords[courseKey];
        const rect = record.rect;

        if (record.isPrereqForCount > 0) {
            // Single output stub at center-right, positioned at 9% from top of course box
            const outputStubY = rect.top + (rect.height * 0.09);
            record.rightStubs.push({
                x: rect.right,
                y: outputStubY,
                used: false,
                connections: [] // Track all connections using this stub
            });

            // Create vertical lanes for same-semester connections
            // These are X positions where vertical segments can be placed
            if (!record.sameSemesterVerticalLanes) {
                record.sameSemesterVerticalLanes = [];
            }
        }
    });

    // Add vertical lanes for courses that receive same-semester connections from above
    visibleCourses.forEach(courseKey => {
        const record = courseRecords[courseKey];
        const rect = record.rect;

        if (record.hasPrereqsCount > 0 || record.hasCoreqsCount > 0) {
            // Create vertical lanes for same-semester connections
            if (!record.sameSemesterVerticalLanes) {
                record.sameSemesterVerticalLanes = [];
            }
        }
    });

    // STEP 4: Count stubs in each gap and calculate lanes needed
    // First, identify semester positions
    const semesterPositions = {};
    semesterOrder.forEach((semester, idx) => {
        const coursesInSemester = visibleCourses.filter(k => courseRecords[k].semester === semester);
        if (coursesInSemester.length > 0) {
            const rects = coursesInSemester.map(k => courseRecords[k].rect);
            let leftMost = Infinity, rightMost = -Infinity, topMost = Infinity, bottomMost = -Infinity;
            for (const rect of rects) {
                leftMost = Math.min(leftMost, rect.left);
                rightMost = Math.max(rightMost, rect.right);
                topMost = Math.min(topMost, rect.top);
                bottomMost = Math.max(bottomMost, rect.bottom);
            }

            semesterPositions[semester] = {
                index: idx,
                left: leftMost,
                right: rightMost,
                top: topMost,
                bottom: bottomMost,
                centerX: (leftMost + rightMost) / 2
            };
        }
    });

    // Calculate gaps between semesters
    for (let i = 0; i < semesterOrder.length - 1; i++) {
        const currentSem = semesterOrder[i];
        const nextSem = semesterOrder[i + 1];

        if (semesterPositions[currentSem] && semesterPositions[nextSem]) {
            const gapKey = `${currentSem}|${nextSem}`;
            const gapLeft = semesterPositions[currentSem].right;
            const gapRight = semesterPositions[nextSem].left;
            const gapWidth = gapRight - gapLeft;

            // Count COURSES that cross this gap (not connections)
            let courseCount = 0;
            visibleCourses.forEach(fromKey => {
                const fromRecord = courseRecords[fromKey];
                if (fromRecord.semester === currentSem && fromRecord.isPrereqForCount > 0) {
                    // Check if this course has any connections crossing this gap
                    const hasConnectionAcrossGap = fromRecord.isPrereqFor.some(toKey => {
                        const toRecord = courseRecords[toKey];
                        return toRecord && toRecord.rect && toRecord.semester !== currentSem;
                    });
                    if (hasConnectionAcrossGap) {
                        courseCount++;
                    }
                }
            });

            semesterGaps[gapKey] = {
                left: gapLeft,
                right: gapRight,
                width: gapWidth,
                courseCount: courseCount,
                laneCount: courseCount + 2, // Add 2 extra lanes as specified
                lanes: [],
                fromSemester: currentSem,
                toSemester: nextSem
            };

            // Create lane positions (evenly distributed in the gap)
            const laneCount = semesterGaps[gapKey].laneCount;
            for (let l = 0; l < laneCount; l++) {
                const x = gapLeft + (gapWidth * (l + 1) / (laneCount + 1));
                semesterGaps[gapKey].lanes.push({
                    x: x,
                    reservations: [], // Array of {y1, y2, fromCourse}
                    assignedToCourse: null // Track which course is using this lane
                });
            }
        }
    }

    // STEP 5: Create horizontal lanes - one above first course, and between each pair of courses
    const horizontalLanesBySemester = {};
    semesterOrder.forEach(semester => {
        if (!semesterPositions[semester]) return;

        // Get all courses in this semester and their positions
        const coursesInSem = visibleCourses.filter(k => courseRecords[k].semester === semester);
        const courseRects = coursesInSem.map(k => courseRecords[k].rect).sort((a, b) => a.top - b.top);

        horizontalLanesBySemester[semester] = [];

        // Add ONE lane above the first course (positioned between semester header and first course)
        if (courseRects.length > 0) {
            const firstRect = courseRects[0];
            // Get the semester header to calculate position between header and first course
            const semesterColumn = document.querySelector(`[data-semester="${semester}"]`);
            const semesterHeader = semesterColumn?.querySelector('.semester-header');
            const headerRect = semesterHeader?.getBoundingClientRect();

            // Position lane halfway between header bottom and first course top
            let laneY;
            if (headerRect) {
                const gapBetweenHeaderAndCourse = firstRect.top - headerRect.bottom;
                laneY = headerRect.bottom + (gapBetweenHeaderAndCourse / 2);
            } else {
                // Fallback if header not found: 10px above first course
                laneY = firstRect.top - 10;
            }

            horizontalLanesBySemester[semester].push({
                y: laneY,
                reservations: [],
                betweenCourses: null, // Special: above all courses
                isPrimary: true,
                isAboveAll: true // Flag to indicate this is the top lane
            });
        }

        // Add lanes ONLY between each pair of courses
        for (let i = 0; i < courseRects.length - 1; i++) {
            const currentRect = courseRects[i];
            const nextRect = courseRects[i + 1];
            const gap = nextRect.top - currentRect.bottom;

            // Create 2 lanes: primary (closer to top, default) and secondary (backup)
            const spacing = gap / 3;

            // Primary lane (closer to top course, used by default)
            horizontalLanesBySemester[semester].push({
                y: currentRect.bottom + spacing,
                reservations: [],
                betweenCourses: [i, i + 1],
                isPrimary: true // Preferred lane
            });

            // Secondary lane (backup, only used when primary conflicts)
            horizontalLanesBySemester[semester].push({
                y: currentRect.bottom + spacing * 2,
                reservations: [],
                betweenCourses: [i, i + 1],
                isPrimary: false // Backup lane
            });
            // If gap is too small (< 8px), no horizontal lanes in this gap
        }

        // Add ONE lane below the last course
        if (courseRects.length > 0) {
            const lastRect = courseRects[courseRects.length - 1];
            // Position lane below the last course
            const laneY = lastRect.bottom + 20; // 20px below last course

            horizontalLanesBySemester[semester].push({
                y: laneY,
                reservations: [],
                betweenCourses: null, // Special: below all courses
                isPrimary: true,
                isBelowAll: true // Flag to indicate this is the bottom lane
            });
        }
    });

    // STEP 6: Route connections from earliest to latest courses
    const connections = [];

    // Collect all connections
    visibleCourses.forEach(fromKey => {
        const fromRecord = courseRecords[fromKey];
        fromRecord.isPrereqForWithType.forEach(connection => {
            const toKey = connection.courseKey;
            const toRecord = courseRecords[toKey];
            if (toRecord && toRecord.rect) {
                connections.push({
                    from: fromKey,
                    to: toKey,
                    type: connection.type, // 'prereq' or 'coreq'
                    fromRecord,
                    toRecord
                });
            }
        });
    });

    // Sort connections by source position (top to bottom, left to right)
    connections.sort((a, b) => {
        const aRect = a.fromRecord.rect;
        const bRect = b.fromRecord.rect;
        if (Math.abs(aRect.centerY - bRect.centerY) > 5) {
            return aRect.centerY - bRect.centerY;
        }
        return aRect.centerX - bRect.centerX;
    });

    // Helper: Check if a vertical lane segment is available
    function isLaneAvailable(lane, y1, y2, startY = null, endY = null, fromCourse = null, toCourse = null, isAdjacentSemester = false) {
        const minY = Math.min(y1, y2);
        const maxY = Math.max(y1, y2);

        // Add buffer zones to prevent horizontal segments from being too close
        const BUFFER = 60; // Minimum vertical separation between horizontal segments (increased for better spacing)

        return !lane.reservations.some(res => {
            // Rule 1: Same source can share if same routing type. Rule 2: Same target cannot share
            if (fromCourse && res.fromCourse === fromCourse) {
                // Same source course - check if different routing types
                if (isAdjacentSemester !== res.isAdjacentSemester) {
                    // Adjacent and multi-semester cannot share lane even from same source
                    return true; // Conflict
                }

                // Same source and same routing type - check if going to same target
                if (toCourse && res.toCourse === toCourse) {
                    // Same source AND same target - this shouldn't happen (duplicate connection)
                    // But if it does, don't allow sharing
                    return true;
                }
                // Same course - check for crossing paths even if same source
                // This prevents adjacent and cross-semester connections from same course from crossing
                if (startY !== null && endY !== null && res.startY !== null && res.endY !== null) {
                    const thisGoingDown = startY < endY;
                    const resGoingDown = res.startY < res.endY;

                    // If going in opposite directions, they might cross - check Y-range overlap
                    if (thisGoingDown !== resGoingDown) {
                        const resMinY = Math.min(res.y1, res.y2);
                        const resMaxY = Math.max(res.y1, res.y2);
                        const verticalOverlap = !(maxY < resMinY || minY > resMaxY);
                        if (verticalOverlap) {
                            return true; // Conflict - paths from same course cross each other
                        }
                    }
                }

                // Otherwise, only check if vertical ranges overlap (no buffer for same course)
                const resMinY = Math.min(res.y1, res.y2);
                const resMaxY = Math.max(res.y1, res.y2);
                return !(maxY < resMinY || minY > resMaxY);
            }

            // Rule 2: Same target CANNOT share lane - must conflict
            if (toCourse && res.toCourse && toCourse === res.toCourse && fromCourse !== res.fromCourse) {
                // Different sources going to same target - CANNOT share lane
                return true; // Conflict
            }

            const resMinY = Math.min(res.y1, res.y2);
            const resMaxY = Math.max(res.y1, res.y2);

            // Check if vertical ranges overlap OR are within buffer distance
            // Ranges conflict if they're not sufficiently separated (with buffer on both sides)
            const verticalOverlap = !(maxY + BUFFER < resMinY || minY - BUFFER > resMaxY);

            // Check for crossing paths: if one path goes down and another goes up in overlapping Y-ranges, they cross
            // This is critical when adjacent semester connects to lower stub and cross-semester connects to higher stub
            if (startY !== null && endY !== null && res.startY !== null && res.endY !== null) {
                const thisGoingDown = startY < endY;
                const resGoingDown = res.startY < res.endY;

                // If going in opposite directions and Y-ranges overlap, they will cross
                if (thisGoingDown !== resGoingDown && verticalOverlap) {
                    return true; // Conflict - paths cross
                }
            }

            // Check if horizontal segments at start/end conflict
            // startY is the Y-position where this connection's horizontal segment leaves the source course
            // endY is the Y-position where this connection's horizontal segment enters the destination course
            // We need to check if these conflict with existing horizontal segments in this lane
            let horizontalConflict = false;

            // Check all combinations of start/end positions more efficiently
            if (startY !== null && (res.startY !== null || res.endY !== null)) {
                if ((res.startY !== null && Math.abs(startY - res.startY) < BUFFER) ||
                    (res.endY !== null && Math.abs(startY - res.endY) < BUFFER)) {
                    horizontalConflict = true;
                }
            }

            if (!horizontalConflict && endY !== null && (res.startY !== null || res.endY !== null)) {
                if ((res.startY !== null && Math.abs(endY - res.startY) < BUFFER) ||
                    (res.endY !== null && Math.abs(endY - res.endY) < BUFFER)) {
                    horizontalConflict = true;
                }
            }

            return verticalOverlap || horizontalConflict;
        });
    }

    // Helper: Check if a horizontal lane segment is available
    function isHorizontalLaneAvailable(lane, x1, x2) {
        const minX = Math.min(x1, x2);
        const maxX = Math.max(x1, x2);
        return !lane.reservations.some(res => {
            const resMinX = Math.min(res.x1, res.x2);
            const resMaxX = Math.max(res.x1, res.x2);
            return !(maxX < resMinX || minX > resMaxX);
        });
    }

    // Helper: Find closest available horizontal lane in a semester to a target Y
    function findClosestAvailableHorizontalLane(semester, x1, x2, targetY, preferTopLane = false, debugCourse = null) {
        const lanes = horizontalLanesBySemester[semester];
        if (!lanes || lanes.length === 0) return null;

        let availableLanes = lanes.filter(lane => isHorizontalLaneAvailable(lane, x1, x2));
        if (availableLanes.length === 0) return null;

        // ADDITIONAL FILTER: Avoid Y-positions that conflict with vertical lanes AND stubs
        // Check all gaps adjacent to this semester
        const semIdx = semesterIndexMap.get(semester);
        // Reduce conflict buffer when not preferring top lane - allows more flexibility for bottom courses
        const conflictBuffer = preferTopLane ? 30 : 15;
        const stubBuffer = 20; // Buffer to avoid overlapping with stubs

        availableLanes = availableLanes.filter(lane => {
            // If we're preferring top lane and this IS the top lane, skip stub conflict checks
            // The top lane is above all courses, so stub conflicts don't matter
            if (preferTopLane && lane.isAboveAll) {
                // Still need to check vertical lane conflicts below, but skip stub checks
            } else {
                // First check: Does this lane conflict with any stubs in this semester?
                const coursesInSemester = visibleCourses.filter(k => courseRecords[k].semester === semester);
                for (const courseKey of coursesInSemester) {
                    const record = courseRecords[courseKey];

                    // Check left stubs (input stubs)
                    for (const stub of record.leftStubs) {
                        if (Math.abs(lane.y - stub.y) < stubBuffer) {
                            return false; // Lane conflicts with input stub
                        }
                    }

                    // Check right stubs (output stubs)
                    for (const stub of record.rightStubs) {
                        if (Math.abs(lane.y - stub.y) < stubBuffer) {
                            return false; // Lane conflicts with output stub
                        }
                    }
                }
            }

            // Skip conflict detection for non-top lanes when we're not preferring top lane
            // This allows bottom courses to use nearby lanes even if there are vertical conflicts
            if (!preferTopLane && !lane.isAboveAll) {
                return true;
            }

            // When preferring top lane, also skip vertical conflict checks for the top lane itself
            // The top lane is high enough that it shouldn't conflict with most connections
            if (preferTopLane && lane.isAboveAll) {
                return true;
            }

            let hasConflict = false;

            // Check gap to the left (previous semester | this semester)
            if (semIdx > 0) {
                const leftGapKey = `${semesterOrder[semIdx - 1]}|${semester}`;
                const leftGap = semesterGaps[leftGapKey];
                if (leftGap) {
                    // Check if any vertical lane in this gap has a reservation at this Y-position
                    leftGap.lanes.forEach(vLane => {
                        vLane.reservations.forEach(res => {
                            // Check if this horizontal lane's Y conflicts with the vertical lane's Y-range
                            const resMinY = Math.min(res.y1, res.y2);
                            const resMaxY = Math.max(res.y1, res.y2);
                            if (lane.y >= resMinY - conflictBuffer && lane.y <= resMaxY + conflictBuffer) {
                                hasConflict = true;
                            }
                            // Also check startY and endY (horizontal segment positions)
                            if (res.startY !== null && Math.abs(lane.y - res.startY) < conflictBuffer) {
                                hasConflict = true;
                            }
                            if (res.endY !== null && Math.abs(lane.y - res.endY) < conflictBuffer) {
                                hasConflict = true;
                            }
                        });
                    });
                }
            }

            // Check gap to the right (this semester | next semester)
            if (semIdx < semesterOrder.length - 1) {
                const rightGapKey = `${semester}|${semesterOrder[semIdx + 1]}`;
                const rightGap = semesterGaps[rightGapKey];
                if (rightGap) {
                    rightGap.lanes.forEach(vLane => {
                        vLane.reservations.forEach(res => {
                            const resMinY = Math.min(res.y1, res.y2);
                            const resMaxY = Math.max(res.y1, res.y2);
                            if (lane.y >= resMinY - conflictBuffer && lane.y <= resMaxY + conflictBuffer) {
                                hasConflict = true;
                            }
                            if (res.startY !== null && Math.abs(lane.y - res.startY) < conflictBuffer) {
                                hasConflict = true;
                            }
                            if (res.endY !== null && Math.abs(lane.y - res.endY) < conflictBuffer) {
                                hasConflict = true;
                            }
                        });
                    });
                }
            }

            return !hasConflict;
        });

        if (availableLanes.length === 0) return null;

        availableLanes.sort((a, b) => {
            const distA = Math.abs(a.y - targetY);
            const distB = Math.abs(b.y - targetY);

            if (preferTopLane) {
                const topLaneDistanceThreshold = 80;
                if (a.isAboveAll && distA <= topLaneDistanceThreshold && !b.isAboveAll) return -1;
                if (b.isAboveAll && distB <= topLaneDistanceThreshold && !a.isAboveAll) return 1;
            }

            if (Math.abs(distA - distB) < 50) {
                if ((a.isPrimary && !a.isAboveAll) && !(b.isPrimary && !b.isAboveAll)) return -1;
                if (!(a.isPrimary && !a.isAboveAll) && (b.isPrimary && !b.isAboveAll)) return 1;
            }

            return distA - distB;
        });

        return availableLanes[0];
    }

    function reserveHorizontalLane(lane, x1, x2, fromCourse) {
        lane.reservations.push({ x1, x2, fromCourse });
    }

    // Helper: Reserve vertical lane segment
    function reserveVerticalLane(lane, y1, y2, fromCourse, startY = null, endY = null, toCourse = null, isAdjacentSemester = false) {
        // y1, y2: vertical segment range
        // startY: Y-position of horizontal segment at the start (from course output to vertical lane)
        // endY: Y-position of horizontal segment at the end (from vertical lane to course input)
        // toCourse: destination course (to enforce same-target cannot share lane rule)
        // isAdjacentSemester: true for adjacent semester direct connections, false for multi-semester
        lane.reservations.push({ y1, y2, fromCourse, startY, endY, toCourse, isAdjacentSemester });
    }

    // Group connections by source course (all connections from same course share one lane)
    const connectionsByCourse = {};
    connections.forEach(conn => {
        if (!connectionsByCourse[conn.from]) {
            connectionsByCourse[conn.from] = [];
        }
        connectionsByCourse[conn.from].push(conn);
    });

    // Helper: Find available lane for specific Y-range in a gap
    function findAvailableLaneForRange(gap, y1, y2, startY = null, endY = null, preferEarly = true, fromCourse = null, toCourse = null, isAdjacentSemester = false) {
        if (!gap) return null;

        // Simplified: Always use first available lane for all cross-semester courses
        // Adjacent and cross-semester courses for the same source course use DIFFERENT lanes
        for (const lane of gap.lanes) {
            if (isLaneAvailable(lane, y1, y2, startY, endY, fromCourse, toCourse, isAdjacentSemester)) {
                return lane;
            }
        }
        return null; // No available lane
    }

    // 10 distinct high-contrast colors ordered to maximize contrast between adjacent colors
    // Order alternates between warm/cool and light/dark hues for maximum visual separation
    // Pre-computed outside function to avoid array recreation on every call
    const DISTINCT_COLORS = [
        '#e6194b', // Bright Red (warm, saturated)
        '#0891b2', // Cyan (cool, medium)
        '#d4a017', // Golden Yellow (warm, medium-dark)
        '#911eb4', // Purple (cool, dark)
        '#f58231', // Orange (warm, bright)
        '#008080', // Teal (cool, dark)
        '#f032e6', // Magenta (warm-cool, bright)
        '#3cb44b', // Bright Green (cool, saturated)
        '#9a6324', // Brown (warm, dark)
        '#4363d8'  // Bright Blue (cool, saturated)
    ];

    // Helper: Generate a unique color for each course
    function getCourseColor(courseKey, index) {
        // Use modulo to cycle through the 10 colors
        return DISTINCT_COLORS[index % DISTINCT_COLORS.length];
    }

    // Assign colors to courses using graph coloring algorithm
    // Build a conflict graph: courses that overlap in lanes need different colors
    const courseColors = {};
    const conflicts = {}; // conflicts[courseKey] = Set of conflicting courseKeys

    // Initialize conflict tracking
    Object.keys(connectionsByCourse).forEach(courseKey => {
        conflicts[courseKey] = new Set();
    });

    // Detect conflicts using actual bounding box intersection
    const courseKeys = Object.keys(connectionsByCourse);

    // Helper: Calculate bounding box for a connection path
    const getConnectionBoundingBox = (conn) => {
        const fromSem = courseData[conn.from].semester;
        const toSem = courseData[conn.to].semester;

        // Get pre-computed sorted course lists by semester (avoid rebuilding for each call)
        const fromSemesterCourses = courseListBySemester[fromSem];
        const toSemesterCourses = courseListBySemester[toSem];

        const fromIndex = fromSemesterCourses.indexOf(conn.from);
        const toIndex = toSemesterCourses.indexOf(conn.to);

        // Get semester indices for proper numeric comparison
        const fromSemIdx = semesterIndexMap.get(fromSem);
        const toSemIdx = semesterIndexMap.get(toSem);

        // Return bounding box: min/max semester and min/max vertical position
        return {
            semMin: Math.min(fromSemIdx, toSemIdx),
            semMax: Math.max(fromSemIdx, toSemIdx),
            posMin: Math.min(fromIndex, toIndex),
            posMax: Math.max(fromIndex, toIndex),
            fromSem: fromSem,
            toSem: toSem,
            fromIndex: fromIndex,
            toIndex: toIndex
        };
    };

    // Helper: Check if two bounding boxes intersect or are very close
    const boundingBoxesConflict = (box1, box2) => {
        // No horizontal overlap means no conflict
        if (box1.semMax < box2.semMin || box2.semMax < box1.semMin) {
            return false;
        }

        // Same semester connections - only conflict if very close vertically
        if (box1.semMin === box1.semMax && box2.semMin === box2.semMax && box1.semMin === box2.semMin) {
            // Both are same-semester connections in the same semester
            return Math.abs(box1.fromIndex - box2.fromIndex) <= 2 || Math.abs(box1.toIndex - box2.toIndex) <= 2;
        }

        // Calculate overlap in semester space
        const semOverlapStart = Math.max(box1.semMin, box2.semMin);
        const semOverlapEnd = Math.min(box1.semMax, box2.semMax);

        // No semester overlap at all
        if (semOverlapEnd < semOverlapStart) {
            return false;
        }

        // Check vertical overlap - be more conservative
        // Only use tolerance of 1 to avoid over-detecting conflicts
        const expandedBox1Min = box1.posMin - 1;
        const expandedBox1Max = box1.posMax + 1;
        const expandedBox2Min = box2.posMin - 1;
        const expandedBox2Max = box2.posMax + 1;

        // Check if expanded boxes overlap
        const verticalOverlap = !(expandedBox1Max < expandedBox2Min || expandedBox2Max < expandedBox1Min);

        if (!verticalOverlap) return false;

        // Additional check: if lines cross (going in opposite vertical directions) in overlapping semesters
        const direction1 = box1.toIndex - box1.fromIndex; // positive = downward
        const direction2 = box2.toIndex - box2.fromIndex;

        // If they cross each other (opposite directions), that's a strong conflict indicator
        if (direction1 * direction2 < 0) { // Opposite signs
            // But only if they're in the same general area
            const overlap = Math.min(box1.posMax, box2.posMax) - Math.max(box1.posMin, box2.posMin);
            return overlap >= 0;
        }

        // For parallel paths (same direction), only conflict if they're very close
        const verticalDistance = Math.min(
            Math.abs(box1.posMin - box2.posMin),
            Math.abs(box1.posMax - box2.posMax),
            Math.abs(box1.posMin - box2.posMax),
            Math.abs(box1.posMax - box2.posMin)
        );

        return verticalDistance <= 1;
    };

    // PERFORMANCE OPTIMIZATION: Pre-compute all bounding boxes before conflict detection
    // Build a Map to cache bounding boxes for each connection to avoid recalculation in triple-nested loop
    const connectionBoundingBoxes = new Map();
    
    // Pre-compute bounding boxes for all connections in all courses
    Object.keys(connectionsByCourse).forEach(courseKey => {
        connectionsByCourse[courseKey].forEach(conn => {
            connectionBoundingBoxes.set(conn, getConnectionBoundingBox(conn));
        });
    });

    // Build conflict graph based on bounding box intersections
    for (let i = 0; i < courseKeys.length; i++) {
        const course1 = courseKeys[i];
        const conns1 = connectionsByCourse[course1];

        for (let j = i + 1; j < courseKeys.length; j++) {
            const course2 = courseKeys[j];
            const conns2 = connectionsByCourse[course2];

            // Check if any pair of connections from these courses conflict
            let hasConflict = false;
            for (const conn1 of conns1) {
                const box1 = connectionBoundingBoxes.get(conn1);

                for (const conn2 of conns2) {
                    const box2 = connectionBoundingBoxes.get(conn2);

                    if (boundingBoxesConflict(box1, box2)) {
                        hasConflict = true;
                        break;
                    }
                }
                if (hasConflict) break;
            }

            if (hasConflict) {
                conflicts[course1].add(course2);
                conflicts[course2].add(course1);
            }
        }
    }

    // Greedy graph coloring: assign minimum color that doesn't conflict
    // Use maximally distinct colors with good contrast on white background
    const colorPalette = [
        '#e6194b', // Vivid Red
        '#3cb44b', // Vivid Green
        '#4363d8', // Vivid Blue
        '#f58231', // Vivid Orange
        '#911eb4', // Vivid Purple
        '#008080', // Teal
        '#9a6324', // Brown
        '#800000', // Maroon
        '#808000', // Olive
        '#000075', // Navy
        '#ff6b6b', // Coral Red
        '#4ecdc4', // Turquoise
        '#00d2d3', // Aqua
        '#ff6348', // Tomato
        '#1dd1a1', // Seafoam
        '#d4a017', // Golden Yellow
        '#10ac84', // Emerald
        '#576574', // Gray
        '#ee5a6f', // Rose
        '#c44569', // Blush
        '#d68910', // Dark Gold
        '#2e86ab', // Ocean Blue
        '#a23b72', // Plum
        '#7209b7', // Deep Purple
        '#06a77d', // Jade
        '#d62828', // Crimson
        '#f77f00', // Pumpkin
        '#2a9d8f', // Persian Green
        '#e76f51', // Burnt Sienna
        '#6a4c93', // Royal Purple
        '#1982c4', // Blue NCS
        '#8ac926', // Android Green
        '#ff595e', // Red Salsa
        '#06aed5', // Blue Green
        '#dd1c1a', // Fire Engine Red
        '#023e8a', // USAFA Blue
        '#0077b6', // Blue Sapphire
        '#7209b7', // Purple X11
        '#9d0208', // Rosewood
        '#ba181b'  // Engineering Red
    ];

    // Sort courses by visual position: top-to-bottom, left-to-right (by semester, then by vertical position)
    const sortedCourses = courseKeys.sort((a, b) => {
        const semA = courseData[a].semester;
        const semB = courseData[b].semester;
        
        // First, sort by semester order (O(1) lookup with map instead of O(n) indexOf)
        const semIndexA = semesterIndexMap.get(semA);
        const semIndexB = semesterIndexMap.get(semB);
        
        if (semIndexA !== semIndexB) {
            return semIndexA - semIndexB;
        }
        
        // Within same semester, sort by vertical position (top to bottom)
        // Use pre-computed course lists instead of rebuilding
        const semesterCourses = courseListBySemester[semA];
        
        const indexA = semesterCourses.indexOf(a);
        const indexB = semesterCourses.indexOf(b);
        
        return indexA - indexB;
    });

    // Helper: Calculate color distance (perceptual difference)
    const hexToRgb = (hex) => {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    };

    const colorDistance = (color1, color2) => {
        const rgb1 = hexToRgb(color1);
        const rgb2 = hexToRgb(color2);
        if (!rgb1 || !rgb2) return 1000; // Large distance for invalid colors

        // Use weighted Euclidean distance (closer to perceptual difference)
        const rDiff = rgb1.r - rgb2.r;
        const gDiff = rgb1.g - rgb2.g;
        const bDiff = rgb1.b - rgb2.b;
        return Math.sqrt(2 * rDiff * rDiff + 4 * gDiff * gDiff + 3 * bDiff * bDiff);
    };

    // Helper: Check if color has sufficient contrast against white background
    const hasGoodContrast = (color) => {
        const rgb = hexToRgb(color);
        if (!rgb) return false;

        // Calculate relative luminance (WCAG formula)
        const rsRGB = rgb.r / 255;
        const gsRGB = rgb.g / 255;
        const bsRGB = rgb.b / 255;

        const r = rsRGB <= 0.03928 ? rsRGB / 12.92 : Math.pow((rsRGB + 0.055) / 1.055, 2.4);
        const g = gsRGB <= 0.03928 ? gsRGB / 12.92 : Math.pow((gsRGB + 0.055) / 1.055, 2.4);
        const b = bsRGB <= 0.03928 ? bsRGB / 12.92 : Math.pow((bsRGB + 0.055) / 1.055, 2.4);

        const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;

        // White has luminance of 1.0
        // Contrast ratio = (lighter + 0.05) / (darker + 0.05)
        const contrastRatio = (1.0 + 0.05) / (luminance + 0.05);

        // Require contrast ratio of at least 3:1 for good visibility
        return contrastRatio >= 3.0;
    };

    // Assign colors with gap-awareness: ensure no duplicate colors in same gap
    const numColors = 10;
    
    // First, assign initial colors sequentially
    sortedCourses.forEach((courseKey, index) => {
        courseColors[courseKey] = getCourseColor(courseKey, index);
    });
    
    // Now check each gap and reassign colors if there are conflicts
    // Build a map of which courses appear in each gap
    const coursesPerGap = {}; // gapKey -> Set of courseKeys
    
    sortedCourses.forEach(courseKey => {
        const conns = connectionsByCourse[courseKey];
        if (!conns) return;
        
        conns.forEach(conn => {
            const fromSem = courseData[conn.from].semester;
            const toSem = courseData[conn.to].semester;
            const fromSemIdx = semesterIndexMap.get(fromSem);
            const toSemIdx = semesterIndexMap.get(toSem);
            
            // Track all gaps this connection crosses
            for (let semIdx = fromSemIdx; semIdx < toSemIdx; semIdx++) {
                const currentSem = semesterOrder[semIdx];
                const nextSem = semesterOrder[semIdx + 1];
                const gapKey = `${currentSem}|${nextSem}`;
                
                if (!coursesPerGap[gapKey]) {
                    coursesPerGap[gapKey] = new Set();
                }
                coursesPerGap[gapKey].add(courseKey);
            }
        });
    });
    
    // For each gap, check for color conflicts and reassign if needed
    Object.keys(coursesPerGap).forEach(gapKey => {
        const coursesInGap = Array.from(coursesPerGap[gapKey]);
        const usedColors = new Set();
        const conflicts = [];
        
        // Find conflicts
        coursesInGap.forEach(courseKey => {
            const color = courseColors[courseKey];
            if (usedColors.has(color)) {
                conflicts.push(courseKey);
            } else {
                usedColors.add(color);
            }
        });
        
        // Reassign colors for conflicting courses
        conflicts.forEach(courseKey => {
            // Find a color not used in this gap
            for (let i = 0; i < numColors; i++) {
                const candidateColor = getCourseColor(courseKey, i);
                if (!usedColors.has(candidateColor)) {
                    courseColors[courseKey] = candidateColor;
                    usedColors.add(candidateColor);
                    break;
                }
            }
        });
    });

    // Global tracking: which course owns which lane in each gap
    // Format: globalVerticalLanes[courseKey][gapKey] = lane object
    const globalVerticalLanes = {};
    // Format: globalHorizontalLanes[courseKey][semester] = lane object
    const globalHorizontalLanes = {};

    // Initialize tracking for all courses
    Object.keys(connectionsByCourse).forEach(fromCourseKey => {
        globalVerticalLanes[fromCourseKey] = {};
        globalHorizontalLanes[fromCourseKey] = {};
    });

    // Route connections course by course
    Object.keys(connectionsByCourse).forEach(fromCourseKey => {
        const courseConnections = connectionsByCourse[fromCourseKey];
        const fromRecord = courseRecords[fromCourseKey];

        if (!fromRecord || !fromRecord.rightStubs[0]) return;

        const outputStub = fromRecord.rightStubs[0];

        // Get the color for this course (all its lines will be this color)
        const courseColor = courseColors[fromCourseKey];

        // Sort connections by priority for stub assignment
        // Priority: same semester (top down) > earlier semesters (earliest first, top down) > later semesters (top down)
        const fromSemIdx = semesterIndexMap.get(fromRecord.semester);

        const sortedConnections = [...courseConnections].sort((connA, connB) => {
            const toSemIdxA = semesterIndexMap.get(connA.toRecord.semester);
            const toSemIdxB = semesterIndexMap.get(connB.toRecord.semester);

            const isSameSemA = toSemIdxA === fromSemIdx;
            const isSameSemB = toSemIdxB === fromSemIdx;
            const isEarlierA = toSemIdxA < fromSemIdx;
            const isEarlierB = toSemIdxB < fromSemIdx;

            // NEW PRIORITY ORDER:
            // 1. Cross-semester connections (non-adjacent) - highest priority
            // 2. Same semester connections (adjacent)
            // 3. Within each group, by position

            // Cross-semester (not same semester) gets priority
            if (!isSameSemA && isSameSemB) return -1;  // A is cross-semester, B is same
            if (isSameSemA && !isSameSemB) return 1;   // B is cross-semester, A is same

            // If both same semester, sort by position in semester (higher courses first)
            if (isSameSemA && isSameSemB) {
                return connA.toRecord.rect.top - connB.toRecord.rect.top;
            }

            // If both cross-semester, earlier semesters get priority
            if (!isSameSemA && !isSameSemB) {
                // Earlier semester connections first
                if (isEarlierA && !isEarlierB) return -1;
                if (!isEarlierA && isEarlierB) return 1;
                
                // If both earlier or both later, sort by semester distance
                if (toSemIdxA !== toSemIdxB) return toSemIdxA - toSemIdxB;
                
                // Same semester, sort by position
                return connA.toRecord.rect.top - connB.toRecord.rect.top;
            }

            // Fallback
            return connA.toRecord.rect.top - connB.toRecord.rect.top;
        });

        // Now route each connection from this course (in priority order)
        sortedConnections.forEach(conn => {
            const toRecord = conn.toRecord;

            const availableInputStubs = toRecord.leftStubs.filter(s => !s.used);
            if (availableInputStubs.length === 0) return;

            // Prioritize input stubs based on connection type
            // 2. Adjacent same semester (highest stub)
            // 3. Adjacent same semester (lower stubs)

            const fromSemester = fromRecord.semester;
            const toSemester = toRecord.semester;
            const fromSemIdx = semesterIndexMap.get(fromSemester);
            const toSemIdx = semesterIndexMap.get(toSemester);
            const isSameSemester = fromSemIdx === toSemIdx;

            // Sort available input stubs based on priority
            availableInputStubs.sort((a, b) => {
                if (!isSameSemester) {
                    // Cross-semester connection
                    // Priority 1: Highest cross semester output gets highest stub (lowest Y value)
                    // Simply assign top to bottom for cross-semester
                    return a.y - b.y;
                } else {
                    // Same semester (adjacent) connection
                    // Priority 2: Highest stub first (lowest Y)
                    // Priority 3: Then lower stubs (higher Y)
                    return a.y - b.y;
                }
            });

            const inputStub = availableInputStubs[0];
            inputStub.used = true;
            inputStub.fromCourse = conn.from;

            // Determine if connection crosses semesters
            const sameSemester = conn.fromRecord.semester === conn.toRecord.semester;

            if (sameSemester) {
                // Same-semester connection - use vertical lanes and horizontal lane routing
                const currentSemester = conn.fromRecord.semester;

                // Determine if going down (use bottom->top stubs) or up (use top->bottom stubs)
                const fromRect = conn.fromRecord.rect;
                const toRect = conn.toRecord.rect;
                const goingDown = fromRect.centerY < toRect.centerY;

                // Allocate a single vertical lane for this connection
                // All connections from the same source course share the same vertical lane
                // Both source and target use the same X position for their vertical segments

                // Track vertical lanes per SOURCE COURSE in this semester
                if (!window.sameSemesterVerticalLanesByCourse) {
                    window.sameSemesterVerticalLanesByCourse = {};
                }
                if (!window.sameSemesterVerticalLanesBySemester) {
                    window.sameSemesterVerticalLanesBySemester = {};
                }
                if (!window.sameSemesterVerticalLanesBySemester[currentSemester]) {
                    window.sameSemesterVerticalLanesBySemester[currentSemester] = [];
                }

                // Check if this source course already has a vertical lane assigned
                const courseKey = `${currentSemester}:${conn.from}`;
                let sharedX;

                if (window.sameSemesterVerticalLanesByCourse[courseKey]) {
                    // Reuse existing lane for this source course
                    sharedX = window.sameSemesterVerticalLanesByCourse[courseKey];
                } else {
                    // Allocate a new lane for this source course
                    const semesterLeft = semesterPositions[currentSemester].left;
                    const semesterRight = semesterPositions[currentSemester].right;
                    const semesterWidth = semesterRight - semesterLeft;
                    const semesterCenterX = (semesterLeft + semesterRight) / 2;

                    const existingLanes = window.sameSemesterVerticalLanesBySemester[currentSemester].length;
                    const laneSpacing = semesterWidth / 10; // Space lanes across semester width

                    // Start from center and alternate left/right for each new lane
                    if (existingLanes === 0) {
                        sharedX = semesterCenterX; // First lane at center of semester
                    } else if (existingLanes % 2 === 1) {
                        // Odd number of lanes: place to the right
                        sharedX = semesterCenterX + laneSpacing * Math.ceil(existingLanes / 2);
                    } else {
                        // Even number of lanes: place to the left
                        sharedX = semesterCenterX - laneSpacing * (existingLanes / 2);
                    }

                    // Track this lane globally for the semester
                    window.sameSemesterVerticalLanesBySemester[currentSemester].push({
                        x: sharedX,
                        reserved: true,
                        forCourse: conn.from,
                        minY: Math.min(fromRect.centerY, toRect.centerY),
                        maxY: Math.max(fromRect.centerY, toRect.centerY)
                    });

                    // Store the lane X position for this source course
                    window.sameSemesterVerticalLanesByCourse[courseKey] = sharedX;
                }

                // Create stub positions using the shared vertical lane X position
                let startStub, endStub;
                if (goingDown) {
                    // Going down: use bottom of source, top of target
                    startStub = { x: sharedX, y: fromRect.bottom };
                    endStub = { x: sharedX, y: toRect.top };
                } else {
                    // Going up: use top of source, bottom of target
                    startStub = { x: sharedX, y: fromRect.top };
                    endStub = { x: sharedX, y: toRect.bottom };
                }

                // Find appropriate horizontal lane between the two courses
                // IMPORTANT: Each connection needs its own lane to avoid overlaps
                let horizLane = null;
                const semesterLanes = horizontalLanesBySemester[currentSemester];
                if (semesterLanes && semesterLanes.length > 0) {
                    const minY = Math.min(startStub.y, endStub.y);
                    const maxY = Math.max(startStub.y, endStub.y);
                    const minX = Math.min(startStub.x, endStub.x);
                    const maxX = Math.max(startStub.x, endStub.x);

                    // Filter lanes that are ONLY between the two courses
                    // Do NOT use the top lane for same-semester connections
                    const lanesBetween = semesterLanes.filter(lane =>
                        !lane.isAboveAll && lane.y > minY && lane.y < maxY
                    );

                    if (lanesBetween.length > 0) {
                        // Sort lanes by preference (primary first)
                        const prioritizedLanes = lanesBetween.sort((a, b) => {
                            if (a.isPrimary && !b.isPrimary) return -1;
                            if (!a.isPrimary && b.isPrimary) return 1;
                            return 0;
                        });

                        // Find first available lane (checking for conflicts)
                        for (const lane of prioritizedLanes) {
                            if (isHorizontalLaneAvailable(lane, minX, maxX)) {
                                horizLane = lane;
                                break;
                            }
                        }

                        // If no available lane in between, try closest available
                        if (!horizLane) {
                            horizLane = findClosestAvailableHorizontalLane(
                                currentSemester,
                                minX,
                                maxX,
                                (startStub.y + endStub.y) / 2
                            );
                        }
                    } else {
                        // No lanes between - use closest available lane
                        horizLane = findClosestAvailableHorizontalLane(
                            currentSemester,
                            minX,
                            maxX,
                            (startStub.y + endStub.y) / 2
                        );
                    }

                    if (horizLane) {
                        // Reserve this lane for this specific connection
                        reserveHorizontalLane(horizLane, minX, maxX, `${fromCourseKey}->${conn.to}`);
                    }
                }

                if (horizLane) {
                    // Route through horizontal lane using top/bottom stubs:
                    // start stub -> horizontal lane -> end stub
                    const path = `M ${startStub.x} ${startStub.y} L ${startStub.x} ${horizLane.y} L ${endStub.x} ${horizLane.y} L ${endStub.x} ${endStub.y}`;
                    const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    pathEl.setAttribute('d', path);
                    pathEl.setAttribute('stroke', courseColor);
                    pathEl.setAttribute('stroke-width', '2');
                    pathEl.setAttribute('fill', 'none');
                    pathEl.setAttribute('opacity', '0.6'); // Slightly transparent since it goes behind boxes
                    pathEl.style.zIndex = '1'; // Behind boxes (boxes are z-index 10+)
                    // Apply dashed line for corequisites, solid for prerequisites
                    if (conn.type === 'coreq') {
                        pathEl.setAttribute('stroke-dasharray', '3 2'); // 3px dash, 2px gap
                    }
                    svg.appendChild(pathEl);

                    // Add visual indicators where the line enters/exits the boxes
                    // Entry indicator (filled circle) at start stub
                    const entryIndicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    entryIndicator.setAttribute('cx', startStub.x);
                    entryIndicator.setAttribute('cy', startStub.y);
                    entryIndicator.setAttribute('r', '4');
                    entryIndicator.setAttribute('fill', courseColor);
                    entryIndicator.style.zIndex = '100'; // Above everything
                    svg.appendChild(entryIndicator);

                    // Exit indicator (triangle/arrow) at end stub to show direction
                    const exitIndicator = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    const arrowSize = 5;
                    // Create arrow pointing in the direction of connection (toward the box)
                    let points;
                    if (goingDown) {
                        // Arrow pointing down (into top of box)
                        points = `${endStub.x},${endStub.y} ${endStub.x - arrowSize},${endStub.y - arrowSize * 1.5} ${endStub.x + arrowSize},${endStub.y - arrowSize * 1.5}`;
                    } else {
                        // Arrow pointing up (into bottom of box)
                        points = `${endStub.x},${endStub.y} ${endStub.x - arrowSize},${endStub.y + arrowSize * 1.5} ${endStub.x + arrowSize},${endStub.y + arrowSize * 1.5}`;
                    }
                    exitIndicator.setAttribute('points', points);
                    exitIndicator.setAttribute('fill', courseColor);
                    exitIndicator.style.zIndex = '100';
                    svg.appendChild(exitIndicator);
                } else {
                    const path = `M ${startStub.x} ${startStub.y} L ${endStub.x} ${endStub.y}`;
                    const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    pathEl.setAttribute('d', path);
                    pathEl.setAttribute('stroke', courseColor);
                    pathEl.setAttribute('stroke-width', '2');
                    pathEl.setAttribute('fill', 'none');
                    // Apply dashed line for corequisites, solid for prerequisites
                    if (conn.type === 'coreq') {
                        pathEl.setAttribute('stroke-dasharray', '3 2');
                    }
                    svg.appendChild(pathEl);
                }
            } else {
                // Multi-semester routing
                const fromSemIdx = semesterOrder.indexOf(conn.fromRecord.semester);
                const toSemIdx = semesterOrder.indexOf(conn.toRecord.semester);
                const semesterJump = toSemIdx - fromSemIdx;

                if (semesterJump === 1) {
                    // Adjacent semester - get or allocate vertical lane for this gap
                    const gapKey = `${semesterOrder[fromSemIdx]}|${semesterOrder[fromSemIdx + 1]}`;
                    const gap = semesterGaps[gapKey];

                    // Check if we already have a lane assigned for this source course in this gap. Same source MUST use same lane
                    let selectedLane = globalVerticalLanes[fromCourseKey][gapKey];

                    if (!selectedLane) {
                        // First connection from this source: find available lane for Y-range. Adjacent connections prefer early/inner lanes
                        selectedLane = findAvailableLaneForRange(gap, outputStub.y, inputStub.y, outputStub.y, inputStub.y, true, fromCourseKey, conn.to, true);

                        if (!selectedLane) return;

                        globalVerticalLanes[fromCourseKey][gapKey] = selectedLane;
                    }

                    // Reserve the lane for THIS connection's Y-range
                    // Include horizontal segment positions (start at outputStub.y, end at inputStub.y)
                    reserveVerticalLane(selectedLane, outputStub.y, inputStub.y, fromCourseKey, outputStub.y, inputStub.y, conn.to, true);

                    const path = `M ${outputStub.x} ${outputStub.y} L ${selectedLane.x} ${outputStub.y} L ${selectedLane.x} ${inputStub.y} L ${inputStub.x} ${inputStub.y}`;
                    const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    pathEl.setAttribute('d', path);
                    pathEl.setAttribute('stroke', courseColor);
                    pathEl.setAttribute('stroke-width', '2');
                    pathEl.setAttribute('fill', 'none');
                    // Apply dashed line for corequisites, solid for prerequisites
                    if (conn.type === 'coreq') {
                        pathEl.setAttribute('stroke-dasharray', '3 2');
                    }
                    svg.appendChild(pathEl);

                    // Add visual indicators at entry and exit points
                    // Entry indicator (filled circle) at output stub
                    const entryIndicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    entryIndicator.setAttribute('cx', outputStub.x);
                    entryIndicator.setAttribute('cy', outputStub.y);
                    entryIndicator.setAttribute('r', '4');
                    entryIndicator.setAttribute('fill', courseColor);
                    svg.appendChild(entryIndicator);

                    // Exit indicator (triangle/arrow) at input stub pointing right (into left side of box)
                    const exitIndicator = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    const arrowSize = 5;
                    // Arrow pointing right (into the input stub from the left)
                    const points = `${inputStub.x},${inputStub.y} ${inputStub.x - arrowSize * 1.5},${inputStub.y - arrowSize} ${inputStub.x - arrowSize * 1.5},${inputStub.y + arrowSize}`;
                    exitIndicator.setAttribute('points', points);
                    exitIndicator.setAttribute('fill', courseColor);
                    svg.appendChild(exitIndicator);
                } else {
                    // Multi-semester jump - allocate lanes per gap
                    const pathSegments = [];
                    let currentX = outputStub.x;
                    let currentY = outputStub.y;
                    let selectedHorizontalY = null; // Track the Y position once a horizontal lane is chosen

                    pathSegments.push(`M ${currentX} ${currentY}`);

                    // For each gap this connection crosses
                    for (let semIdx = fromSemIdx; semIdx < toSemIdx; semIdx++) {
                        const currentSem = semesterOrder[semIdx];
                        const nextSem = semesterOrder[semIdx + 1];
                        const gapKey = `${currentSem}|${nextSem}`;
                        const gap = semesterGaps[gapKey];

                        if (!gap) continue;

                        const isLastGap = (semIdx === toSemIdx - 1);
                        const isFirstGap = (semIdx === fromSemIdx);

                        // For non-last gaps, determine the horizontal lane FIRST so we know the target Y
                        let horizLane = null;
                        let targetY = currentY;

                        if (!isLastGap) {
                            // Need to determine horizontal lane before allocating vertical lane
                            const nextSemester = nextSem;
                            horizLane = globalHorizontalLanes[fromCourseKey][nextSemester];

                            if (!horizLane) {
                                // First connection through this semester - allocate horizontal lane
                                const fromSemesterBounds = semesterPositions[fromRecord.semester];
                                // Check if the course box itself is in the upper half of the semester
                                const isInUpperHalf = fromSemesterBounds &&
                                    fromRecord.rect.top < (fromSemesterBounds.top + fromSemesterBounds.bottom) / 2;

                                // Determine target Y for lane selection
                                let laneTargetY;
                                let shouldPreferTopLane;
                                
                                if (isFirstGap) {
                                    // First gap: use output stub position
                                    laneTargetY = currentY;
                                    
                                    // Only prefer top lane if this is the topmost course in its semester
                                    const fromSemesterBounds = semesterPositions[fromRecord.semester];
                                    const coursesInSemester = visibleCourses.filter(k => courseRecords[k].semester === fromRecord.semester);
                                    const sortedCourses = coursesInSemester
                                        .map(k => ({ key: k, top: courseRecords[k].rect.top }))
                                        .sort((a, b) => a.top - b.top);
                                    const isTopCourse = sortedCourses.length > 0 && sortedCourses[0].key === fromCourseKey;
                                    
                                    shouldPreferTopLane = isTopCourse;
                                } else if (selectedHorizontalY !== null) {
                                    laneTargetY = selectedHorizontalY;
                                    shouldPreferTopLane = false;
                                } else {
                                    laneTargetY = currentY;
                                    shouldPreferTopLane = false;
                                }

                                horizLane = findClosestAvailableHorizontalLane(
                                    nextSemester,
                                    semesterPositions[nextSemester]?.left || 0,
                                    semesterPositions[semesterOrder[semIdx + 2]]?.right || 1000,
                                    laneTargetY,
                                    shouldPreferTopLane,
                                    fromCourseKey
                                );

                                if (!horizLane) {
                                    return;
                                }

                                globalHorizontalLanes[fromCourseKey][nextSemester] = horizLane;
                                reserveHorizontalLane(horizLane, currentX, semesterPositions[semesterOrder[semIdx + 2]]?.left || 1000, fromCourseKey);
                                
                                // Remember this Y position for subsequent gaps (only set once in first gap)
                                if (isFirstGap) {
                                    selectedHorizontalY = horizLane.y;
                                }
                            } else {
                                // Lane already exists for this semester - but make sure we update selectedHorizontalY if not set
                                if (isFirstGap && selectedHorizontalY === null) {
                                    selectedHorizontalY = horizLane.y;
                                }
                            }

                            targetY = horizLane.y; // Use horizontal lane Y as target
                        } else {
                            targetY = inputStub.y; // Last gap goes to input stub
                        }

                        // Now allocate vertical lane knowing the correct target Y
                        // Get or allocate vertical lane for this source course in this gap
                        // Same source MUST use same lane
                        let verticalLane = globalVerticalLanes[fromCourseKey][gapKey];

                        if (!verticalLane) {
                            // First connection from this source course through this gap
                            // For multi-semester, we need to reserve space considering horizontal segments
                            // startY: where horizontal segment enters the vertical lane (currentY)
                            // endY: where horizontal segment exits the vertical lane (targetY)
                            verticalLane = findAvailableLaneForRange(gap, currentY, targetY, currentY, targetY, false, fromCourseKey, conn.to, false);

                            if (!verticalLane) return;

                            globalVerticalLanes[fromCourseKey][gapKey] = verticalLane;
                        }

                        // Move horizontally to the vertical lane
                        pathSegments.push(`L ${verticalLane.x} ${currentY}`);
                        currentX = verticalLane.x;

                        // Determine where to go next (using isLastGap and horizLane already calculated above)

                        if (isLastGap) {
                            // Last gap - go directly to destination
                            // Horizontal segment enters at currentY, exits at inputStub.y
                            reserveVerticalLane(verticalLane, currentY, inputStub.y, fromCourseKey, currentY, inputStub.y, conn.to, false);
                            pathSegments.push(`L ${currentX} ${inputStub.y}`);
                            currentY = inputStub.y;
                        } else {
                            // Not last gap - use horizontal lane allocated above. Reserve vertical lane and drop/rise to horizontal lane
                            reserveVerticalLane(verticalLane, currentY, horizLane.y, fromCourseKey, currentY, horizLane.y, conn.to, false);

                            // Drop/rise to horizontal lane
                            pathSegments.push(`L ${currentX} ${horizLane.y}`);
                            currentY = horizLane.y;
                        }
                    }

                    // Final horizontal segment to input stub
                    pathSegments.push(`L ${inputStub.x} ${inputStub.y}`);

                    const path = pathSegments.join(' ');
                    const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    pathEl.setAttribute('d', path);
                    pathEl.setAttribute('stroke', courseColor);
                    pathEl.setAttribute('stroke-width', '2');
                    pathEl.setAttribute('fill', 'none');
                    // Apply dashed line for corequisites, solid for prerequisites
                    if (conn.type === 'coreq') {
                        pathEl.setAttribute('stroke-dasharray', '3 2');
                    }
                    svg.appendChild(pathEl);

                    // Add visual indicators at entry and exit points
                    // Entry indicator (filled circle) at output stub
                    const entryIndicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    entryIndicator.setAttribute('cx', outputStub.x);
                    entryIndicator.setAttribute('cy', outputStub.y);
                    entryIndicator.setAttribute('r', '4');
                    entryIndicator.setAttribute('fill', courseColor);
                    svg.appendChild(entryIndicator);

                    // Exit indicator (triangle/arrow) at input stub pointing right (into left side of box)
                    const exitIndicator = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    const arrowSize = 5;
                    // Arrow pointing right (into the input stub from the left)
                    const points = `${inputStub.x},${inputStub.y} ${inputStub.x - arrowSize * 1.5},${inputStub.y - arrowSize} ${inputStub.x - arrowSize * 1.5},${inputStub.y + arrowSize}`;
                    exitIndicator.setAttribute('points', points);
                    exitIndicator.setAttribute('fill', courseColor);
                    svg.appendChild(exitIndicator);
                }
            }
        });
    });


    // Analyze connection types
    let sameSemesterCount = 0;
    let adjacentSemesterCount = 0;
    let multiSemesterCount = 0;

    connections.forEach(conn => {
        const fromIdx = semesterOrder.indexOf(conn.fromRecord.semester);
        const toIdx = semesterOrder.indexOf(conn.toRecord.semester);
        const jump = toIdx - fromIdx;

        if (jump === 0) sameSemesterCount++;
        else if (jump === 1) adjacentSemesterCount++;
        else if (jump > 1) multiSemesterCount++;
    });


}


        window.highlightRelatedCourses = function(courseKey) {
            try {
                window.clearHighlights();

                const course = courseData[courseKey];
                const leadsTo = leadsToMap[courseKey];

                if (!course || !leadsTo) return;

            // Combine highlighting and drawing in a single requestAnimationFrame
            requestAnimationFrame(() => {
                    try {
                        // Highlight the selected course
                        highlightSelectedCourse(courseKey);

                        // Dim all other courses
                        dimOtherCourses(courseKey);

                        // Highlight prerequisites
                        highlightPrerequisites(course.prereqs);

                        // Highlight corequisites
                        highlightCorequisites(course.coreqs);

                        // Sort courses by position (now in same frame)
                        const prereqsSorted = sortCoursesByPosition(course.prereqs);
                        const coreqsSorted = sortCoursesByPosition(course.coreqs);

                        // Combine leads-to arrays once and reuse
                        const allLeadsToKeys = [...leadsTo.asPrereq, ...leadsTo.asCoreq];
                        const leadsToSorted = sortCoursesByPosition(allLeadsToKeys);

                        // Highlight courses this leads to (filter out duplicates)
                        const allLeadsTo = allLeadsToKeys.filter(
                            key => !course.coreqs.includes(key)
                        );
                        highlightLeadsTo(allLeadsTo);

                        // Calculate connection counts
                        const { destConnectionCounts, srcConnectionCounts } = calculateConnectionCounts(
                            courseKey,
                            prereqsSorted,
                            coreqsSorted,
                            leadsToSorted
                        );

                        window.destTotalConnections = destConnectionCounts;
                        window.srcTotalConnections = srcConnectionCounts;

                        // Draw all connection lines
                        drawAllConnections(
                            courseKey,
                            course,
                            prereqsSorted,
                            coreqsSorted,
                            leadsToSorted,
                            destConnectionCounts,
                            srcConnectionCounts
                        );

                        // Announce the selection
                        announceSelection(courseKey, course, leadsToSorted);

                        // Update SVG size
                        updateSVGSize();

            // Draw all connections automatically on load (static version)
            setTimeout(() => {
                drawAllConnections();
            }, 100);
                    } catch (error) {
                        console.error('Error highlighting and drawing connections:', error);
                    }
                });

                selectedCourseKey = courseKey;
            } catch (error) {
                console.error('Error in highlightRelatedCourses:', error);
                // Clean up on error
                window.clearHighlights();
            }
        };
        
        function announceSelection(courseKey, course, leadsTo) {
            const announcer = domCache.announcements;
            if (!announcer) return;
            
            const courseInfo = courseData[courseKey];
            if (!courseInfo) return;
            
            const prereqCount = course.prereqs.length;
            const coreqCount = course.coreqs.length;
            const leadsToCount = leadsTo.length;
            
            let message = `${courseInfo.code} ${courseInfo.name} selected. `;
            
            if (prereqCount === 0 && coreqCount === 0 && leadsToCount === 0) {
                message += 'This course has no prerequisites, co-requisites, or courses it leads to.';
            } else {
                const parts = [];
                
                if (prereqCount > 0) {
                    const prereqNames = course.prereqs.map(p => courseData[p]?.code || p).join(', ');
                    parts.push(`${prereqCount} prerequisite${prereqCount > 1 ? 's' : ''}: ${prereqNames}`);
                }
                
                if (coreqCount > 0) {
                    const coreqNames = course.coreqs.map(c => courseData[c]?.code || c).join(', ');
                    parts.push(`${coreqCount} co-requisite${coreqCount > 1 ? 's' : ''}: ${coreqNames}`);
                }
                
                if (leadsToCount > 0) {
                    const leadsToNames = leadsTo.map(l => courseData[l]?.code || l).join(', ');
                    parts.push(`leads to ${leadsToCount} course${leadsToCount > 1 ? 's' : ''}: ${leadsToNames}`);
                }
                
                message += parts.join('. ') + '.';
            }
            
            announcer.textContent = message;
        }
        
        // Store event handlers for cleanup
        const eventHandlers = new WeakMap();

        function buildFlowchart(isProgramSwitch = false) {
            const container = domCache.flowchartContainer;
            if (!container) return;
            
            const courseBySemester = {};
            semesterOrder.forEach(sem => courseBySemester[sem] = []);
            
            Object.entries(courseData).forEach(([key, course]) => {
                courseBySemester[course.semester].push({key, ...course});
            });

            // Sort priority map for efficient course ordering
            const sortPriorityPrefixes = [
                ['CHE-', 1],
                ['BIOENG-', 1],
                ['ELEC-CHE', 2],
                ['ELEC-BIOENG', 2],
                ['ENGR-', 3],
                ['EE-', 3],  // Electrical Engineering
                ['CE-', 3],  // Civil Engineering
                ['ELEC-TECH', 4],
                ['CHEM-', 5],
                ['MBIOS-', 5],  // Treat MBIOS like chemistry
                ['MATH-', 6],
                ['PHYS-', 7],
                ['BIOLOGY-', 8],
                ['ENGL-', 9],
                ['HIST-', 10],
                ['ECONS-', 11],
                ['ELEC-', 12],
                ['STAT-', 13]
            ];

            function getSortPriority(courseCode) {
                for (const [prefix, priority] of sortPriorityPrefixes) {
                    if (courseCode.startsWith(prefix)) {
                        return priority;
                    }
                }
                return 14;  // Default priority
            }
            
            semesterOrder.forEach(semester => {
                courseBySemester[semester].sort((a, b) => {
                    const priorityA = getSortPriority(a.key);
                    const priorityB = getSortPriority(b.key);
                    if (priorityA !== priorityB) {
                        return priorityA - priorityB;
                    }
                    return a.key.localeCompare(b.key);
                });
            });
            
            semesterOrder.forEach(semester => {
                const column = document.createElement('div');
                column.className = 'semester-column';

                // Calculate total credits for this semester
                const totalCredits = courseBySemester[semester].reduce((sum, course) => sum + course.credits, 0);

                const header = document.createElement('div');
                header.className = 'semester-header';
                const parts = semester.split(' ');
                header.innerHTML = `${parts[0]} ${parts[1]}<br>${parts[2]}<br><span class="credits">${totalCredits} Credits</span>`;
                column.appendChild(header);

                courseBySemester[semester].forEach(course => {
                    const courseDiv = document.createElement('div');
                    courseDiv.className = `course ${course.type}`;
                    // Removed tabindex to disable keyboard focus/interaction
                    courseDiv.setAttribute('data-course-key', course.key);
                    
                    const prereqText = course.prereqs.length > 0
                        ? `Prereq: ${course.prereqs.map(p => courseData[p]?.code || p).join(', ')}`
                        : '';

                    const coreqText = course.coreqs.length > 0
                        ? `Coreq: ${course.coreqs.map(c => courseData[c]?.code || c).join(', ')}`
                        : '';

                    const alternativesText = course.alternatives && course.alternatives.length > 0
                        ? ` Has ${course.alternatives.length} alternative course${course.alternatives.length > 1 ? 's' : ''}, press A to view.`
                        : '';

                    const semesterRestrictionText = course.semesterRestriction
                        ? ` Only offered in ${course.semesterRestriction}.`
                        : '';

                    const ariaLabel = `${course.code}, ${course.credits} credits.${semesterRestrictionText} ${prereqText}${coreqText}${alternativesText}`;
                    courseDiv.setAttribute('aria-label', ariaLabel);

                    // Build tooltip text for hover
                    let tooltipText = `${course.code} - ${course.name}\n${course.credits} credits`;
                    if (semesterRestrictionText) {
                        tooltipText += `\n${semesterRestrictionText}`;
                    }
                    if (prereqText) {
                        tooltipText += `\n${prereqText}`;
                    }
                    if (coreqText) {
                        tooltipText += `\n${coreqText.trim()}`;
                    }
                    courseDiv.setAttribute('title', tooltipText);

                    courseDiv.innerHTML = `
                        <span class="course-code">${course.code}</span>
                        <span class="course-name">${course.shortName || course.name}</span>
                        <span class="course-credits">${course.credits} cr</span>
                    `;
                    
                    if (course.notes && course.notes.trim() !== '') {
                        const notesIndicator = document.createElement('div');
                        notesIndicator.className = 'notes-indicator';
                        notesIndicator.textContent = 'i';
                        notesIndicator.setAttribute('aria-label', `Note: ${course.notes}`);
                        notesIndicator.setAttribute('title', course.notes);

                        courseDiv.appendChild(notesIndicator);
                        courseDiv.setAttribute('data-has-notes', 'true');
                    }

                    if (course.semesterRestriction) {
                        const restrictionBadge = document.createElement('div');
                        const semester = course.semesterRestriction.toLowerCase();
                        restrictionBadge.className = `semester-restriction-badge ${semester}`;

                        // Display text: "F" for Fall, "Sp" for Spring, "Su" for Summer
                        let displayText = course.semesterRestriction;
                        if (course.semesterRestriction === 'Fall') {
                            displayText = 'F';
                        } else if (course.semesterRestriction === 'Spring') {
                            displayText = 'Sp';
                        } else if (course.semesterRestriction === 'Summer') {
                            displayText = 'Su';
                        }

                        restrictionBadge.textContent = displayText;
                        restrictionBadge.setAttribute('aria-hidden', 'true');
                        restrictionBadge.setAttribute('aria-label', `Only offered in ${course.semesterRestriction}`);
                        restrictionBadge.setAttribute('title', `Only offered in ${course.semesterRestriction}`);

                        courseDiv.appendChild(restrictionBadge);
                    }

                    if (course.alternatives && course.alternatives.length > 0) {
                        const alternativesIndicator = document.createElement('div');
                        alternativesIndicator.className = 'alternatives-indicator';
                        alternativesIndicator.textContent = 'OR';
                        alternativesIndicator.setAttribute('aria-hidden', 'true');
                        alternativesIndicator.setAttribute('aria-label', `Alternative: ${course.alternatives.join(', ')}`);
                        alternativesIndicator.setAttribute('title', `Alternative: ${course.alternatives.join(', ')}`);

                        // STATIC VERSION: Alternatives clicks disabled
                        // alternativesIndicator.addEventListener('click', (e) => {
                        // e.stopPropagation();

                            // Check if clicking the same indicator to toggle off
                        // const tooltip = domCache.alternativesTooltip;
                        // if (tooltip && tooltip.classList.contains('visible') && currentAlternativesIndicator === alternativesIndicator) {
                        // closeAlternativesTooltip();
                        // return;
                        // }

                        // const rect = courseDiv.getBoundingClientRect();
                        // const syntheticEvent = {
                        // clientX: rect.left + rect.width / 2,
                        // clientY: rect.bottom,
                        // stopPropagation: () => {}
                        // };
                        // showAlternativesTooltip(course.key, syntheticEvent, alternativesIndicator);
                        // });

                        courseDiv.appendChild(alternativesIndicator);
                        courseDiv.setAttribute('data-has-alternatives', 'true');
                    }
                    
                    // STATIC VERSION: Course clicks disabled
                    // courseDiv.addEventListener('click', (e) => {
                        // Close any open tooltips first
                    // const notesTooltip = domCache.notesTooltip;
                    // const alternativesTooltip = domCache.alternativesTooltip;

                    // if (!e.target.closest('.notes-indicator')) {
                    // if (notesTooltip && notesTooltip.classList.contains('visible')) {
                    // closeNotesTooltip();
                    // }
                    // }

                    // if (!e.target.closest('.alternatives-indicator')) {
                    // if (alternativesTooltip && alternativesTooltip.classList.contains('visible')) {
                    // closeAlternativesTooltip();
                    // }
                    // }

                    // e.stopPropagation();
                    // if (selectedCourseKey === course.key) {
                    // window.clearHighlights();
                    // } else {
                    // window.highlightRelatedCourses(course.key);
                    // }
                    // });
                    
                    // STATIC VERSION: Course keydown disabled
                    // courseDiv.addEventListener('keydown', (e) => {
                    // if (e.key === 'Enter' || e.key === ' ') {
                    // e.preventDefault();
                    // if (selectedCourseKey === course.key) {
                    // window.clearHighlights();
                    // } else {
                    // window.highlightRelatedCourses(course.key);
                    // }
                    // }

                    // if ((e.key === 'i' || e.key === 'I') && courseDiv.getAttribute('data-has-notes') === 'true') {
                    // e.preventDefault();
                    // const rect = courseDiv.getBoundingClientRect();
                    // const syntheticEvent = {
                    // clientX: rect.left + rect.width / 2,
                    // clientY: rect.top + rect.height / 2,
                    // stopPropagation: () => {}
                    // };
                    // showNotesTooltip(course.key, syntheticEvent, courseDiv);
                    // }

                    // if ((e.key === 'a' || e.key === 'A') && courseDiv.getAttribute('data-has-alternatives') === 'true') {
                    // e.preventDefault();
                    // const rect = courseDiv.getBoundingClientRect();
                    // const syntheticEvent = {
                    // clientX: rect.left + rect.width / 2,
                    // clientY: rect.bottom,
                    // stopPropagation: () => {}
                    // };
                    // const altIndicator = courseDiv.querySelector('.alternatives-indicator');
                    // showAlternativesTooltip(course.key, syntheticEvent, altIndicator);
                    // }
                    // });
                    
                    column.appendChild(courseDiv);
                });
                
                container.appendChild(column);
            });

            // Only reset scroll position on initial load, not on program switch
            if (!isProgramSwitch) {
                setTimeout(() => {
                    centerFlowchartOnInit();
                }, 0);
            }
        }

        function centerFlowchartOnInit() {
            const wrapper = domCache.visualView;
            if (!wrapper) return;

            // Always start with Year 1 Fall visible (leftmost position)
            wrapper.scrollLeft = 0;
        }

        window.switchProgram = function() {
            const select = domCache.programSelect;
            if (!select) return;

            const newProgram = select.value;

            if (newProgram === currentProgram) return;

            // Save current scroll position before switching
            const wrapper = domCache.visualView;
            const savedScrollLeft = wrapper ? wrapper.scrollLeft : 0;

            // Close any open tooltips
            closeNotesTooltip();
            closeAlternativesTooltip();

            // Clear highlights
            window.clearHighlights();

            // Update current program
            currentProgram = newProgram;
            courseData = programsData[currentProgram].courseData;
            semesterOrder = programsData[currentProgram].semesterOrder;

            // Update global references
            window.courseData = courseData;
            window.semesterOrder = semesterOrder;

            // Update page title
            const programTitle = domCache.programTitle;
            if (programTitle) {
                programTitle.textContent = programsData[currentProgram].fullTitle;
            }

            // Clear existing flowchart and text view efficiently
            const flowchartContainer = domCache.flowchartContainer;
            const textContent = domCache.textContent;
            const svg = domCache.connectionsSvg;

            // Clear course element cache since DOM is being rebuilt
            clearCourseElementCache();

            // Preserve the SVG element before clearing
            const svgElement = svg ? svg.cloneNode(false) : null;

            // Clear containers efficiently
            if (flowchartContainer) {
                while (flowchartContainer.firstChild) {
                    flowchartContainer.removeChild(flowchartContainer.firstChild);
                }
            }
            if (textContent) {
                while (textContent.firstChild) {
                    textContent.removeChild(textContent.firstChild);
                }
            }

            // Re-add the SVG element to the container
            if (svgElement && flowchartContainer) {
                // Update cache reference
                domCache.connectionsSvg = svgElement;
                flowchartContainer.appendChild(svgElement);
            }

            // Rebuild everything (with scroll preservation flag)
            leadsToMap = buildLeadsToMap();
            buildFlowchart(true); // Pass true to indicate program switch
            buildTextView();
            setupScrollIndicators();
            createArrowMarkers();
            updateSVGSize();

            // Draw all connections automatically on load (static version)
            setTimeout(() => {
                drawAllConnections();
            }, 100);

            // Restore scroll position after rebuild
            if (wrapper) {
                setTimeout(() => {
                    wrapper.scrollLeft = savedScrollLeft;
                    updateActiveIndicator();
                }, 10);
            }

            // Announce the change
            const announcer = domCache.announcements;
            if (announcer) {
                announcer.textContent = `Switched to ${programsData[currentProgram].name} program.`;
            }
        };

        // Disclaimer Modal Functions
        let modalPreviousFocus = null;

        // Utility function to safely write to localStorage
        function safeLocalStorageSet(key, value) {
            // Validate key to prevent prototype pollution
            if (typeof key !== 'string' || key.includes('__proto__') || key.includes('constructor') || key.includes('prototype')) {
                console.warn('Invalid localStorage key');
                return false;
            }

            try {
                // Only store boolean true as string 'true'
                const sanitizedValue = value === true ? 'true' : 'false';
                localStorage.setItem(key, sanitizedValue);
                return true;
            } catch (e) {
                // localStorage might be disabled or full
                console.warn('Could not save to localStorage');
                return false;
            }
        }

        // Utility function to safely read from localStorage
        function safeLocalStorageGet(key) {
            // Validate key
            if (typeof key !== 'string' || key.includes('__proto__') || key.includes('constructor') || key.includes('prototype')) {
                console.warn('Invalid localStorage key');
                return null;
            }

            try {
                const value = localStorage.getItem(key);
                // Validate that value is exactly 'true' or 'false'
                if (value === 'true') {
                    return true;
                } else if (value === 'false') {
                    return false;
                }
                return null;
            } catch (e) {
                // localStorage might be disabled
                console.warn('Could not read from localStorage');
                return null;
            }
        }

        window.closeDisclaimerModal = function() {
            const modal = domCache.disclaimerModal;
            if (modal) {
                modal.classList.add('hidden');
                // Remove focus trap
                removeFocusTrap(modal);
                // Store that user has seen the disclaimer
                safeLocalStorageSet('flowchartDisclaimerShown', true);
                // Return focus to previously focused element
                if (modalPreviousFocus && modalPreviousFocus.focus) {
                    modalPreviousFocus.focus();
                }
            }
        };

        // Focus trap for modal
        let modalFocusTrapHandler = null;

        function trapFocus(element) {
            const focusableElements = element.querySelectorAll(
                'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
            );
            const firstFocusable = focusableElements[0];
            const lastFocusable = focusableElements[focusableElements.length - 1];

            // Remove previous handler if it exists
            if (modalFocusTrapHandler) {
                element.removeEventListener('keydown', modalFocusTrapHandler);
            }

            // Create and store new handler
            modalFocusTrapHandler = function(e) {
                if (e.key !== 'Tab') return;

                if (e.shiftKey) {
                    if (document.activeElement === firstFocusable) {
                        lastFocusable.focus();
                        e.preventDefault();
                    }
                } else {
                    if (document.activeElement === lastFocusable) {
                        firstFocusable.focus();
                        e.preventDefault();
                    }
                }
            };

            element.addEventListener('keydown', modalFocusTrapHandler);
        }

        function removeFocusTrap(element) {
            if (modalFocusTrapHandler) {
                element.removeEventListener('keydown', modalFocusTrapHandler);
                modalFocusTrapHandler = null;
            }
        }

        function checkAndShowDisclaimer() {
            // Use safe localStorage getter
            const hasSeenDisclaimer = safeLocalStorageGet('flowchartDisclaimerShown');

            const modal = domCache.disclaimerModal;
            if (modal) {
                // Show modal if user hasn't seen it (null or false)
                if (hasSeenDisclaimer === true) {
                    modal.classList.add('hidden');
                } else {
                    modal.classList.remove('hidden');
                    // Store current focus
                    modalPreviousFocus = document.activeElement;
                    // Set up focus trap
                    trapFocus(modal);
                    // Focus the button for keyboard accessibility
                    setTimeout(() => {
                        const button = modal.querySelector('.modal-button');
                        if (button) button.focus();
                    }, 100);
                }
            }
        }

        // Allow Escape key to close modal
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const modal = domCache.disclaimerModal;
                if (modal && !modal.classList.contains('hidden')) {
                    closeDisclaimerModal();
                    return;
                }
            }

            const focusedElement = document.activeElement;

            const notesTooltip = domCache.notesTooltip;
            const alternativesTooltip = domCache.alternativesTooltip;

            if (e.key === 'Escape') {
                if (notesTooltip && notesTooltip.classList.contains('visible')) {
                    closeNotesTooltip();
                }

                if (alternativesTooltip && alternativesTooltip.classList.contains('visible')) {
                    closeAlternativesTooltip();
                }

                window.clearHighlights();
                return;
            }

            if (e.key === 'v' || e.key === 'V') {
                if (!focusedElement.matches('input, textarea')) {
                    toggleView();
                }
                return;
            }

            if (!focusedElement.classList.contains('course')) return;

            const allCourses = Array.from(document.querySelectorAll('.course'));
            const currentIndex = allCourses.indexOf(focusedElement);
            let nextIndex = currentIndex;

            const currentColumn = focusedElement.closest('.semester-column');
            const columns = Array.from(document.querySelectorAll('.semester-column'));
            const columnIndex = columns.indexOf(currentColumn);
            const coursesInColumn = Array.from(currentColumn.querySelectorAll('.course'));
            const positionInColumn = coursesInColumn.indexOf(focusedElement);

            switch(e.key) {
                case 'ArrowRight':
                    e.preventDefault();
                    if (columnIndex < columns.length - 1) {
                        const nextColumn = columns[columnIndex + 1];
                        const nextColumnCourses = Array.from(nextColumn.querySelectorAll('.course'));
                        const targetCourse = nextColumnCourses[Math.min(positionInColumn, nextColumnCourses.length - 1)];
                        if (targetCourse) targetCourse.focus();
                    }
                    break;

                case 'ArrowLeft':
                    e.preventDefault();
                    if (columnIndex > 0) {
                        const prevColumn = columns[columnIndex - 1];
                        const prevColumnCourses = Array.from(prevColumn.querySelectorAll('.course'));
                        const targetCourse = prevColumnCourses[Math.min(positionInColumn, prevColumnCourses.length - 1)];
                        if (targetCourse) targetCourse.focus();
                    }
                    break;

                case 'ArrowDown':
                    e.preventDefault();
                    if (positionInColumn < coursesInColumn.length - 1) {
                        coursesInColumn[positionInColumn + 1].focus();
                    }
                    break;

                case 'ArrowUp':
                    e.preventDefault();
                    if (positionInColumn > 0) {
                        coursesInColumn[positionInColumn - 1].focus();
                    }
                    break;
            }
        });

        // Function to populate program selector dynamically
        function populateProgramSelector() {
            console.log('populateProgramSelector called');
            const select = domCache.programSelect;
            console.log('select element:', select);
            if (!select) return;
            
            // Safety check: ensure programsData is loaded
            if (typeof programsData === 'undefined' || !programsData) {
                console.warn('programsData not loaded yet, retrying...');
                setTimeout(populateProgramSelector, 100);
                return;
            }
            
            console.log('programsData available, keys:', Object.keys(programsData));

            // Clear existing options efficiently
            while (select.firstChild) {
                select.removeChild(select.firstChild);
            }

            // Get all programs and add version metadata
            const programs = Object.keys(programsData).map(key => {
                const program = programsData[key];
                console.log(`Processing ${key}:`, program);
                let displayLabel = program.name || 'Unknown Program';
                
                // Get status with fallback
                const status = program.status || 'current';
                const version = program.version || '1.0';
                const effectiveDate = program.effectiveDate || '';
                const effectiveUntil = program.effectiveUntil || '';
                
                console.log(`  - Status: ${status}, EffectiveDate: "${effectiveDate}", effectiveUntil: "${effectiveUntil}"`);
                
                // Debug logging (remove in production if needed)
                if (!effectiveDate && status === 'current') {
                    console.warn(`Missing effectiveDate for ${key}:`, program);
                }
                
                // Add version information to label based on status
                if (status === 'current') {
                    displayLabel += ` (Current - Effective ${effectiveDate})`;
                } else if (status === 'proposed') {
                    displayLabel += ` (Proposed - Effective ${effectiveDate})`;
                } else if (status === 'archived') {
                    if (effectiveUntil) {
                        displayLabel += ` (Archived - Effective Until ${effectiveUntil})`;
                    } else {
                        displayLabel += ` (Archived - v${version})`;
                    }
                }
                
                console.log(`  - Final label: "${displayLabel}"`);
                
                return {
                    key: key,
                    name: program.name || 'Unknown',
                    displayLabel: displayLabel,
                    status: status,
                    effectiveDate: effectiveDate,
                    sortOrder: status === 'current' ? 1 : status === 'proposed' ? 2 : 3
                };
            });

            console.log('Programs array:', programs);

            // Sort: Current first, then proposed, then archived. CHE always first within each group
            programs.sort((a, b) => {
                // Sort by status first (current < proposed < archived)
                if (a.sortOrder !== b.sortOrder) {
                    return a.sortOrder - b.sortOrder;
                }
                
                // Within same status, CHE always first
                if (a.key === 'CHE' || a.key.startsWith('CHE-')) return -1;
                if (b.key === 'CHE' || b.key.startsWith('CHE-')) return 1;
                
                // Otherwise sort alphabetically by name
                return a.name.localeCompare(b.name);
            });

            console.log('Sorted programs:', programs);

            // Add all programs as individual options
            programs.forEach(program => {
                console.log(`Adding option: ${program.displayLabel}`);
                const option = document.createElement('option');
                option.value = program.key;
                option.textContent = program.displayLabel;
                select.appendChild(option);
            });
            
            console.log('Dropdown populated with', programs.length, 'options');
        }

        document.addEventListener('DOMContentLoaded', function() {
            try {
                // Initialize DOM cache first
                initDOMCache();

                // Set print date for footer
                try {
                    const printDate = new Date().toLocaleDateString('en-US', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric'
                    });
                    document.body.setAttribute('data-print-date', printDate);
                } catch (error) {
                    console.error('Error setting print date:', error);
                }

                // Populate program selector from programsData
                try {
                    populateProgramSelector();
                } catch (error) {
                    console.error('Error populating program selector:', error);
                }

                // Check and show disclaimer if needed
                try {
                    checkAndShowDisclaimer();
                } catch (error) {
                    console.error('Error checking disclaimer:', error);
                }

                // Check for URL parameter to set initial program
                try {
                    const urlParams = new URLSearchParams(window.location.search);
                    const programParam = urlParams.get('program');

                    // Validate program parameter against whitelist
                    if (programParam) {
                        // Sanitize input - only allow alphanumeric, hyphens, and underscores
                        const sanitizedParam = programParam.replace(/[^a-zA-Z0-9\-_]/g, '');

                        // Check if sanitized param exists in programsData
                        if (sanitizedParam && Object.prototype.hasOwnProperty.call(programsData, sanitizedParam)) {
                            currentProgram = sanitizedParam;
                            courseData = programsData[currentProgram].courseData;
                            semesterOrder = programsData[currentProgram].semesterOrder;
                            window.courseData = courseData;
                            window.semesterOrder = semesterOrder;

                            // Update dropdown
                            const select = domCache.programSelect;
                            if (select) select.value = currentProgram;

                            // Update title
                            const programTitle = domCache.programTitle;
                            if (programTitle) {
                                programTitle.textContent = programsData[currentProgram].fullTitle;
                            }
                        } else {
                            // Invalid program parameter - log but continue with default
                            console.warn('Invalid program parameter provided');
                        }
                    }
                } catch (error) {
                    console.error('Error processing URL parameters:', error);
                }

                // Build and render flowchart
                try {
                    leadsToMap = buildLeadsToMap();
                    buildFlowchart();
                    buildTextView();
                    setupScrollIndicators();
                    createArrowMarkers();
                    updateSVGSize();

            // Draw all connections automatically on load (static version)
            setTimeout(() => {
                drawAllConnections();
            }, 100);
                } catch (error) {
                    console.error('Error building flowchart:', error);
                    alert('Error loading flowchart. Please refresh the page.');
                }

                // Initialize dot states after everything is rendered
                try {
                    setTimeout(() => {
                        updateActiveIndicator();
                    }, 100);
                } catch (error) {
                    console.error('Error initializing scroll indicators:', error);
                }

                // Add resize listener
                try {
                    window.addEventListener('resize', updateSVGSize);
                } catch (error) {
                    console.error('Error adding resize listener:', error);
                }

                // Add event listeners for buttons
                try {
                    const disclaimerButton = domCache.disclaimerModal?.querySelector('.modal-button');
                    if (disclaimerButton) {
                        disclaimerButton.addEventListener('click', closeDisclaimerModal);
                    }

                    const guideToggle = domCache.guideToggle;
                    if (guideToggle) {
                        guideToggle.addEventListener('click', toggleGuide);
                    }

                    const toggleBtn = domCache.toggleBtn;
                    if (toggleBtn) {
                        toggleBtn.addEventListener('click', toggleView);
                    }

                    const closeNotesBtn = domCache.notesTooltip?.querySelector('#closeNotesBtn');
                    if (closeNotesBtn) {
                        closeNotesBtn.addEventListener('click', closeNotesTooltip);
                    }

                    const closeAlternativesBtn = domCache.alternativesTooltip?.querySelector('#closeAlternativesBtn');
                    if (closeAlternativesBtn) {
                        closeAlternativesBtn.addEventListener('click', closeAlternativesTooltip);
                    }

                    const programSelect = domCache.programSelect;
                    if (programSelect) {
                        programSelect.addEventListener('change', switchProgram);
                    }

                    document.addEventListener('click', (e) => {
                        // Close tooltips if clicking outside
                        const notesTooltip = domCache.notesTooltip;
                        const alternativesTooltip = domCache.alternativesTooltip;

                        if (notesTooltip && notesTooltip.classList.contains('visible')) {
                            if (!e.target.closest('#notesTooltip') && !e.target.closest('.notes-indicator')) {
                                closeNotesTooltip();
                            }
                        }

                        if (alternativesTooltip && alternativesTooltip.classList.contains('visible')) {
                            if (!e.target.closest('#alternativesTooltip') && !e.target.closest('.alternatives-indicator')) {
                                closeAlternativesTooltip();
                            }
                        }

                        // Clear course highlights if clicking outside
                        if (!e.target.closest('.course') && selectedCourseKey) {
                            window.clearHighlights();
                        }
                    });
                } catch (error) {
                    console.error('Error setting up event listeners:', error);
                }
            } catch (error) {
                console.error('Critical error during initialization:', error);
                alert('An error occurred while loading the application. Please refresh the page.');
            }
        });
        
        function setupScrollIndicators() {
            const container = domCache.flowchartContainer;
            const indicatorsDiv = domCache.scrollIndicators;
            const wrapper = domCache.visualView;

            if (!container || !indicatorsDiv || !wrapper) return;

            // Clear existing indicators efficiently
            while (indicatorsDiv.firstChild) {
                indicatorsDiv.removeChild(indicatorsDiv.firstChild);
            }

            semesterOrder.forEach((semester, index) => {
                const dot = document.createElement('button');
                dot.className = 'scroll-dot';
                dot.setAttribute('type', 'button');

                if (index === 0) {
                    dot.classList.add('active');
                    dot.setAttribute('aria-label', `Jump to ${semester} (current)`);
                } else {
                    dot.setAttribute('aria-label', `Jump to ${semester}`);
                }
                
                dot.addEventListener('click', () => {
                    const columns = container.querySelectorAll('.semester-column');
                    if (columns[index]) {
                        columns[index].scrollIntoView({
                            behavior: 'smooth',
                            block: 'nearest',
                            inline: 'start'
                        });
                        // Move focus to first course in the scrolled semester
                        setTimeout(() => {
                            const firstCourse = columns[index].querySelector('.course');
                            if (firstCourse) {
                                firstCourse.focus();
                            }
                        }, 500);
                    }
                });
                
                indicatorsDiv.appendChild(dot);
            });
            
            let scrollTimeout;
            wrapper.addEventListener('scroll', () => {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    updateActiveIndicator();
                }, 100);
            });
        }
        
        function updateActiveIndicator() {
            const wrapper = domCache.visualView;
            const container = domCache.flowchartContainer;
            const dots = document.querySelectorAll('.scroll-dot');

            if (!wrapper || !container || dots.length === 0) return;
            
            const scrollLeft = wrapper.scrollLeft;
            const wrapperWidth = wrapper.clientWidth;
            const scrollWidth = wrapper.scrollWidth;
            const columns = container.querySelectorAll('.semester-column');
            
            const visibleLeft = scrollLeft;
            const visibleRight = scrollLeft + wrapperWidth;
            
            if (scrollLeft + wrapperWidth >= scrollWidth - 5) {
                dots.forEach((dot, index) => {
                    const semester = window.semesterOrder[index];
                    if (index === dots.length - 1) {
                        dot.classList.add('active');
                        dot.setAttribute('aria-label', `Jump to ${semester} (current)`);
                    } else {
                        dot.classList.remove('active');
                        dot.setAttribute('aria-label', `Jump to ${semester}`);
                    }
                    
                    const column = columns[index];
                    const columnLeft = column.offsetLeft - container.offsetLeft;
                    const columnRight = columnLeft + column.offsetWidth;
                    const isInView = columnRight > visibleLeft && columnLeft < visibleRight;
                    
                    if (isInView) {
                        dot.classList.remove('out-of-view');
                    } else {
                        dot.classList.add('out-of-view');
                    }
                });
                return;
            }
            
            if (scrollLeft <= 5) {
                dots.forEach((dot, index) => {
                    const semester = window.semesterOrder[index];
                    if (index === 0) {
                        dot.classList.add('active');
                        dot.setAttribute('aria-label', `Jump to ${semester} (current)`);
                    } else {
                        dot.classList.remove('active');
                        dot.setAttribute('aria-label', `Jump to ${semester}`);
                    }
                    
                    const column = columns[index];
                    const columnLeft = column.offsetLeft - container.offsetLeft;
                    const columnRight = columnLeft + column.offsetWidth;
                    const isInView = columnRight > visibleLeft && columnLeft < visibleRight;
                    
                    if (isInView) {
                        dot.classList.remove('out-of-view');
                    } else {
                        dot.classList.add('out-of-view');
                    }
                });
                return;
            }
            
            let activeIndex = 0;
            let minDistance = Infinity;
            
            columns.forEach((column, index) => {
                const columnLeft = column.offsetLeft - container.offsetLeft;
                const distance = Math.abs(scrollLeft - columnLeft);
                
                if (distance < minDistance) {
                    minDistance = distance;
                    activeIndex = index;
                }
            });
            
            dots.forEach((dot, index) => {
                const semester = window.semesterOrder[index];
                if (index === activeIndex) {
                    dot.classList.add('active');
                    dot.setAttribute('aria-label', `Jump to ${semester} (current)`);
                } else {
                    dot.classList.remove('active');
                    dot.setAttribute('aria-label', `Jump to ${semester}`);
                }
                
                const column = columns[index];
                const columnLeft = column.offsetLeft - container.offsetLeft;
                const columnRight = columnLeft + column.offsetWidth;
                const isInView = columnRight > visibleLeft && columnLeft < visibleRight;
                
                if (isInView) {
                    dot.classList.remove('out-of-view');
                } else {
                    dot.classList.add('out-of-view');
                }
            });
        }
        
        function buildTextView() {
            const container = domCache.textContent;
            if (!container) return;

            const courseBySemester = {};
            semesterOrder.forEach(sem => courseBySemester[sem] = []);

            Object.entries(courseData).forEach(([key, course]) => {
                courseBySemester[course.semester].push({key, ...course});
            });

            semesterOrder.forEach(semester => {
                const semesterDiv = document.createElement('div');
                semesterDiv.className = 'text-semester';

                const header = document.createElement('h3');
                header.textContent = semester;
                semesterDiv.appendChild(header);

                courseBySemester[semester].forEach(course => {
                    const courseDiv = document.createElement('div');
                    courseDiv.className = `text-course ${course.type}`;

                    const heading = document.createElement('h4');
                    heading.textContent = `${course.code} - ${course.name} (${course.credits} credits)`;
                    courseDiv.appendChild(heading);

                    if (course.semesterRestriction) {
                        const restrictionP = document.createElement('p');
                        restrictionP.innerHTML = `<strong>Availability:</strong> ${course.semesterRestriction} only`;
                        restrictionP.style.color = '#D2691E';
                        restrictionP.style.fontWeight = '600';
                        courseDiv.appendChild(restrictionP);
                    }

                    const prereqP = document.createElement('p');
                    if (course.prereqs.length > 0) {
                        const prereqNames = course.prereqs.map(p => courseData[p]?.code || p).join(', ');
                        prereqP.innerHTML = `<strong>Prerequisites:</strong> ${prereqNames}`;
                    } else {
                        prereqP.innerHTML = `<strong>Prerequisites:</strong> None`;
                    }
                    courseDiv.appendChild(prereqP);

                    if (course.coreqs.length > 0) {
                        const coreqP = document.createElement('p');
                        const coreqNames = course.coreqs.map(c => courseData[c]?.code || c).join(', ');
                        coreqP.innerHTML = `<strong>Co-requisites:</strong> ${coreqNames}`;
                        courseDiv.appendChild(coreqP);
                    }

                    if (course.alternatives && course.alternatives.length > 0) {
                        const altP = document.createElement('p');
                        if (course.alternatives.length === 1) {
                            altP.innerHTML = `<strong>Alternative:</strong> ${course.alternatives[0]}`;
                        } else {
                            const altList = course.alternatives.map((alt, index) =>
                                `<br>&nbsp;&nbsp;Option ${index + 1}: ${alt}`
                            ).join('');
                            altP.innerHTML = `<strong>Alternatives:</strong>${altList}`;
                        }
                        courseDiv.appendChild(altP);
                    }

                    if (course.notes && course.notes.trim() !== '') {
                        const notesP = document.createElement('p');
                        notesP.style.fontStyle = 'italic';
                        notesP.style.color = '#444';

                        // Add "Notes:" label
                        const strong = document.createElement('strong');
                        strong.textContent = 'Notes: ';
                        notesP.appendChild(strong);

                        // Safely create links from notes text
                        const safeContent = createSafeLinksFromText(course.notes);
                        notesP.appendChild(safeContent);

                        courseDiv.appendChild(notesP);
                    }

                    semesterDiv.appendChild(courseDiv);
                });

                container.appendChild(semesterDiv);
            });
        }

        window.toggleGuide = function() {
            const heading = domCache.guideToggle;
            const content = domCache.guideContent;

            if (!heading || !content) return;

            const isCollapsed = heading.classList.toggle('collapsed');
            content.classList.toggle('hidden');

            heading.setAttribute('aria-expanded', !isCollapsed);
        };

        let currentView = 'visual';
        window.toggleView = function() {
            const visualView = domCache.visualView;
            const textView = domCache.textView;
            const scrollControls = domCache.scrollControls;
            const btn = domCache.toggleBtn;
            const announcer = domCache.announcements;

            if (!visualView || !textView || !btn) return;

            if (currentView === 'visual') {
                visualView.style.display = 'none';
                textView.style.display = 'block';
                scrollControls.style.display = 'none';
                btn.textContent = 'Switch to Visual Flowchart';

                if (announcer) {
                    announcer.textContent = 'Switched to text-only view. Courses are now listed by semester with full details.';
                }

                currentView = 'text';

                // Move focus to the first heading in text view
                setTimeout(() => {
                    const firstHeading = textView.querySelector('h3');
                    if (firstHeading) {
                        firstHeading.setAttribute('tabindex', '-1');
                        firstHeading.focus();
                    }
                }, 100);
            } else {
                visualView.style.display = 'block';
                textView.style.display = 'none';
                scrollControls.style.display = 'block';
                btn.textContent = 'Switch to Text-Only View';

                if (announcer) {
                    announcer.textContent = 'Switched to visual flowchart view. Interactive course boxes are now displayed.';
                }

                currentView = 'visual';

                // Move focus to the first course in visual view
                setTimeout(() => {
                    const firstCourse = visualView.querySelector('.course');
                    if (firstCourse) {
                        firstCourse.focus();
                    }
                }, 100);
            }
        };
    </script>
</body>
</html>
